// Automatically generated by Packet Go code generator.
package openflowv10

import (
  "encoding/binary"
  "errors"
  "fmt"
  "net"

  "github.com/packet/packet/src/go/packet"

  "github.com/soheilhy/beehive/openflow/openflow"
)

type OpenflowPorts int

const (
  OFPP_MAX OpenflowPorts = 65280
  OFPP_IN_PORT OpenflowPorts = 65528
  OFPP_TABLE OpenflowPorts = 65529
  OFPP_NORMAL OpenflowPorts = 65530
  OFPP_FLOOD OpenflowPorts = 65531
  OFPP_ALL OpenflowPorts = 65532
  OFPP_CONTROLLER OpenflowPorts = 65533
  OFPP_LOCAL OpenflowPorts = 65534
  OFPP_NONE OpenflowPorts = 65535
)

type Openflow10Type int

const (
  OFPT_PACKET_IN Openflow10Type = 10
  OFPT_FLOW_REMOVED Openflow10Type = 11
  OFPT_PORT_STATUS Openflow10Type = 12
  OFPT_PACKET_OUT Openflow10Type = 13
  OFPT_FLOW_MOD Openflow10Type = 14
  OFPT_PORT_MOD Openflow10Type = 15
  OFPT_STATS_REQUEST Openflow10Type = 16
  OFPT_STATS_REPLY Openflow10Type = 17
  OFPT_BARRIER_REQUEST Openflow10Type = 18
  OFPT_BARRIER_REPLY Openflow10Type = 19
  OFPT_QUEUE_GET_CONFIG_REQUEST Openflow10Type = 20
  OFPT_QUEUE_GET_CONFIG_REPLY Openflow10Type = 21
)

type OpenflowConfigFlags int

const (
  OFPC_FRAG_NORMAL OpenflowConfigFlags = 0
  OFPC_FRAG_DROP OpenflowConfigFlags = 1
  OFPC_FRAG_REASM OpenflowConfigFlags = 2
  OFPC_FRAG_MASK OpenflowConfigFlags = 3
)

type OpenflowCapabilities int

const (
  OFPC_FLOW_STATS OpenflowCapabilities = 1
  OFPC_TABLE_STATS OpenflowCapabilities = 2
  OFPC_PORT_STATS OpenflowCapabilities = 4
  OFPC_STP OpenflowCapabilities = 8
  OFPC_RESERVED OpenflowCapabilities = 16
  OFPC_IP_REASM OpenflowCapabilities = 32
  OFPC_QUEUE_STATS OpenflowCapabilities = 64
  OFPC_ARP_MATCH_IP OpenflowCapabilities = 128
)

type OpenflowPortConfig int

const (
  OFPPC_PORT_DOWN OpenflowPortConfig = 1
  OFPPC_NO_STP OpenflowPortConfig = 2
  OFPPC_NO_RECV OpenflowPortConfig = 4
  OFPPC_NO_RECV_STP OpenflowPortConfig = 8
  OFPPC_NO_FLOOD OpenflowPortConfig = 16
  OFPPC_NO_FWD OpenflowPortConfig = 32
  OFPPC_NO_PACKET_IN OpenflowPortConfig = 64
)

type OpenflowPortState int

const (
  OFPPS_LINK_DOWN OpenflowPortState = 1
  OFPPS_STP_LISTEN OpenflowPortState = 0
  OFPPS_STP_LEARN OpenflowPortState = 256
  OFPPS_STP_FORWARD OpenflowPortState = 512
  OFPPS_STP_BLOCK OpenflowPortState = 768
  OFPPS_STP_MASK OpenflowPortState = 768
)

type OpenflowPortFeatures int

const (
  OFPPF_10MB_HD OpenflowPortFeatures = 0
  OFPPF_10MB_FD OpenflowPortFeatures = 2
  OFPPF_100MB_HD OpenflowPortFeatures = 4
  OFPPF_100MB_FD OpenflowPortFeatures = 8
  OFPPF_1GB_HD OpenflowPortFeatures = 16
  OFPPF_1GB_FD OpenflowPortFeatures = 32
  OFPPF_10GB_FD OpenflowPortFeatures = 64
  OFPPF_COPPER OpenflowPortFeatures = 128
  OFPPF_FIBER OpenflowPortFeatures = 256
  OFPPF_AUTONEG OpenflowPortFeatures = 512
  OFPPF_PAUSE OpenflowPortFeatures = 1024
  OFPPF_PAUSE_ASYM OpenflowPortFeatures = 2048
)

type OpenflowPortReason int

const (
  OFPPR_ADD OpenflowPortReason = 0
  OFPPR_DELETE OpenflowPortReason = 1
  OFPPR_MODIFY OpenflowPortReason = 2
)

type OpenflowPacketInReason int

const (
  OFPR_NO_MATCH OpenflowPacketInReason = 0
  OFPR_ACTION OpenflowPacketInReason = 1
)

type OpenflowActionType int

const (
  OFPAT_OUTPUT OpenflowActionType = 0
  OFPAT_SET_VLAN_VID OpenflowActionType = 1
  OFPAT_SET_VLAN_PCP OpenflowActionType = 2
  OFPAT_STRIP_VLAN OpenflowActionType = 3
  OFPAT_SET_DL_SRC OpenflowActionType = 4
  OFPAT_SET_DL_DST OpenflowActionType = 5
  OFPAT_SET_NW_SRC OpenflowActionType = 6
  OFPAT_SET_NW_DST OpenflowActionType = 7
  OFPAT_SET_NW_TOS OpenflowActionType = 8
  OFPAT_SET_TP_SRC OpenflowActionType = 9
  OFPAT_SET_TP_DST OpenflowActionType = 10
  OFPAT_ENQUEUE OpenflowActionType = 11
  OFPAT_VENDOR OpenflowActionType = 65535
)

type OpenflowVlanIds int

const (
  OFP_VLAN_NONE OpenflowVlanIds = 65535
)

type OpenflowFlowModCommand int

const (
  OFPFC_ADD OpenflowFlowModCommand = 0
  OFPFC_MODIFY OpenflowFlowModCommand = 1
  OFPFC_MODIFY_STRICT OpenflowFlowModCommand = 2
  OFPFC_DELETE OpenflowFlowModCommand = 3
  OFPFC_DELETE_STRICT OpenflowFlowModCommand = 4
)

type OpenflowFlowWildcards int

const (
  OFPFW_IN_PORT OpenflowFlowWildcards = 1
  OFPFW_DL_VLAN OpenflowFlowWildcards = 2
  OFPFW_DL_SRC OpenflowFlowWildcards = 4
  OFPFW_DL_DST OpenflowFlowWildcards = 8
  OFPFW_DL_TYPE OpenflowFlowWildcards = 16
  OFPFW_NW_PROTO OpenflowFlowWildcards = 32
  OFPFW_TP_SRC OpenflowFlowWildcards = 64
  OFPFW_TP_DST OpenflowFlowWildcards = 128
  OFPFW_NW_SRC_SHIFT OpenflowFlowWildcards = 8
  OFPFW_NW_SRC_BITS OpenflowFlowWildcards = 5
  OFPFW_NW_SRC_MASK OpenflowFlowWildcards = 8
  OFPFW_NW_SRC_ALL OpenflowFlowWildcards = 8
  OFPFW_NW_DST_SHIFT OpenflowFlowWildcards = 14
  OFPFW_NW_DST_BITS OpenflowFlowWildcards = 6
  OFPFW_NW_DST_MASK OpenflowFlowWildcards = 14
  OFPFW_NW_DST_ALL OpenflowFlowWildcards = 14
  OFPFW_DL_VLAN_PCP OpenflowFlowWildcards = 1048576
  OFPFW_NW_TOS OpenflowFlowWildcards = 2097152
  OFPFW_ALL OpenflowFlowWildcards = 4194303
)

type OpenflowFlowModFlags int

const (
  OFPFF_SEND_FLOW_REM OpenflowFlowModFlags = 1
  OFPFF_CHECK_OVERLAP OpenflowFlowModFlags = 2
  OFPFF_EMERG OpenflowFlowModFlags = 4
)

type OpenflowFlowRemovedReason int

const (
  OFPRR_IDLE_TIMEOUT OpenflowFlowRemovedReason = 0
  OFPRR_HARD_TIMEOUT OpenflowFlowRemovedReason = 1
  OFPRR_DELETE OpenflowFlowRemovedReason = 2
)

type OpenflowErrorType int

const (
  OFPET_HELLO_FAILED OpenflowErrorType = 0
  OFPET_BAD_REQUEST OpenflowErrorType = 1
  OFPET_BAD_ACTION OpenflowErrorType = 2
  OFPET_FLOW_MOD_FAILED OpenflowErrorType = 3
  OFPET_PORT_MOD_FAILED OpenflowErrorType = 4
  OFPET_QUEUE_OP_FAILED OpenflowErrorType = 5
)

type OpenflowHelloFailedCode int

const (
  OFPHFC_INCOMPATIBLE OpenflowHelloFailedCode = 0
  OFPHFC_EPERM OpenflowHelloFailedCode = 1
)

type OpenflowBadRequestCode int

const (
  OFPBRC_BAD_VERSION OpenflowBadRequestCode = 0
  OFPBRC_BAD_TYPE OpenflowBadRequestCode = 1
  OFPBRC_BAD_STAT OpenflowBadRequestCode = 2
  OFPBRC_BAD_VENDOR OpenflowBadRequestCode = 3
  OFPBRC_BAD_SUBTYPE OpenflowBadRequestCode = 4
  OFPBRC_EPERM OpenflowBadRequestCode = 5
  OFPBRC_BAD_LEN OpenflowBadRequestCode = 6
  OFPBRC_BUFFER_EMPTY OpenflowBadRequestCode = 7
  OFPBRC_BUFFER_UNKNOWN OpenflowBadRequestCode = 8
)

type OpenflowBadActionCode int

const (
  OFPBAC_BAD_TYPE OpenflowBadActionCode = 0
  OFPBAC_BAD_LEN OpenflowBadActionCode = 1
  OFPBAC_BAD_VENDOR OpenflowBadActionCode = 2
  OFPBAC_BAD_VENDOR_TYPE OpenflowBadActionCode = 3
  OFPBAC_BAD_OUT_PORT OpenflowBadActionCode = 4
  OFPBAC_BAD_ARGUMENT OpenflowBadActionCode = 5
  OFPBAC_EPERM OpenflowBadActionCode = 6
  OFPBAC_TOO_MANY OpenflowBadActionCode = 7
  OFPBAC_BAD_QUEUE OpenflowBadActionCode = 8
)

type OpenflowFlow_modFailedCode int

const (
  OFPFMFC_ALL_TABLES_FULL OpenflowFlow_modFailedCode = 0
  OFPFMFC_OVERLAP OpenflowFlow_modFailedCode = 1
  OFPFMFC_EPERM OpenflowFlow_modFailedCode = 2
  OFPFMFC_BAD_EMERG_TIMEOUT OpenflowFlow_modFailedCode = 3
  OFPFMFC_BAD_COMMAND OpenflowFlow_modFailedCode = 4
  OFPFMFC_UNSUPPORTED OpenflowFlow_modFailedCode = 5
)

type OpenflowPort_modFailedCode int

const (
  OFPPMFC_BAD_PORT OpenflowPort_modFailedCode = 0
  OFPPMFC_BAD_HW_ADDR OpenflowPort_modFailedCode = 1
)

type OpenflowQueueOpFailedCode int

const (
  OFPQOFC_BAD_PORT OpenflowQueueOpFailedCode = 0
  OFPQOFC_BAD_QUEUE OpenflowQueueOpFailedCode = 1
  OFPQOFC_EPERM OpenflowQueueOpFailedCode = 2
)

type OpenflowStatsTypes int

const (
  OFPST_DESC OpenflowStatsTypes = 0
  OFPST_FLOW OpenflowStatsTypes = 1
  OFPST_AGGREGATE OpenflowStatsTypes = 2
  OFPST_TABLE OpenflowStatsTypes = 3
  OFPST_PORT OpenflowStatsTypes = 4
  OFPST_QUEUE OpenflowStatsTypes = 5
  OFPST_VENDOR OpenflowStatsTypes = 65535
)

type OpenflowStatsReplyFlags int

const (
  OFPSF_REPLY_MORE OpenflowStatsReplyFlags = 1
)

type OpenflowDescStatsConstants int

const (
  SERIAL_NUM_LEN OpenflowDescStatsConstants = 32
  DESC_STR_LEN OpenflowDescStatsConstants = 256
)

type OpenflowQueueProperties int

const (
  OFPQT_NONE OpenflowQueueProperties = 0
  OFPQT_MIN_RATE OpenflowQueueProperties = 1
)

func NewOpenflowHeaderV10WithBuf(b []byte) OpenflowHeaderV10 {
  return OpenflowHeaderV10{openflow.OpenflowHeader{packet.Packet{Buf: b}}}
}

func NewOpenflowHeaderV10() OpenflowHeaderV10 {
  s := 8
  b := make([]byte, s)
  p := OpenflowHeaderV10{openflow.OpenflowHeader{packet.Packet{Buf: b}}}
  p.Init()
  return p
}

type OpenflowHeaderV10 struct {
  openflow.OpenflowHeader
}

func (this OpenflowHeaderV10) minSize() int {
  return 8
}

type OpenflowHeaderV10Conn struct {
  net.Conn
  buf []byte
  offset int
}

func NewOpenflowHeaderV10Conn(c net.Conn) OpenflowHeaderV10Conn {
  return OpenflowHeaderV10Conn {
    Conn: c,
    buf: make([]byte, packet.DefaultBufSize),
  }
}

func (c *OpenflowHeaderV10Conn) Write(pkts []OpenflowHeaderV10) error {
  for _, p := range pkts {
    s := p.Size()
    b := p.Buffer()[:s]
    n := 0
    for s > 0 {
      var err error
      if n, err = c.Conn.Write(b); err != nil {
        return fmt.Errorf("Error in write: %v", err)
      }
      s -= n
    }
  }
  return nil
}

func (c *OpenflowHeaderV10Conn) Read(pkts []OpenflowHeaderV10) (int, error) {
  if len(c.buf) == c.offset {
    newSize := packet.DefaultBufSize
    if newSize < len(c.buf) {
      newSize = 2 * len(c.buf)
    }

    buf := make([]byte, newSize)
    copy(buf, c.buf[:c.offset])
    c.buf = buf
  }

  r, err := c.Conn.Read(c.buf[c.offset:])
  if err != nil {
    return 0, err
  }

  r += c.offset

  s := 0
  n := 0
  for i := range pkts {
    p := NewOpenflowHeaderV10WithBuf(c.buf)

    pSize := p.Size()
    if r < s+pSize {
      break
    }

    pkts[i] = p
    s += pSize
    n++
  }

  c.offset = r - s
  if c.offset < 0 {
    panic("Invalid value for offset")
  }

  c.buf = c.buf[s:]
  if c.offset < len(c.buf) {
    return n, nil
  }

  buf := make([]byte, packet.DefaultBufSize)
  copy(buf, c.buf[:c.offset])
  c.buf = buf
  return n, nil
}

func (this *OpenflowHeaderV10) Init() {
  this.OpenflowHeader.Init()
  this.SetLength(uint16(this.minSize()))
  // Invariants.
  this.SetVersion(uint8(1)) // version
}

func (this OpenflowHeaderV10) Size() int {
  if len(this.Buf) < this.minSize() {
    return 0
  }

  size := int(this.Length())
  return size
}

func ConvertToOpenflowHeaderV10(p openflow.OpenflowHeader) (OpenflowHeaderV10, error) {
  if !IsOpenflowHeaderV10(p) {
    return NewOpenflowHeaderV10WithBuf(nil), errors.New("Cannot convert to openflowv10.OpenflowHeaderV10")
  }

  return NewOpenflowHeaderV10WithBuf(p.Buf), nil
}

func IsOpenflowHeaderV10(p openflow.OpenflowHeader) bool {
  return p.Version() == 1 && true
}

func NewOpenflowHelloWithBuf(b []byte) OpenflowHello {
  return OpenflowHello{openflow.OpenflowHello{openflow.OpenflowHeader{packet.Packet{Buf: b}}}}
}

func NewOpenflowHello() OpenflowHello {
  s := 8
  b := make([]byte, s)
  p := OpenflowHello{openflow.OpenflowHello{openflow.OpenflowHeader{packet.Packet{Buf: b}}}}
  p.Init()
  return p
}

type OpenflowHello struct {
  openflow.OpenflowHello
}

func (this OpenflowHello) minSize() int {
  return 8
}

type OpenflowHelloConn struct {
  net.Conn
  buf []byte
  offset int
}

func NewOpenflowHelloConn(c net.Conn) OpenflowHelloConn {
  return OpenflowHelloConn {
    Conn: c,
    buf: make([]byte, packet.DefaultBufSize),
  }
}

func (c *OpenflowHelloConn) Write(pkts []OpenflowHello) error {
  for _, p := range pkts {
    s := p.Size()
    b := p.Buffer()[:s]
    n := 0
    for s > 0 {
      var err error
      if n, err = c.Conn.Write(b); err != nil {
        return fmt.Errorf("Error in write: %v", err)
      }
      s -= n
    }
  }
  return nil
}

func (c *OpenflowHelloConn) Read(pkts []OpenflowHello) (int, error) {
  if len(c.buf) == c.offset {
    newSize := packet.DefaultBufSize
    if newSize < len(c.buf) {
      newSize = 2 * len(c.buf)
    }

    buf := make([]byte, newSize)
    copy(buf, c.buf[:c.offset])
    c.buf = buf
  }

  r, err := c.Conn.Read(c.buf[c.offset:])
  if err != nil {
    return 0, err
  }

  r += c.offset

  s := 0
  n := 0
  for i := range pkts {
    p := NewOpenflowHelloWithBuf(c.buf)

    pSize := p.Size()
    if r < s+pSize {
      break
    }

    pkts[i] = p
    s += pSize
    n++
  }

  c.offset = r - s
  if c.offset < 0 {
    panic("Invalid value for offset")
  }

  c.buf = c.buf[s:]
  if c.offset < len(c.buf) {
    return n, nil
  }

  buf := make([]byte, packet.DefaultBufSize)
  copy(buf, c.buf[:c.offset])
  c.buf = buf
  return n, nil
}

func (this *OpenflowHello) Init() {
  this.OpenflowHello.Init()
  this.SetLength(uint16(this.minSize()))
  // Invariants.
  this.SetVersion(uint8(1)) // version
  this.SetType(uint8(0)) // type
}

func (this OpenflowHello) Size() int {
  if len(this.Buf) < this.minSize() {
    return 0
  }

  size := int(this.Length())
  return size
}

func ConvertToOpenflowHello(p openflow.OpenflowHello) (OpenflowHello, error) {
  if !IsOpenflowHello(p) {
    return NewOpenflowHelloWithBuf(nil), errors.New("Cannot convert to openflowv10.OpenflowHello")
  }

  return NewOpenflowHelloWithBuf(p.Buf), nil
}

func IsOpenflowHello(p openflow.OpenflowHello) bool {
  return p.Version() == 1 && true
}

func NewOpenflowEchoRequestWithBuf(b []byte) OpenflowEchoRequest {
  return OpenflowEchoRequest{OpenflowHeaderV10{openflow.OpenflowHeader{packet.Packet{Buf: b}}}}
}

func NewOpenflowEchoRequest() OpenflowEchoRequest {
  s := 8
  b := make([]byte, s)
  p := OpenflowEchoRequest{OpenflowHeaderV10{openflow.OpenflowHeader{packet.Packet{Buf: b}}}}
  p.Init()
  return p
}

type OpenflowEchoRequest struct {
  OpenflowHeaderV10
}

func (this OpenflowEchoRequest) minSize() int {
  return 8
}

type OpenflowEchoRequestConn struct {
  net.Conn
  buf []byte
  offset int
}

func NewOpenflowEchoRequestConn(c net.Conn) OpenflowEchoRequestConn {
  return OpenflowEchoRequestConn {
    Conn: c,
    buf: make([]byte, packet.DefaultBufSize),
  }
}

func (c *OpenflowEchoRequestConn) Write(pkts []OpenflowEchoRequest) error {
  for _, p := range pkts {
    s := p.Size()
    b := p.Buffer()[:s]
    n := 0
    for s > 0 {
      var err error
      if n, err = c.Conn.Write(b); err != nil {
        return fmt.Errorf("Error in write: %v", err)
      }
      s -= n
    }
  }
  return nil
}

func (c *OpenflowEchoRequestConn) Read(pkts []OpenflowEchoRequest) (int, error) {
  if len(c.buf) == c.offset {
    newSize := packet.DefaultBufSize
    if newSize < len(c.buf) {
      newSize = 2 * len(c.buf)
    }

    buf := make([]byte, newSize)
    copy(buf, c.buf[:c.offset])
    c.buf = buf
  }

  r, err := c.Conn.Read(c.buf[c.offset:])
  if err != nil {
    return 0, err
  }

  r += c.offset

  s := 0
  n := 0
  for i := range pkts {
    p := NewOpenflowEchoRequestWithBuf(c.buf)

    pSize := p.Size()
    if r < s+pSize {
      break
    }

    pkts[i] = p
    s += pSize
    n++
  }

  c.offset = r - s
  if c.offset < 0 {
    panic("Invalid value for offset")
  }

  c.buf = c.buf[s:]
  if c.offset < len(c.buf) {
    return n, nil
  }

  buf := make([]byte, packet.DefaultBufSize)
  copy(buf, c.buf[:c.offset])
  c.buf = buf
  return n, nil
}

func (this *OpenflowEchoRequest) Init() {
  this.OpenflowHeaderV10.Init()
  this.SetLength(uint16(this.minSize()))
  // Invariants.
  this.SetType(uint8(2)) // type
  this.SetVersion(uint8(1)) // version
}

func (this OpenflowEchoRequest) Size() int {
  if len(this.Buf) < this.minSize() {
    return 0
  }

  size := int(this.Length())
  return size
}

func ConvertToOpenflowEchoRequest(p OpenflowHeaderV10) (OpenflowEchoRequest, error) {
  if !IsOpenflowEchoRequest(p) {
    return NewOpenflowEchoRequestWithBuf(nil), errors.New("Cannot convert to openflowv10.OpenflowEchoRequest")
  }

  return NewOpenflowEchoRequestWithBuf(p.Buf), nil
}

func IsOpenflowEchoRequest(p OpenflowHeaderV10) bool {
  return p.Type() == 2 && true
}

func NewOpenflowEchoReplyWithBuf(b []byte) OpenflowEchoReply {
  return OpenflowEchoReply{OpenflowHeaderV10{openflow.OpenflowHeader{packet.Packet{Buf: b}}}}
}

func NewOpenflowEchoReply() OpenflowEchoReply {
  s := 8
  b := make([]byte, s)
  p := OpenflowEchoReply{OpenflowHeaderV10{openflow.OpenflowHeader{packet.Packet{Buf: b}}}}
  p.Init()
  return p
}

type OpenflowEchoReply struct {
  OpenflowHeaderV10
}

func (this OpenflowEchoReply) minSize() int {
  return 8
}

type OpenflowEchoReplyConn struct {
  net.Conn
  buf []byte
  offset int
}

func NewOpenflowEchoReplyConn(c net.Conn) OpenflowEchoReplyConn {
  return OpenflowEchoReplyConn {
    Conn: c,
    buf: make([]byte, packet.DefaultBufSize),
  }
}

func (c *OpenflowEchoReplyConn) Write(pkts []OpenflowEchoReply) error {
  for _, p := range pkts {
    s := p.Size()
    b := p.Buffer()[:s]
    n := 0
    for s > 0 {
      var err error
      if n, err = c.Conn.Write(b); err != nil {
        return fmt.Errorf("Error in write: %v", err)
      }
      s -= n
    }
  }
  return nil
}

func (c *OpenflowEchoReplyConn) Read(pkts []OpenflowEchoReply) (int, error) {
  if len(c.buf) == c.offset {
    newSize := packet.DefaultBufSize
    if newSize < len(c.buf) {
      newSize = 2 * len(c.buf)
    }

    buf := make([]byte, newSize)
    copy(buf, c.buf[:c.offset])
    c.buf = buf
  }

  r, err := c.Conn.Read(c.buf[c.offset:])
  if err != nil {
    return 0, err
  }

  r += c.offset

  s := 0
  n := 0
  for i := range pkts {
    p := NewOpenflowEchoReplyWithBuf(c.buf)

    pSize := p.Size()
    if r < s+pSize {
      break
    }

    pkts[i] = p
    s += pSize
    n++
  }

  c.offset = r - s
  if c.offset < 0 {
    panic("Invalid value for offset")
  }

  c.buf = c.buf[s:]
  if c.offset < len(c.buf) {
    return n, nil
  }

  buf := make([]byte, packet.DefaultBufSize)
  copy(buf, c.buf[:c.offset])
  c.buf = buf
  return n, nil
}

func (this *OpenflowEchoReply) Init() {
  this.OpenflowHeaderV10.Init()
  this.SetLength(uint16(this.minSize()))
  // Invariants.
  this.SetType(uint8(3)) // type
  this.SetVersion(uint8(1)) // version
}

func (this OpenflowEchoReply) Size() int {
  if len(this.Buf) < this.minSize() {
    return 0
  }

  size := int(this.Length())
  return size
}

func ConvertToOpenflowEchoReply(p OpenflowHeaderV10) (OpenflowEchoReply, error) {
  if !IsOpenflowEchoReply(p) {
    return NewOpenflowEchoReplyWithBuf(nil), errors.New("Cannot convert to openflowv10.OpenflowEchoReply")
  }

  return NewOpenflowEchoReplyWithBuf(p.Buf), nil
}

func IsOpenflowEchoReply(p OpenflowHeaderV10) bool {
  return p.Type() == 3 && true
}

func NewOpenflowFeaturesRequestWithBuf(b []byte) OpenflowFeaturesRequest {
  return OpenflowFeaturesRequest{OpenflowHeaderV10{openflow.OpenflowHeader{packet.Packet{Buf: b}}}}
}

func NewOpenflowFeaturesRequest() OpenflowFeaturesRequest {
  s := 8
  b := make([]byte, s)
  p := OpenflowFeaturesRequest{OpenflowHeaderV10{openflow.OpenflowHeader{packet.Packet{Buf: b}}}}
  p.Init()
  return p
}

type OpenflowFeaturesRequest struct {
  OpenflowHeaderV10
}

func (this OpenflowFeaturesRequest) minSize() int {
  return 8
}

type OpenflowFeaturesRequestConn struct {
  net.Conn
  buf []byte
  offset int
}

func NewOpenflowFeaturesRequestConn(c net.Conn) OpenflowFeaturesRequestConn {
  return OpenflowFeaturesRequestConn {
    Conn: c,
    buf: make([]byte, packet.DefaultBufSize),
  }
}

func (c *OpenflowFeaturesRequestConn) Write(pkts []OpenflowFeaturesRequest) error {
  for _, p := range pkts {
    s := p.Size()
    b := p.Buffer()[:s]
    n := 0
    for s > 0 {
      var err error
      if n, err = c.Conn.Write(b); err != nil {
        return fmt.Errorf("Error in write: %v", err)
      }
      s -= n
    }
  }
  return nil
}

func (c *OpenflowFeaturesRequestConn) Read(pkts []OpenflowFeaturesRequest) (int, error) {
  if len(c.buf) == c.offset {
    newSize := packet.DefaultBufSize
    if newSize < len(c.buf) {
      newSize = 2 * len(c.buf)
    }

    buf := make([]byte, newSize)
    copy(buf, c.buf[:c.offset])
    c.buf = buf
  }

  r, err := c.Conn.Read(c.buf[c.offset:])
  if err != nil {
    return 0, err
  }

  r += c.offset

  s := 0
  n := 0
  for i := range pkts {
    p := NewOpenflowFeaturesRequestWithBuf(c.buf)

    pSize := p.Size()
    if r < s+pSize {
      break
    }

    pkts[i] = p
    s += pSize
    n++
  }

  c.offset = r - s
  if c.offset < 0 {
    panic("Invalid value for offset")
  }

  c.buf = c.buf[s:]
  if c.offset < len(c.buf) {
    return n, nil
  }

  buf := make([]byte, packet.DefaultBufSize)
  copy(buf, c.buf[:c.offset])
  c.buf = buf
  return n, nil
}

func (this *OpenflowFeaturesRequest) Init() {
  this.OpenflowHeaderV10.Init()
  this.SetLength(uint16(this.minSize()))
  // Invariants.
  this.SetType(uint8(5)) // type
  this.SetVersion(uint8(1)) // version
}

func (this OpenflowFeaturesRequest) Size() int {
  if len(this.Buf) < this.minSize() {
    return 0
  }

  size := int(this.Length())
  return size
}

func ConvertToOpenflowFeaturesRequest(p OpenflowHeaderV10) (OpenflowFeaturesRequest, error) {
  if !IsOpenflowFeaturesRequest(p) {
    return NewOpenflowFeaturesRequestWithBuf(nil), errors.New("Cannot convert to openflowv10.OpenflowFeaturesRequest")
  }

  return NewOpenflowFeaturesRequestWithBuf(p.Buf), nil
}

func IsOpenflowFeaturesRequest(p OpenflowHeaderV10) bool {
  return p.Type() == 5 && true
}

func NewOpenflowGetConfigRequestWithBuf(b []byte) OpenflowGetConfigRequest {
  return OpenflowGetConfigRequest{OpenflowHeaderV10{openflow.OpenflowHeader{packet.Packet{Buf: b}}}}
}

func NewOpenflowGetConfigRequest() OpenflowGetConfigRequest {
  s := 8
  b := make([]byte, s)
  p := OpenflowGetConfigRequest{OpenflowHeaderV10{openflow.OpenflowHeader{packet.Packet{Buf: b}}}}
  p.Init()
  return p
}

type OpenflowGetConfigRequest struct {
  OpenflowHeaderV10
}

func (this OpenflowGetConfigRequest) minSize() int {
  return 8
}

type OpenflowGetConfigRequestConn struct {
  net.Conn
  buf []byte
  offset int
}

func NewOpenflowGetConfigRequestConn(c net.Conn) OpenflowGetConfigRequestConn {
  return OpenflowGetConfigRequestConn {
    Conn: c,
    buf: make([]byte, packet.DefaultBufSize),
  }
}

func (c *OpenflowGetConfigRequestConn) Write(pkts []OpenflowGetConfigRequest) error {
  for _, p := range pkts {
    s := p.Size()
    b := p.Buffer()[:s]
    n := 0
    for s > 0 {
      var err error
      if n, err = c.Conn.Write(b); err != nil {
        return fmt.Errorf("Error in write: %v", err)
      }
      s -= n
    }
  }
  return nil
}

func (c *OpenflowGetConfigRequestConn) Read(pkts []OpenflowGetConfigRequest) (int, error) {
  if len(c.buf) == c.offset {
    newSize := packet.DefaultBufSize
    if newSize < len(c.buf) {
      newSize = 2 * len(c.buf)
    }

    buf := make([]byte, newSize)
    copy(buf, c.buf[:c.offset])
    c.buf = buf
  }

  r, err := c.Conn.Read(c.buf[c.offset:])
  if err != nil {
    return 0, err
  }

  r += c.offset

  s := 0
  n := 0
  for i := range pkts {
    p := NewOpenflowGetConfigRequestWithBuf(c.buf)

    pSize := p.Size()
    if r < s+pSize {
      break
    }

    pkts[i] = p
    s += pSize
    n++
  }

  c.offset = r - s
  if c.offset < 0 {
    panic("Invalid value for offset")
  }

  c.buf = c.buf[s:]
  if c.offset < len(c.buf) {
    return n, nil
  }

  buf := make([]byte, packet.DefaultBufSize)
  copy(buf, c.buf[:c.offset])
  c.buf = buf
  return n, nil
}

func (this *OpenflowGetConfigRequest) Init() {
  this.OpenflowHeaderV10.Init()
  this.SetLength(uint16(this.minSize()))
  // Invariants.
  this.SetType(uint8(7)) // type
  this.SetVersion(uint8(1)) // version
}

func (this OpenflowGetConfigRequest) Size() int {
  if len(this.Buf) < this.minSize() {
    return 0
  }

  size := int(this.Length())
  return size
}

func ConvertToOpenflowGetConfigRequest(p OpenflowHeaderV10) (OpenflowGetConfigRequest, error) {
  if !IsOpenflowGetConfigRequest(p) {
    return NewOpenflowGetConfigRequestWithBuf(nil), errors.New("Cannot convert to openflowv10.OpenflowGetConfigRequest")
  }

  return NewOpenflowGetConfigRequestWithBuf(p.Buf), nil
}

func IsOpenflowGetConfigRequest(p OpenflowHeaderV10) bool {
  return p.Type() == 7 && true
}

func NewOpenflowSwitchGetConfigReplyWithBuf(b []byte) OpenflowSwitchGetConfigReply {
  return OpenflowSwitchGetConfigReply{OpenflowHeaderV10{openflow.OpenflowHeader{packet.Packet{Buf: b}}}}
}

func NewOpenflowSwitchGetConfigReply() OpenflowSwitchGetConfigReply {
  s := 12
  b := make([]byte, s)
  p := OpenflowSwitchGetConfigReply{OpenflowHeaderV10{openflow.OpenflowHeader{packet.Packet{Buf: b}}}}
  p.Init()
  return p
}

type OpenflowSwitchGetConfigReply struct {
  OpenflowHeaderV10
}

func (this OpenflowSwitchGetConfigReply) minSize() int {
  return 12
}

type OpenflowSwitchGetConfigReplyConn struct {
  net.Conn
  buf []byte
  offset int
}

func NewOpenflowSwitchGetConfigReplyConn(c net.Conn) OpenflowSwitchGetConfigReplyConn {
  return OpenflowSwitchGetConfigReplyConn {
    Conn: c,
    buf: make([]byte, packet.DefaultBufSize),
  }
}

func (c *OpenflowSwitchGetConfigReplyConn) Write(pkts []OpenflowSwitchGetConfigReply) error {
  for _, p := range pkts {
    s := p.Size()
    b := p.Buffer()[:s]
    n := 0
    for s > 0 {
      var err error
      if n, err = c.Conn.Write(b); err != nil {
        return fmt.Errorf("Error in write: %v", err)
      }
      s -= n
    }
  }
  return nil
}

func (c *OpenflowSwitchGetConfigReplyConn) Read(pkts []OpenflowSwitchGetConfigReply) (int, error) {
  if len(c.buf) == c.offset {
    newSize := packet.DefaultBufSize
    if newSize < len(c.buf) {
      newSize = 2 * len(c.buf)
    }

    buf := make([]byte, newSize)
    copy(buf, c.buf[:c.offset])
    c.buf = buf
  }

  r, err := c.Conn.Read(c.buf[c.offset:])
  if err != nil {
    return 0, err
  }

  r += c.offset

  s := 0
  n := 0
  for i := range pkts {
    p := NewOpenflowSwitchGetConfigReplyWithBuf(c.buf)

    pSize := p.Size()
    if r < s+pSize {
      break
    }

    pkts[i] = p
    s += pSize
    n++
  }

  c.offset = r - s
  if c.offset < 0 {
    panic("Invalid value for offset")
  }

  c.buf = c.buf[s:]
  if c.offset < len(c.buf) {
    return n, nil
  }

  buf := make([]byte, packet.DefaultBufSize)
  copy(buf, c.buf[:c.offset])
  c.buf = buf
  return n, nil
}

func (this *OpenflowSwitchGetConfigReply) Init() {
  this.OpenflowHeaderV10.Init()
  this.SetLength(uint16(this.minSize()))
  // Invariants.
  this.SetType(uint8(8)) // type
  this.SetVersion(uint8(1)) // version
}

func (this OpenflowSwitchGetConfigReply) Size() int {
  if len(this.Buf) < this.minSize() {
    return 0
  }

  size := int(this.Length())
  return size
}

func ConvertToOpenflowSwitchGetConfigReply(p OpenflowHeaderV10) (OpenflowSwitchGetConfigReply, error) {
  if !IsOpenflowSwitchGetConfigReply(p) {
    return NewOpenflowSwitchGetConfigReplyWithBuf(nil), errors.New("Cannot convert to openflowv10.OpenflowSwitchGetConfigReply")
  }

  return NewOpenflowSwitchGetConfigReplyWithBuf(p.Buf), nil
}

func IsOpenflowSwitchGetConfigReply(p OpenflowHeaderV10) bool {
  return p.Type() == 8 && true
}

func (this *OpenflowSwitchGetConfigReply) Flags() uint16 {
  offset := this.FlagsOffset()
  res := binary.BigEndian.Uint16(this.Buf[offset:])
  return res
}

func (this *OpenflowSwitchGetConfigReply) SetFlags(f uint16) {
  offset := this.FlagsOffset()
  binary.BigEndian.PutUint16(this.Buf[offset:], f); offset += 2
}

func (this *OpenflowSwitchGetConfigReply) FlagsOffset() int {
  offset := 8
  return offset
}


func (this *OpenflowSwitchGetConfigReply) MissSendLen() uint16 {
  offset := this.MissSendLenOffset()
  res := binary.BigEndian.Uint16(this.Buf[offset:])
  return res
}

func (this *OpenflowSwitchGetConfigReply) SetMissSendLen(m uint16) {
  offset := this.MissSendLenOffset()
  binary.BigEndian.PutUint16(this.Buf[offset:], m); offset += 2
}

func (this *OpenflowSwitchGetConfigReply) MissSendLenOffset() int {
  offset := 10
  return offset
}


func NewOpenflowSwitchSetConfigWithBuf(b []byte) OpenflowSwitchSetConfig {
  return OpenflowSwitchSetConfig{OpenflowHeaderV10{openflow.OpenflowHeader{packet.Packet{Buf: b}}}}
}

func NewOpenflowSwitchSetConfig() OpenflowSwitchSetConfig {
  s := 12
  b := make([]byte, s)
  p := OpenflowSwitchSetConfig{OpenflowHeaderV10{openflow.OpenflowHeader{packet.Packet{Buf: b}}}}
  p.Init()
  return p
}

type OpenflowSwitchSetConfig struct {
  OpenflowHeaderV10
}

func (this OpenflowSwitchSetConfig) minSize() int {
  return 12
}

type OpenflowSwitchSetConfigConn struct {
  net.Conn
  buf []byte
  offset int
}

func NewOpenflowSwitchSetConfigConn(c net.Conn) OpenflowSwitchSetConfigConn {
  return OpenflowSwitchSetConfigConn {
    Conn: c,
    buf: make([]byte, packet.DefaultBufSize),
  }
}

func (c *OpenflowSwitchSetConfigConn) Write(pkts []OpenflowSwitchSetConfig) error {
  for _, p := range pkts {
    s := p.Size()
    b := p.Buffer()[:s]
    n := 0
    for s > 0 {
      var err error
      if n, err = c.Conn.Write(b); err != nil {
        return fmt.Errorf("Error in write: %v", err)
      }
      s -= n
    }
  }
  return nil
}

func (c *OpenflowSwitchSetConfigConn) Read(pkts []OpenflowSwitchSetConfig) (int, error) {
  if len(c.buf) == c.offset {
    newSize := packet.DefaultBufSize
    if newSize < len(c.buf) {
      newSize = 2 * len(c.buf)
    }

    buf := make([]byte, newSize)
    copy(buf, c.buf[:c.offset])
    c.buf = buf
  }

  r, err := c.Conn.Read(c.buf[c.offset:])
  if err != nil {
    return 0, err
  }

  r += c.offset

  s := 0
  n := 0
  for i := range pkts {
    p := NewOpenflowSwitchSetConfigWithBuf(c.buf)

    pSize := p.Size()
    if r < s+pSize {
      break
    }

    pkts[i] = p
    s += pSize
    n++
  }

  c.offset = r - s
  if c.offset < 0 {
    panic("Invalid value for offset")
  }

  c.buf = c.buf[s:]
  if c.offset < len(c.buf) {
    return n, nil
  }

  buf := make([]byte, packet.DefaultBufSize)
  copy(buf, c.buf[:c.offset])
  c.buf = buf
  return n, nil
}

func (this *OpenflowSwitchSetConfig) Init() {
  this.OpenflowHeaderV10.Init()
  this.SetLength(uint16(this.minSize()))
  // Invariants.
  this.SetType(uint8(9)) // type
  this.SetVersion(uint8(1)) // version
}

func (this OpenflowSwitchSetConfig) Size() int {
  if len(this.Buf) < this.minSize() {
    return 0
  }

  size := int(this.Length())
  return size
}

func ConvertToOpenflowSwitchSetConfig(p OpenflowHeaderV10) (OpenflowSwitchSetConfig, error) {
  if !IsOpenflowSwitchSetConfig(p) {
    return NewOpenflowSwitchSetConfigWithBuf(nil), errors.New("Cannot convert to openflowv10.OpenflowSwitchSetConfig")
  }

  return NewOpenflowSwitchSetConfigWithBuf(p.Buf), nil
}

func IsOpenflowSwitchSetConfig(p OpenflowHeaderV10) bool {
  return p.Type() == 9 && true
}

func (this *OpenflowSwitchSetConfig) Flags() uint16 {
  offset := this.FlagsOffset()
  res := binary.BigEndian.Uint16(this.Buf[offset:])
  return res
}

func (this *OpenflowSwitchSetConfig) SetFlags(f uint16) {
  offset := this.FlagsOffset()
  binary.BigEndian.PutUint16(this.Buf[offset:], f); offset += 2
}

func (this *OpenflowSwitchSetConfig) FlagsOffset() int {
  offset := 8
  return offset
}


func (this *OpenflowSwitchSetConfig) MissSendLen() uint16 {
  offset := this.MissSendLenOffset()
  res := binary.BigEndian.Uint16(this.Buf[offset:])
  return res
}

func (this *OpenflowSwitchSetConfig) SetMissSendLen(m uint16) {
  offset := this.MissSendLenOffset()
  binary.BigEndian.PutUint16(this.Buf[offset:], m); offset += 2
}

func (this *OpenflowSwitchSetConfig) MissSendLenOffset() int {
  offset := 10
  return offset
}


func NewOpenflowPhysicalPortWithBuf(b []byte) OpenflowPhysicalPort {
  return OpenflowPhysicalPort{packet.Packet{Buf: b}}
}

func NewOpenflowPhysicalPort() OpenflowPhysicalPort {
  s := 48
  b := make([]byte, s)
  p := OpenflowPhysicalPort{packet.Packet{Buf: b}}
  p.Init()
  return p
}

type OpenflowPhysicalPort struct {
  packet.Packet
}

func (this OpenflowPhysicalPort) minSize() int {
  return 48
}

type OpenflowPhysicalPortConn struct {
  net.Conn
  buf []byte
  offset int
}

func NewOpenflowPhysicalPortConn(c net.Conn) OpenflowPhysicalPortConn {
  return OpenflowPhysicalPortConn {
    Conn: c,
    buf: make([]byte, packet.DefaultBufSize),
  }
}

func (c *OpenflowPhysicalPortConn) Write(pkts []OpenflowPhysicalPort) error {
  for _, p := range pkts {
    s := p.Size()
    b := p.Buffer()[:s]
    n := 0
    for s > 0 {
      var err error
      if n, err = c.Conn.Write(b); err != nil {
        return fmt.Errorf("Error in write: %v", err)
      }
      s -= n
    }
  }
  return nil
}

func (c *OpenflowPhysicalPortConn) Read(pkts []OpenflowPhysicalPort) (int, error) {
  if len(c.buf) == c.offset {
    newSize := packet.DefaultBufSize
    if newSize < len(c.buf) {
      newSize = 2 * len(c.buf)
    }

    buf := make([]byte, newSize)
    copy(buf, c.buf[:c.offset])
    c.buf = buf
  }

  r, err := c.Conn.Read(c.buf[c.offset:])
  if err != nil {
    return 0, err
  }

  r += c.offset

  s := 0
  n := 0
  for i := range pkts {
    p := NewOpenflowPhysicalPortWithBuf(c.buf)

    pSize := p.Size()
    if r < s+pSize {
      break
    }

    pkts[i] = p
    s += pSize
    n++
  }

  c.offset = r - s
  if c.offset < 0 {
    panic("Invalid value for offset")
  }

  c.buf = c.buf[s:]
  if c.offset < len(c.buf) {
    return n, nil
  }

  buf := make([]byte, packet.DefaultBufSize)
  copy(buf, c.buf[:c.offset])
  c.buf = buf
  return n, nil
}

func (this *OpenflowPhysicalPort) Init() {
  // Invariants.
}

func (this OpenflowPhysicalPort) Size() int {
  return 48
}

func ConvertToOpenflowPhysicalPort(p packet.Packet) (OpenflowPhysicalPort, error) {
  if !IsOpenflowPhysicalPort(p) {
    return NewOpenflowPhysicalPortWithBuf(nil), errors.New("Cannot convert to openflowv10.OpenflowPhysicalPort")
  }

  return NewOpenflowPhysicalPortWithBuf(p.Buf), nil
}

func IsOpenflowPhysicalPort(p packet.Packet) bool {
  return true
}

func (this *OpenflowPhysicalPort) PortNo() uint16 {
  offset := this.PortNoOffset()
  res := binary.BigEndian.Uint16(this.Buf[offset:])
  return res
}

func (this *OpenflowPhysicalPort) SetPortNo(p uint16) {
  offset := this.PortNoOffset()
  binary.BigEndian.PutUint16(this.Buf[offset:], p); offset += 2
}

func (this *OpenflowPhysicalPort) PortNoOffset() int {
  offset := 0
  return offset
}


func (this *OpenflowPhysicalPort) HwAddr() [6]uint8 {
  offset := this.HwAddrOffset()
  packet_size := this.Size()
  size := packet_size - offset
  count := this.Size() - offset
  i := 0
  var res [6]uint8
  for size > 0 && count > 0 && packet_size > offset {
    elem := uint8(this.Buf[offset])
    if size < 1 {
      break
    }
    size -= 1
    count--
    res[i] = elem
    i++
  }
  return res
}

func (this *OpenflowPhysicalPort) SetHwAddr(h [6]uint8) {
  offset := this.HwAddrOffset()
  for _, e := range h {
    this.Buf[offset] = byte(e); offset++
  }
}

func (this *OpenflowPhysicalPort) HwAddrOffset() int {
  offset := 2
  return offset
}


func (this *OpenflowPhysicalPort) Name() [16]int8 {
  offset := this.NameOffset()
  packet_size := this.Size()
  size := packet_size - offset
  count := this.Size() - offset
  i := 0
  var res [16]int8
  for size > 0 && count > 0 && packet_size > offset {
    elem := int8(this.Buf[offset])
    if size < 1 {
      break
    }
    size -= 1
    count--
    res[i] = elem
    i++
  }
  return res
}

func (this *OpenflowPhysicalPort) SetName(n [16]int8) {
  offset := this.NameOffset()
  for _, e := range n {
    this.Buf[offset] = byte(e); offset++
  }
}

func (this *OpenflowPhysicalPort) NameOffset() int {
  offset := 8
  return offset
}


func (this *OpenflowPhysicalPort) Config() uint32 {
  offset := this.ConfigOffset()
  res := binary.BigEndian.Uint32(this.Buf[offset:])
  return res
}

func (this *OpenflowPhysicalPort) SetConfig(c uint32) {
  offset := this.ConfigOffset()
  binary.BigEndian.PutUint32(this.Buf[offset:], c); offset += 4
}

func (this *OpenflowPhysicalPort) ConfigOffset() int {
  offset := 24
  return offset
}


func (this *OpenflowPhysicalPort) State() uint32 {
  offset := this.StateOffset()
  res := binary.BigEndian.Uint32(this.Buf[offset:])
  return res
}

func (this *OpenflowPhysicalPort) SetState(s uint32) {
  offset := this.StateOffset()
  binary.BigEndian.PutUint32(this.Buf[offset:], s); offset += 4
}

func (this *OpenflowPhysicalPort) StateOffset() int {
  offset := 28
  return offset
}


func (this *OpenflowPhysicalPort) Curr() uint32 {
  offset := this.CurrOffset()
  res := binary.BigEndian.Uint32(this.Buf[offset:])
  return res
}

func (this *OpenflowPhysicalPort) SetCurr(c uint32) {
  offset := this.CurrOffset()
  binary.BigEndian.PutUint32(this.Buf[offset:], c); offset += 4
}

func (this *OpenflowPhysicalPort) CurrOffset() int {
  offset := 32
  return offset
}


func (this *OpenflowPhysicalPort) Advertised() uint32 {
  offset := this.AdvertisedOffset()
  res := binary.BigEndian.Uint32(this.Buf[offset:])
  return res
}

func (this *OpenflowPhysicalPort) SetAdvertised(a uint32) {
  offset := this.AdvertisedOffset()
  binary.BigEndian.PutUint32(this.Buf[offset:], a); offset += 4
}

func (this *OpenflowPhysicalPort) AdvertisedOffset() int {
  offset := 36
  return offset
}


func (this *OpenflowPhysicalPort) Supported() uint32 {
  offset := this.SupportedOffset()
  res := binary.BigEndian.Uint32(this.Buf[offset:])
  return res
}

func (this *OpenflowPhysicalPort) SetSupported(s uint32) {
  offset := this.SupportedOffset()
  binary.BigEndian.PutUint32(this.Buf[offset:], s); offset += 4
}

func (this *OpenflowPhysicalPort) SupportedOffset() int {
  offset := 40
  return offset
}


func (this *OpenflowPhysicalPort) Peer() uint32 {
  offset := this.PeerOffset()
  res := binary.BigEndian.Uint32(this.Buf[offset:])
  return res
}

func (this *OpenflowPhysicalPort) SetPeer(p uint32) {
  offset := this.PeerOffset()
  binary.BigEndian.PutUint32(this.Buf[offset:], p); offset += 4
}

func (this *OpenflowPhysicalPort) PeerOffset() int {
  offset := 44
  return offset
}


func NewOpenflowFeaturesReplyWithBuf(b []byte) OpenflowFeaturesReply {
  return OpenflowFeaturesReply{OpenflowHeaderV10{openflow.OpenflowHeader{packet.Packet{Buf: b}}}}
}

func NewOpenflowFeaturesReply() OpenflowFeaturesReply {
  s := 32
  b := make([]byte, s)
  p := OpenflowFeaturesReply{OpenflowHeaderV10{openflow.OpenflowHeader{packet.Packet{Buf: b}}}}
  p.Init()
  return p
}

type OpenflowFeaturesReply struct {
  OpenflowHeaderV10
}

func (this OpenflowFeaturesReply) minSize() int {
  return 32
}

type OpenflowFeaturesReplyConn struct {
  net.Conn
  buf []byte
  offset int
}

func NewOpenflowFeaturesReplyConn(c net.Conn) OpenflowFeaturesReplyConn {
  return OpenflowFeaturesReplyConn {
    Conn: c,
    buf: make([]byte, packet.DefaultBufSize),
  }
}

func (c *OpenflowFeaturesReplyConn) Write(pkts []OpenflowFeaturesReply) error {
  for _, p := range pkts {
    s := p.Size()
    b := p.Buffer()[:s]
    n := 0
    for s > 0 {
      var err error
      if n, err = c.Conn.Write(b); err != nil {
        return fmt.Errorf("Error in write: %v", err)
      }
      s -= n
    }
  }
  return nil
}

func (c *OpenflowFeaturesReplyConn) Read(pkts []OpenflowFeaturesReply) (int, error) {
  if len(c.buf) == c.offset {
    newSize := packet.DefaultBufSize
    if newSize < len(c.buf) {
      newSize = 2 * len(c.buf)
    }

    buf := make([]byte, newSize)
    copy(buf, c.buf[:c.offset])
    c.buf = buf
  }

  r, err := c.Conn.Read(c.buf[c.offset:])
  if err != nil {
    return 0, err
  }

  r += c.offset

  s := 0
  n := 0
  for i := range pkts {
    p := NewOpenflowFeaturesReplyWithBuf(c.buf)

    pSize := p.Size()
    if r < s+pSize {
      break
    }

    pkts[i] = p
    s += pSize
    n++
  }

  c.offset = r - s
  if c.offset < 0 {
    panic("Invalid value for offset")
  }

  c.buf = c.buf[s:]
  if c.offset < len(c.buf) {
    return n, nil
  }

  buf := make([]byte, packet.DefaultBufSize)
  copy(buf, c.buf[:c.offset])
  c.buf = buf
  return n, nil
}

func (this *OpenflowFeaturesReply) Init() {
  this.OpenflowHeaderV10.Init()
  this.SetLength(uint16(this.minSize()))
  // Invariants.
  this.SetType(uint8(6)) // type
  this.SetVersion(uint8(1)) // version
}

func (this OpenflowFeaturesReply) Size() int {
  if len(this.Buf) < this.minSize() {
    return 0
  }

  size := int(this.Length())
  return size
}

func ConvertToOpenflowFeaturesReply(p OpenflowHeaderV10) (OpenflowFeaturesReply, error) {
  if !IsOpenflowFeaturesReply(p) {
    return NewOpenflowFeaturesReplyWithBuf(nil), errors.New("Cannot convert to openflowv10.OpenflowFeaturesReply")
  }

  return NewOpenflowFeaturesReplyWithBuf(p.Buf), nil
}

func IsOpenflowFeaturesReply(p OpenflowHeaderV10) bool {
  return p.Type() == 6 && true
}

func (this *OpenflowFeaturesReply) DatapathId() uint64 {
  offset := this.DatapathIdOffset()
  res := binary.BigEndian.Uint64(this.Buf[offset:])
  return res
}

func (this *OpenflowFeaturesReply) SetDatapathId(d uint64) {
  offset := this.DatapathIdOffset()
  binary.BigEndian.PutUint64(this.Buf[offset:], d); offset += 8
}

func (this *OpenflowFeaturesReply) DatapathIdOffset() int {
  offset := 8
  return offset
}


func (this *OpenflowFeaturesReply) NBuffers() uint32 {
  offset := this.NBuffersOffset()
  res := binary.BigEndian.Uint32(this.Buf[offset:])
  return res
}

func (this *OpenflowFeaturesReply) SetNBuffers(n uint32) {
  offset := this.NBuffersOffset()
  binary.BigEndian.PutUint32(this.Buf[offset:], n); offset += 4
}

func (this *OpenflowFeaturesReply) NBuffersOffset() int {
  offset := 16
  return offset
}


func (this *OpenflowFeaturesReply) NTables() uint8 {
  offset := this.NTablesOffset()
  res := uint8(this.Buf[offset])
  return res
}

func (this *OpenflowFeaturesReply) SetNTables(n uint8) {
  offset := this.NTablesOffset()
  this.Buf[offset] = byte(n); offset++
}

func (this *OpenflowFeaturesReply) NTablesOffset() int {
  offset := 20
  return offset
}


func (this *OpenflowFeaturesReply) Pad() [3]uint8 {
  offset := this.PadOffset()
  packet_size := this.Size()
  size := packet_size - offset
  count := this.Size() - offset
  i := 0
  var res [3]uint8
  for size > 0 && count > 0 && packet_size > offset {
    elem := uint8(this.Buf[offset])
    if size < 1 {
      break
    }
    size -= 1
    count--
    res[i] = elem
    i++
  }
  return res
}

func (this *OpenflowFeaturesReply) SetPad(p [3]uint8) {
  offset := this.PadOffset()
  for _, e := range p {
    this.Buf[offset] = byte(e); offset++
  }
}

func (this *OpenflowFeaturesReply) PadOffset() int {
  offset := 21
  return offset
}


func (this *OpenflowFeaturesReply) Capabilities() uint32 {
  offset := this.CapabilitiesOffset()
  res := binary.BigEndian.Uint32(this.Buf[offset:])
  return res
}

func (this *OpenflowFeaturesReply) SetCapabilities(c uint32) {
  offset := this.CapabilitiesOffset()
  binary.BigEndian.PutUint32(this.Buf[offset:], c); offset += 4
}

func (this *OpenflowFeaturesReply) CapabilitiesOffset() int {
  offset := 24
  return offset
}


func (this *OpenflowFeaturesReply) Actions() uint32 {
  offset := this.ActionsOffset()
  res := binary.BigEndian.Uint32(this.Buf[offset:])
  return res
}

func (this *OpenflowFeaturesReply) SetActions(a uint32) {
  offset := this.ActionsOffset()
  binary.BigEndian.PutUint32(this.Buf[offset:], a); offset += 4
}

func (this *OpenflowFeaturesReply) ActionsOffset() int {
  offset := 28
  return offset
}


func (this *OpenflowFeaturesReply) Ports() []OpenflowPhysicalPort {
  offset := this.PortsOffset()
  packet_size := this.Size()
  size := packet_size - offset
  count := this.Size() - offset
  i := 0
  var res []OpenflowPhysicalPort
  for size > 0 && count > 0 && packet_size > offset {
    elem := NewOpenflowPhysicalPortWithBuf(this.Buf[offset:])
    if elem.Size() > size {
      break
    }
    size -= elem.Size()
    count--
    res[i] = elem
    i++
  }
  return res
}

func (this *OpenflowFeaturesReply) AddPorts(p OpenflowPhysicalPort) {
  offset := this.PortsOffset()
  offset += this.PortsSize()
  size := p.Size()
  this.OpenGap(offset, size)
  this.SetLength(uint16(this.Size() + size))
  copy(this.Buf[offset:], p.Buf[:p.Size()]); offset += p.Size()
}

func (this *OpenflowFeaturesReply) PortsOffset() int {
  offset := 32
  return offset
}

func (this *OpenflowFeaturesReply) PortsSize() int {
  offset := this.PortsOffset()
  return this.Size() - offset
}

func NewOpenflowPortStatusWithBuf(b []byte) OpenflowPortStatus {
  return OpenflowPortStatus{OpenflowHeaderV10{openflow.OpenflowHeader{packet.Packet{Buf: b}}}}
}

func NewOpenflowPortStatus() OpenflowPortStatus {
  s := 64
  b := make([]byte, s)
  p := OpenflowPortStatus{OpenflowHeaderV10{openflow.OpenflowHeader{packet.Packet{Buf: b}}}}
  p.Init()
  return p
}

type OpenflowPortStatus struct {
  OpenflowHeaderV10
}

func (this OpenflowPortStatus) minSize() int {
  return 64
}

type OpenflowPortStatusConn struct {
  net.Conn
  buf []byte
  offset int
}

func NewOpenflowPortStatusConn(c net.Conn) OpenflowPortStatusConn {
  return OpenflowPortStatusConn {
    Conn: c,
    buf: make([]byte, packet.DefaultBufSize),
  }
}

func (c *OpenflowPortStatusConn) Write(pkts []OpenflowPortStatus) error {
  for _, p := range pkts {
    s := p.Size()
    b := p.Buffer()[:s]
    n := 0
    for s > 0 {
      var err error
      if n, err = c.Conn.Write(b); err != nil {
        return fmt.Errorf("Error in write: %v", err)
      }
      s -= n
    }
  }
  return nil
}

func (c *OpenflowPortStatusConn) Read(pkts []OpenflowPortStatus) (int, error) {
  if len(c.buf) == c.offset {
    newSize := packet.DefaultBufSize
    if newSize < len(c.buf) {
      newSize = 2 * len(c.buf)
    }

    buf := make([]byte, newSize)
    copy(buf, c.buf[:c.offset])
    c.buf = buf
  }

  r, err := c.Conn.Read(c.buf[c.offset:])
  if err != nil {
    return 0, err
  }

  r += c.offset

  s := 0
  n := 0
  for i := range pkts {
    p := NewOpenflowPortStatusWithBuf(c.buf)

    pSize := p.Size()
    if r < s+pSize {
      break
    }

    pkts[i] = p
    s += pSize
    n++
  }

  c.offset = r - s
  if c.offset < 0 {
    panic("Invalid value for offset")
  }

  c.buf = c.buf[s:]
  if c.offset < len(c.buf) {
    return n, nil
  }

  buf := make([]byte, packet.DefaultBufSize)
  copy(buf, c.buf[:c.offset])
  c.buf = buf
  return n, nil
}

func (this *OpenflowPortStatus) Init() {
  this.OpenflowHeaderV10.Init()
  this.SetLength(uint16(this.minSize()))
  // Invariants.
  this.SetType(uint8(12)) // type
  this.SetVersion(uint8(1)) // version
}

func (this OpenflowPortStatus) Size() int {
  if len(this.Buf) < this.minSize() {
    return 0
  }

  size := int(this.Length())
  return size
}

func ConvertToOpenflowPortStatus(p OpenflowHeaderV10) (OpenflowPortStatus, error) {
  if !IsOpenflowPortStatus(p) {
    return NewOpenflowPortStatusWithBuf(nil), errors.New("Cannot convert to openflowv10.OpenflowPortStatus")
  }

  return NewOpenflowPortStatusWithBuf(p.Buf), nil
}

func IsOpenflowPortStatus(p OpenflowHeaderV10) bool {
  return p.Type() == 12 && true
}

func (this *OpenflowPortStatus) Reason() uint8 {
  offset := this.ReasonOffset()
  res := uint8(this.Buf[offset])
  return res
}

func (this *OpenflowPortStatus) SetReason(r uint8) {
  offset := this.ReasonOffset()
  this.Buf[offset] = byte(r); offset++
}

func (this *OpenflowPortStatus) ReasonOffset() int {
  offset := 8
  return offset
}


func (this *OpenflowPortStatus) Pad() [7]uint8 {
  offset := this.PadOffset()
  packet_size := this.Size()
  size := packet_size - offset
  count := this.Size() - offset
  i := 0
  var res [7]uint8
  for size > 0 && count > 0 && packet_size > offset {
    elem := uint8(this.Buf[offset])
    if size < 1 {
      break
    }
    size -= 1
    count--
    res[i] = elem
    i++
  }
  return res
}

func (this *OpenflowPortStatus) SetPad(p [7]uint8) {
  offset := this.PadOffset()
  for _, e := range p {
    this.Buf[offset] = byte(e); offset++
  }
}

func (this *OpenflowPortStatus) PadOffset() int {
  offset := 9
  return offset
}


func (this *OpenflowPortStatus) Desc() OpenflowPhysicalPort {
  offset := this.DescOffset()
  res := NewOpenflowPhysicalPortWithBuf(this.Buf[offset:])
  return res
}

func (this *OpenflowPortStatus) SetDesc(d OpenflowPhysicalPort) {
  offset := this.DescOffset()
  copy(this.Buf[offset:], d.Buf[:d.Size()]); offset += d.Size()
}

func (this *OpenflowPortStatus) DescOffset() int {
  offset := 16
  return offset
}


func NewOpenflowPortModWithBuf(b []byte) OpenflowPortMod {
  return OpenflowPortMod{OpenflowHeaderV10{openflow.OpenflowHeader{packet.Packet{Buf: b}}}}
}

func NewOpenflowPortMod() OpenflowPortMod {
  s := 32
  b := make([]byte, s)
  p := OpenflowPortMod{OpenflowHeaderV10{openflow.OpenflowHeader{packet.Packet{Buf: b}}}}
  p.Init()
  return p
}

type OpenflowPortMod struct {
  OpenflowHeaderV10
}

func (this OpenflowPortMod) minSize() int {
  return 32
}

type OpenflowPortModConn struct {
  net.Conn
  buf []byte
  offset int
}

func NewOpenflowPortModConn(c net.Conn) OpenflowPortModConn {
  return OpenflowPortModConn {
    Conn: c,
    buf: make([]byte, packet.DefaultBufSize),
  }
}

func (c *OpenflowPortModConn) Write(pkts []OpenflowPortMod) error {
  for _, p := range pkts {
    s := p.Size()
    b := p.Buffer()[:s]
    n := 0
    for s > 0 {
      var err error
      if n, err = c.Conn.Write(b); err != nil {
        return fmt.Errorf("Error in write: %v", err)
      }
      s -= n
    }
  }
  return nil
}

func (c *OpenflowPortModConn) Read(pkts []OpenflowPortMod) (int, error) {
  if len(c.buf) == c.offset {
    newSize := packet.DefaultBufSize
    if newSize < len(c.buf) {
      newSize = 2 * len(c.buf)
    }

    buf := make([]byte, newSize)
    copy(buf, c.buf[:c.offset])
    c.buf = buf
  }

  r, err := c.Conn.Read(c.buf[c.offset:])
  if err != nil {
    return 0, err
  }

  r += c.offset

  s := 0
  n := 0
  for i := range pkts {
    p := NewOpenflowPortModWithBuf(c.buf)

    pSize := p.Size()
    if r < s+pSize {
      break
    }

    pkts[i] = p
    s += pSize
    n++
  }

  c.offset = r - s
  if c.offset < 0 {
    panic("Invalid value for offset")
  }

  c.buf = c.buf[s:]
  if c.offset < len(c.buf) {
    return n, nil
  }

  buf := make([]byte, packet.DefaultBufSize)
  copy(buf, c.buf[:c.offset])
  c.buf = buf
  return n, nil
}

func (this *OpenflowPortMod) Init() {
  this.OpenflowHeaderV10.Init()
  this.SetLength(uint16(this.minSize()))
  // Invariants.
  this.SetType(uint8(15)) // type
  this.SetVersion(uint8(1)) // version
}

func (this OpenflowPortMod) Size() int {
  if len(this.Buf) < this.minSize() {
    return 0
  }

  size := int(this.Length())
  return size
}

func ConvertToOpenflowPortMod(p OpenflowHeaderV10) (OpenflowPortMod, error) {
  if !IsOpenflowPortMod(p) {
    return NewOpenflowPortModWithBuf(nil), errors.New("Cannot convert to openflowv10.OpenflowPortMod")
  }

  return NewOpenflowPortModWithBuf(p.Buf), nil
}

func IsOpenflowPortMod(p OpenflowHeaderV10) bool {
  return p.Type() == 15 && true
}

func (this *OpenflowPortMod) PortNo() uint16 {
  offset := this.PortNoOffset()
  res := binary.BigEndian.Uint16(this.Buf[offset:])
  return res
}

func (this *OpenflowPortMod) SetPortNo(p uint16) {
  offset := this.PortNoOffset()
  binary.BigEndian.PutUint16(this.Buf[offset:], p); offset += 2
}

func (this *OpenflowPortMod) PortNoOffset() int {
  offset := 8
  return offset
}


func (this *OpenflowPortMod) HwAddr() [6]uint8 {
  offset := this.HwAddrOffset()
  packet_size := this.Size()
  size := packet_size - offset
  count := this.Size() - offset
  i := 0
  var res [6]uint8
  for size > 0 && count > 0 && packet_size > offset {
    elem := uint8(this.Buf[offset])
    if size < 1 {
      break
    }
    size -= 1
    count--
    res[i] = elem
    i++
  }
  return res
}

func (this *OpenflowPortMod) SetHwAddr(h [6]uint8) {
  offset := this.HwAddrOffset()
  for _, e := range h {
    this.Buf[offset] = byte(e); offset++
  }
}

func (this *OpenflowPortMod) HwAddrOffset() int {
  offset := 10
  return offset
}


func (this *OpenflowPortMod) Config() uint32 {
  offset := this.ConfigOffset()
  res := binary.BigEndian.Uint32(this.Buf[offset:])
  return res
}

func (this *OpenflowPortMod) SetConfig(c uint32) {
  offset := this.ConfigOffset()
  binary.BigEndian.PutUint32(this.Buf[offset:], c); offset += 4
}

func (this *OpenflowPortMod) ConfigOffset() int {
  offset := 16
  return offset
}


func (this *OpenflowPortMod) Mask() uint32 {
  offset := this.MaskOffset()
  res := binary.BigEndian.Uint32(this.Buf[offset:])
  return res
}

func (this *OpenflowPortMod) SetMask(m uint32) {
  offset := this.MaskOffset()
  binary.BigEndian.PutUint32(this.Buf[offset:], m); offset += 4
}

func (this *OpenflowPortMod) MaskOffset() int {
  offset := 20
  return offset
}


func (this *OpenflowPortMod) Advertise() uint32 {
  offset := this.AdvertiseOffset()
  res := binary.BigEndian.Uint32(this.Buf[offset:])
  return res
}

func (this *OpenflowPortMod) SetAdvertise(a uint32) {
  offset := this.AdvertiseOffset()
  binary.BigEndian.PutUint32(this.Buf[offset:], a); offset += 4
}

func (this *OpenflowPortMod) AdvertiseOffset() int {
  offset := 24
  return offset
}


func (this *OpenflowPortMod) Pad() [4]uint8 {
  offset := this.PadOffset()
  packet_size := this.Size()
  size := packet_size - offset
  count := this.Size() - offset
  i := 0
  var res [4]uint8
  for size > 0 && count > 0 && packet_size > offset {
    elem := uint8(this.Buf[offset])
    if size < 1 {
      break
    }
    size -= 1
    count--
    res[i] = elem
    i++
  }
  return res
}

func (this *OpenflowPortMod) SetPad(p [4]uint8) {
  offset := this.PadOffset()
  for _, e := range p {
    this.Buf[offset] = byte(e); offset++
  }
}

func (this *OpenflowPortMod) PadOffset() int {
  offset := 28
  return offset
}


func NewOpenflowPacketInWithBuf(b []byte) OpenflowPacketIn {
  return OpenflowPacketIn{OpenflowHeaderV10{openflow.OpenflowHeader{packet.Packet{Buf: b}}}}
}

func NewOpenflowPacketIn() OpenflowPacketIn {
  s := 18
  b := make([]byte, s)
  p := OpenflowPacketIn{OpenflowHeaderV10{openflow.OpenflowHeader{packet.Packet{Buf: b}}}}
  p.Init()
  return p
}

type OpenflowPacketIn struct {
  OpenflowHeaderV10
}

func (this OpenflowPacketIn) minSize() int {
  return 18
}

type OpenflowPacketInConn struct {
  net.Conn
  buf []byte
  offset int
}

func NewOpenflowPacketInConn(c net.Conn) OpenflowPacketInConn {
  return OpenflowPacketInConn {
    Conn: c,
    buf: make([]byte, packet.DefaultBufSize),
  }
}

func (c *OpenflowPacketInConn) Write(pkts []OpenflowPacketIn) error {
  for _, p := range pkts {
    s := p.Size()
    b := p.Buffer()[:s]
    n := 0
    for s > 0 {
      var err error
      if n, err = c.Conn.Write(b); err != nil {
        return fmt.Errorf("Error in write: %v", err)
      }
      s -= n
    }
  }
  return nil
}

func (c *OpenflowPacketInConn) Read(pkts []OpenflowPacketIn) (int, error) {
  if len(c.buf) == c.offset {
    newSize := packet.DefaultBufSize
    if newSize < len(c.buf) {
      newSize = 2 * len(c.buf)
    }

    buf := make([]byte, newSize)
    copy(buf, c.buf[:c.offset])
    c.buf = buf
  }

  r, err := c.Conn.Read(c.buf[c.offset:])
  if err != nil {
    return 0, err
  }

  r += c.offset

  s := 0
  n := 0
  for i := range pkts {
    p := NewOpenflowPacketInWithBuf(c.buf)

    pSize := p.Size()
    if r < s+pSize {
      break
    }

    pkts[i] = p
    s += pSize
    n++
  }

  c.offset = r - s
  if c.offset < 0 {
    panic("Invalid value for offset")
  }

  c.buf = c.buf[s:]
  if c.offset < len(c.buf) {
    return n, nil
  }

  buf := make([]byte, packet.DefaultBufSize)
  copy(buf, c.buf[:c.offset])
  c.buf = buf
  return n, nil
}

func (this *OpenflowPacketIn) Init() {
  this.OpenflowHeaderV10.Init()
  this.SetLength(uint16(this.minSize()))
  // Invariants.
  this.SetType(uint8(10)) // type
  this.SetVersion(uint8(1)) // version
}

func (this OpenflowPacketIn) Size() int {
  if len(this.Buf) < this.minSize() {
    return 0
  }

  size := int(this.Length())
  return size
}

func ConvertToOpenflowPacketIn(p OpenflowHeaderV10) (OpenflowPacketIn, error) {
  if !IsOpenflowPacketIn(p) {
    return NewOpenflowPacketInWithBuf(nil), errors.New("Cannot convert to openflowv10.OpenflowPacketIn")
  }

  return NewOpenflowPacketInWithBuf(p.Buf), nil
}

func IsOpenflowPacketIn(p OpenflowHeaderV10) bool {
  return p.Type() == 10 && true
}

func (this *OpenflowPacketIn) BufferId() uint32 {
  offset := this.BufferIdOffset()
  res := binary.BigEndian.Uint32(this.Buf[offset:])
  return res
}

func (this *OpenflowPacketIn) SetBufferId(b uint32) {
  offset := this.BufferIdOffset()
  binary.BigEndian.PutUint32(this.Buf[offset:], b); offset += 4
}

func (this *OpenflowPacketIn) BufferIdOffset() int {
  offset := 8
  return offset
}


func (this *OpenflowPacketIn) TotalLen() uint16 {
  offset := this.TotalLenOffset()
  res := binary.BigEndian.Uint16(this.Buf[offset:])
  return res
}

func (this *OpenflowPacketIn) SetTotalLen(t uint16) {
  offset := this.TotalLenOffset()
  binary.BigEndian.PutUint16(this.Buf[offset:], t); offset += 2
}

func (this *OpenflowPacketIn) TotalLenOffset() int {
  offset := 12
  return offset
}


func (this *OpenflowPacketIn) InPort() uint16 {
  offset := this.InPortOffset()
  res := binary.BigEndian.Uint16(this.Buf[offset:])
  return res
}

func (this *OpenflowPacketIn) SetInPort(i uint16) {
  offset := this.InPortOffset()
  binary.BigEndian.PutUint16(this.Buf[offset:], i); offset += 2
}

func (this *OpenflowPacketIn) InPortOffset() int {
  offset := 14
  return offset
}


func (this *OpenflowPacketIn) Reason() uint8 {
  offset := this.ReasonOffset()
  res := uint8(this.Buf[offset])
  return res
}

func (this *OpenflowPacketIn) SetReason(r uint8) {
  offset := this.ReasonOffset()
  this.Buf[offset] = byte(r); offset++
}

func (this *OpenflowPacketIn) ReasonOffset() int {
  offset := 16
  return offset
}


func (this *OpenflowPacketIn) Pad() uint8 {
  offset := this.PadOffset()
  res := uint8(this.Buf[offset])
  return res
}

func (this *OpenflowPacketIn) SetPad(p uint8) {
  offset := this.PadOffset()
  this.Buf[offset] = byte(p); offset++
}

func (this *OpenflowPacketIn) PadOffset() int {
  offset := 17
  return offset
}


func (this *OpenflowPacketIn) Data() []uint8 {
  offset := this.DataOffset()
  packet_size := this.Size()
  size := packet_size - offset
  count := this.Size() - offset
  i := 0
  var res []uint8
  for size > 0 && count > 0 && packet_size > offset {
    elem := uint8(this.Buf[offset])
    if size < 1 {
      break
    }
    size -= 1
    count--
    res[i] = elem
    i++
  }
  return res
}

func (this *OpenflowPacketIn) AddData(d uint8) {
  offset := this.DataOffset()
  offset += 1
  size := 1
  this.OpenGap(offset, size)
  this.SetLength(uint16(this.Size() + size))
  this.Buf[offset] = byte(d); offset++
}

func (this *OpenflowPacketIn) DataOffset() int {
  offset := 18
  return offset
}

func (this *OpenflowPacketIn) DataSize() int {
  offset := this.DataOffset()
  return this.Size() - offset
}

func NewOpenflowActionHeaderWithBuf(b []byte) OpenflowActionHeader {
  return OpenflowActionHeader{packet.Packet{Buf: b}}
}

func NewOpenflowActionHeader() OpenflowActionHeader {
  s := 4
  b := make([]byte, s)
  p := OpenflowActionHeader{packet.Packet{Buf: b}}
  p.Init()
  return p
}

type OpenflowActionHeader struct {
  packet.Packet
}

func (this OpenflowActionHeader) minSize() int {
  return 4
}

type OpenflowActionHeaderConn struct {
  net.Conn
  buf []byte
  offset int
}

func NewOpenflowActionHeaderConn(c net.Conn) OpenflowActionHeaderConn {
  return OpenflowActionHeaderConn {
    Conn: c,
    buf: make([]byte, packet.DefaultBufSize),
  }
}

func (c *OpenflowActionHeaderConn) Write(pkts []OpenflowActionHeader) error {
  for _, p := range pkts {
    s := p.Size()
    b := p.Buffer()[:s]
    n := 0
    for s > 0 {
      var err error
      if n, err = c.Conn.Write(b); err != nil {
        return fmt.Errorf("Error in write: %v", err)
      }
      s -= n
    }
  }
  return nil
}

func (c *OpenflowActionHeaderConn) Read(pkts []OpenflowActionHeader) (int, error) {
  if len(c.buf) == c.offset {
    newSize := packet.DefaultBufSize
    if newSize < len(c.buf) {
      newSize = 2 * len(c.buf)
    }

    buf := make([]byte, newSize)
    copy(buf, c.buf[:c.offset])
    c.buf = buf
  }

  r, err := c.Conn.Read(c.buf[c.offset:])
  if err != nil {
    return 0, err
  }

  r += c.offset

  s := 0
  n := 0
  for i := range pkts {
    p := NewOpenflowActionHeaderWithBuf(c.buf)

    pSize := p.Size()
    if r < s+pSize {
      break
    }

    pkts[i] = p
    s += pSize
    n++
  }

  c.offset = r - s
  if c.offset < 0 {
    panic("Invalid value for offset")
  }

  c.buf = c.buf[s:]
  if c.offset < len(c.buf) {
    return n, nil
  }

  buf := make([]byte, packet.DefaultBufSize)
  copy(buf, c.buf[:c.offset])
  c.buf = buf
  return n, nil
}

func (this *OpenflowActionHeader) Init() {
  this.SetLen(uint16(this.minSize()))
  // Invariants.
}

func (this OpenflowActionHeader) Size() int {
  if len(this.Buf) < this.minSize() {
    return 0
  }

  size := int(this.Len())
  return size
}

func ConvertToOpenflowActionHeader(p packet.Packet) (OpenflowActionHeader, error) {
  if !IsOpenflowActionHeader(p) {
    return NewOpenflowActionHeaderWithBuf(nil), errors.New("Cannot convert to openflowv10.OpenflowActionHeader")
  }

  return NewOpenflowActionHeaderWithBuf(p.Buf), nil
}

func IsOpenflowActionHeader(p packet.Packet) bool {
  return true
}

func (this *OpenflowActionHeader) Type() uint16 {
  offset := this.TypeOffset()
  res := binary.BigEndian.Uint16(this.Buf[offset:])
  return res
}

func (this *OpenflowActionHeader) SetType(t uint16) {
  offset := this.TypeOffset()
  binary.BigEndian.PutUint16(this.Buf[offset:], t); offset += 2
}

func (this *OpenflowActionHeader) TypeOffset() int {
  offset := 0
  return offset
}


func (this *OpenflowActionHeader) Len() uint16 {
  offset := this.LenOffset()
  res := binary.BigEndian.Uint16(this.Buf[offset:])
  return res
}

func (this *OpenflowActionHeader) SetLen(l uint16) {
  offset := this.LenOffset()
  binary.BigEndian.PutUint16(this.Buf[offset:], l); offset += 2
}

func (this *OpenflowActionHeader) LenOffset() int {
  offset := 2
  return offset
}


func NewOpenflowActionOutputWithBuf(b []byte) OpenflowActionOutput {
  return OpenflowActionOutput{OpenflowActionHeader{packet.Packet{Buf: b}}}
}

func NewOpenflowActionOutput() OpenflowActionOutput {
  s := 8
  b := make([]byte, s)
  p := OpenflowActionOutput{OpenflowActionHeader{packet.Packet{Buf: b}}}
  p.Init()
  return p
}

type OpenflowActionOutput struct {
  OpenflowActionHeader
}

func (this OpenflowActionOutput) minSize() int {
  return 8
}

type OpenflowActionOutputConn struct {
  net.Conn
  buf []byte
  offset int
}

func NewOpenflowActionOutputConn(c net.Conn) OpenflowActionOutputConn {
  return OpenflowActionOutputConn {
    Conn: c,
    buf: make([]byte, packet.DefaultBufSize),
  }
}

func (c *OpenflowActionOutputConn) Write(pkts []OpenflowActionOutput) error {
  for _, p := range pkts {
    s := p.Size()
    b := p.Buffer()[:s]
    n := 0
    for s > 0 {
      var err error
      if n, err = c.Conn.Write(b); err != nil {
        return fmt.Errorf("Error in write: %v", err)
      }
      s -= n
    }
  }
  return nil
}

func (c *OpenflowActionOutputConn) Read(pkts []OpenflowActionOutput) (int, error) {
  if len(c.buf) == c.offset {
    newSize := packet.DefaultBufSize
    if newSize < len(c.buf) {
      newSize = 2 * len(c.buf)
    }

    buf := make([]byte, newSize)
    copy(buf, c.buf[:c.offset])
    c.buf = buf
  }

  r, err := c.Conn.Read(c.buf[c.offset:])
  if err != nil {
    return 0, err
  }

  r += c.offset

  s := 0
  n := 0
  for i := range pkts {
    p := NewOpenflowActionOutputWithBuf(c.buf)

    pSize := p.Size()
    if r < s+pSize {
      break
    }

    pkts[i] = p
    s += pSize
    n++
  }

  c.offset = r - s
  if c.offset < 0 {
    panic("Invalid value for offset")
  }

  c.buf = c.buf[s:]
  if c.offset < len(c.buf) {
    return n, nil
  }

  buf := make([]byte, packet.DefaultBufSize)
  copy(buf, c.buf[:c.offset])
  c.buf = buf
  return n, nil
}

func (this *OpenflowActionOutput) Init() {
  this.OpenflowActionHeader.Init()
  this.SetLen(uint16(this.minSize()))
  // Invariants.
  this.SetType(uint16(0)) // type
}

func (this OpenflowActionOutput) Size() int {
  if len(this.Buf) < this.minSize() {
    return 0
  }

  size := int(this.Len())
  return size
}

func ConvertToOpenflowActionOutput(p OpenflowActionHeader) (OpenflowActionOutput, error) {
  if !IsOpenflowActionOutput(p) {
    return NewOpenflowActionOutputWithBuf(nil), errors.New("Cannot convert to openflowv10.OpenflowActionOutput")
  }

  return NewOpenflowActionOutputWithBuf(p.Buf), nil
}

func IsOpenflowActionOutput(p OpenflowActionHeader) bool {
  return p.Type() == 0 && true
}

func (this *OpenflowActionOutput) Port() uint16 {
  offset := this.PortOffset()
  res := binary.BigEndian.Uint16(this.Buf[offset:])
  return res
}

func (this *OpenflowActionOutput) SetPort(p uint16) {
  offset := this.PortOffset()
  binary.BigEndian.PutUint16(this.Buf[offset:], p); offset += 2
}

func (this *OpenflowActionOutput) PortOffset() int {
  offset := 4
  return offset
}


func (this *OpenflowActionOutput) MaxLen() uint16 {
  offset := this.MaxLenOffset()
  res := binary.BigEndian.Uint16(this.Buf[offset:])
  return res
}

func (this *OpenflowActionOutput) SetMaxLen(m uint16) {
  offset := this.MaxLenOffset()
  binary.BigEndian.PutUint16(this.Buf[offset:], m); offset += 2
}

func (this *OpenflowActionOutput) MaxLenOffset() int {
  offset := 6
  return offset
}


func NewOpenflowActionVlanVidWithBuf(b []byte) OpenflowActionVlanVid {
  return OpenflowActionVlanVid{OpenflowActionHeader{packet.Packet{Buf: b}}}
}

func NewOpenflowActionVlanVid() OpenflowActionVlanVid {
  s := 8
  b := make([]byte, s)
  p := OpenflowActionVlanVid{OpenflowActionHeader{packet.Packet{Buf: b}}}
  p.Init()
  return p
}

type OpenflowActionVlanVid struct {
  OpenflowActionHeader
}

func (this OpenflowActionVlanVid) minSize() int {
  return 8
}

type OpenflowActionVlanVidConn struct {
  net.Conn
  buf []byte
  offset int
}

func NewOpenflowActionVlanVidConn(c net.Conn) OpenflowActionVlanVidConn {
  return OpenflowActionVlanVidConn {
    Conn: c,
    buf: make([]byte, packet.DefaultBufSize),
  }
}

func (c *OpenflowActionVlanVidConn) Write(pkts []OpenflowActionVlanVid) error {
  for _, p := range pkts {
    s := p.Size()
    b := p.Buffer()[:s]
    n := 0
    for s > 0 {
      var err error
      if n, err = c.Conn.Write(b); err != nil {
        return fmt.Errorf("Error in write: %v", err)
      }
      s -= n
    }
  }
  return nil
}

func (c *OpenflowActionVlanVidConn) Read(pkts []OpenflowActionVlanVid) (int, error) {
  if len(c.buf) == c.offset {
    newSize := packet.DefaultBufSize
    if newSize < len(c.buf) {
      newSize = 2 * len(c.buf)
    }

    buf := make([]byte, newSize)
    copy(buf, c.buf[:c.offset])
    c.buf = buf
  }

  r, err := c.Conn.Read(c.buf[c.offset:])
  if err != nil {
    return 0, err
  }

  r += c.offset

  s := 0
  n := 0
  for i := range pkts {
    p := NewOpenflowActionVlanVidWithBuf(c.buf)

    pSize := p.Size()
    if r < s+pSize {
      break
    }

    pkts[i] = p
    s += pSize
    n++
  }

  c.offset = r - s
  if c.offset < 0 {
    panic("Invalid value for offset")
  }

  c.buf = c.buf[s:]
  if c.offset < len(c.buf) {
    return n, nil
  }

  buf := make([]byte, packet.DefaultBufSize)
  copy(buf, c.buf[:c.offset])
  c.buf = buf
  return n, nil
}

func (this *OpenflowActionVlanVid) Init() {
  this.OpenflowActionHeader.Init()
  this.SetLen(uint16(this.minSize()))
  // Invariants.
  this.SetType(uint16(1)) // type
}

func (this OpenflowActionVlanVid) Size() int {
  if len(this.Buf) < this.minSize() {
    return 0
  }

  size := int(this.Len())
  return size
}

func ConvertToOpenflowActionVlanVid(p OpenflowActionHeader) (OpenflowActionVlanVid, error) {
  if !IsOpenflowActionVlanVid(p) {
    return NewOpenflowActionVlanVidWithBuf(nil), errors.New("Cannot convert to openflowv10.OpenflowActionVlanVid")
  }

  return NewOpenflowActionVlanVidWithBuf(p.Buf), nil
}

func IsOpenflowActionVlanVid(p OpenflowActionHeader) bool {
  return p.Type() == 1 && true
}

func (this *OpenflowActionVlanVid) VlanVid() uint16 {
  offset := this.VlanVidOffset()
  res := binary.BigEndian.Uint16(this.Buf[offset:])
  return res
}

func (this *OpenflowActionVlanVid) SetVlanVid(v uint16) {
  offset := this.VlanVidOffset()
  binary.BigEndian.PutUint16(this.Buf[offset:], v); offset += 2
}

func (this *OpenflowActionVlanVid) VlanVidOffset() int {
  offset := 4
  return offset
}


func (this *OpenflowActionVlanVid) Pad() [2]uint8 {
  offset := this.PadOffset()
  packet_size := this.Size()
  size := packet_size - offset
  count := this.Size() - offset
  i := 0
  var res [2]uint8
  for size > 0 && count > 0 && packet_size > offset {
    elem := uint8(this.Buf[offset])
    if size < 1 {
      break
    }
    size -= 1
    count--
    res[i] = elem
    i++
  }
  return res
}

func (this *OpenflowActionVlanVid) SetPad(p [2]uint8) {
  offset := this.PadOffset()
  for _, e := range p {
    this.Buf[offset] = byte(e); offset++
  }
}

func (this *OpenflowActionVlanVid) PadOffset() int {
  offset := 6
  return offset
}


func NewOpenflowActionVlanPcpWithBuf(b []byte) OpenflowActionVlanPcp {
  return OpenflowActionVlanPcp{OpenflowActionHeader{packet.Packet{Buf: b}}}
}

func NewOpenflowActionVlanPcp() OpenflowActionVlanPcp {
  s := 8
  b := make([]byte, s)
  p := OpenflowActionVlanPcp{OpenflowActionHeader{packet.Packet{Buf: b}}}
  p.Init()
  return p
}

type OpenflowActionVlanPcp struct {
  OpenflowActionHeader
}

func (this OpenflowActionVlanPcp) minSize() int {
  return 8
}

type OpenflowActionVlanPcpConn struct {
  net.Conn
  buf []byte
  offset int
}

func NewOpenflowActionVlanPcpConn(c net.Conn) OpenflowActionVlanPcpConn {
  return OpenflowActionVlanPcpConn {
    Conn: c,
    buf: make([]byte, packet.DefaultBufSize),
  }
}

func (c *OpenflowActionVlanPcpConn) Write(pkts []OpenflowActionVlanPcp) error {
  for _, p := range pkts {
    s := p.Size()
    b := p.Buffer()[:s]
    n := 0
    for s > 0 {
      var err error
      if n, err = c.Conn.Write(b); err != nil {
        return fmt.Errorf("Error in write: %v", err)
      }
      s -= n
    }
  }
  return nil
}

func (c *OpenflowActionVlanPcpConn) Read(pkts []OpenflowActionVlanPcp) (int, error) {
  if len(c.buf) == c.offset {
    newSize := packet.DefaultBufSize
    if newSize < len(c.buf) {
      newSize = 2 * len(c.buf)
    }

    buf := make([]byte, newSize)
    copy(buf, c.buf[:c.offset])
    c.buf = buf
  }

  r, err := c.Conn.Read(c.buf[c.offset:])
  if err != nil {
    return 0, err
  }

  r += c.offset

  s := 0
  n := 0
  for i := range pkts {
    p := NewOpenflowActionVlanPcpWithBuf(c.buf)

    pSize := p.Size()
    if r < s+pSize {
      break
    }

    pkts[i] = p
    s += pSize
    n++
  }

  c.offset = r - s
  if c.offset < 0 {
    panic("Invalid value for offset")
  }

  c.buf = c.buf[s:]
  if c.offset < len(c.buf) {
    return n, nil
  }

  buf := make([]byte, packet.DefaultBufSize)
  copy(buf, c.buf[:c.offset])
  c.buf = buf
  return n, nil
}

func (this *OpenflowActionVlanPcp) Init() {
  this.OpenflowActionHeader.Init()
  this.SetLen(uint16(this.minSize()))
  // Invariants.
  this.SetType(uint16(2)) // type
}

func (this OpenflowActionVlanPcp) Size() int {
  if len(this.Buf) < this.minSize() {
    return 0
  }

  size := int(this.Len())
  return size
}

func ConvertToOpenflowActionVlanPcp(p OpenflowActionHeader) (OpenflowActionVlanPcp, error) {
  if !IsOpenflowActionVlanPcp(p) {
    return NewOpenflowActionVlanPcpWithBuf(nil), errors.New("Cannot convert to openflowv10.OpenflowActionVlanPcp")
  }

  return NewOpenflowActionVlanPcpWithBuf(p.Buf), nil
}

func IsOpenflowActionVlanPcp(p OpenflowActionHeader) bool {
  return p.Type() == 2 && true
}

func (this *OpenflowActionVlanPcp) VlanPcp() uint8 {
  offset := this.VlanPcpOffset()
  res := uint8(this.Buf[offset])
  return res
}

func (this *OpenflowActionVlanPcp) SetVlanPcp(v uint8) {
  offset := this.VlanPcpOffset()
  this.Buf[offset] = byte(v); offset++
}

func (this *OpenflowActionVlanPcp) VlanPcpOffset() int {
  offset := 4
  return offset
}


func (this *OpenflowActionVlanPcp) Pad() [3]uint8 {
  offset := this.PadOffset()
  packet_size := this.Size()
  size := packet_size - offset
  count := this.Size() - offset
  i := 0
  var res [3]uint8
  for size > 0 && count > 0 && packet_size > offset {
    elem := uint8(this.Buf[offset])
    if size < 1 {
      break
    }
    size -= 1
    count--
    res[i] = elem
    i++
  }
  return res
}

func (this *OpenflowActionVlanPcp) SetPad(p [3]uint8) {
  offset := this.PadOffset()
  for _, e := range p {
    this.Buf[offset] = byte(e); offset++
  }
}

func (this *OpenflowActionVlanPcp) PadOffset() int {
  offset := 5
  return offset
}


func NewOpenflowActionDlSrcAddrWithBuf(b []byte) OpenflowActionDlSrcAddr {
  return OpenflowActionDlSrcAddr{OpenflowActionHeader{packet.Packet{Buf: b}}}
}

func NewOpenflowActionDlSrcAddr() OpenflowActionDlSrcAddr {
  s := 16
  b := make([]byte, s)
  p := OpenflowActionDlSrcAddr{OpenflowActionHeader{packet.Packet{Buf: b}}}
  p.Init()
  return p
}

type OpenflowActionDlSrcAddr struct {
  OpenflowActionHeader
}

func (this OpenflowActionDlSrcAddr) minSize() int {
  return 16
}

type OpenflowActionDlSrcAddrConn struct {
  net.Conn
  buf []byte
  offset int
}

func NewOpenflowActionDlSrcAddrConn(c net.Conn) OpenflowActionDlSrcAddrConn {
  return OpenflowActionDlSrcAddrConn {
    Conn: c,
    buf: make([]byte, packet.DefaultBufSize),
  }
}

func (c *OpenflowActionDlSrcAddrConn) Write(pkts []OpenflowActionDlSrcAddr) error {
  for _, p := range pkts {
    s := p.Size()
    b := p.Buffer()[:s]
    n := 0
    for s > 0 {
      var err error
      if n, err = c.Conn.Write(b); err != nil {
        return fmt.Errorf("Error in write: %v", err)
      }
      s -= n
    }
  }
  return nil
}

func (c *OpenflowActionDlSrcAddrConn) Read(pkts []OpenflowActionDlSrcAddr) (int, error) {
  if len(c.buf) == c.offset {
    newSize := packet.DefaultBufSize
    if newSize < len(c.buf) {
      newSize = 2 * len(c.buf)
    }

    buf := make([]byte, newSize)
    copy(buf, c.buf[:c.offset])
    c.buf = buf
  }

  r, err := c.Conn.Read(c.buf[c.offset:])
  if err != nil {
    return 0, err
  }

  r += c.offset

  s := 0
  n := 0
  for i := range pkts {
    p := NewOpenflowActionDlSrcAddrWithBuf(c.buf)

    pSize := p.Size()
    if r < s+pSize {
      break
    }

    pkts[i] = p
    s += pSize
    n++
  }

  c.offset = r - s
  if c.offset < 0 {
    panic("Invalid value for offset")
  }

  c.buf = c.buf[s:]
  if c.offset < len(c.buf) {
    return n, nil
  }

  buf := make([]byte, packet.DefaultBufSize)
  copy(buf, c.buf[:c.offset])
  c.buf = buf
  return n, nil
}

func (this *OpenflowActionDlSrcAddr) Init() {
  this.OpenflowActionHeader.Init()
  this.SetLen(uint16(this.minSize()))
  // Invariants.
  this.SetType(uint16(4)) // type
}

func (this OpenflowActionDlSrcAddr) Size() int {
  if len(this.Buf) < this.minSize() {
    return 0
  }

  size := int(this.Len())
  return size
}

func ConvertToOpenflowActionDlSrcAddr(p OpenflowActionHeader) (OpenflowActionDlSrcAddr, error) {
  if !IsOpenflowActionDlSrcAddr(p) {
    return NewOpenflowActionDlSrcAddrWithBuf(nil), errors.New("Cannot convert to openflowv10.OpenflowActionDlSrcAddr")
  }

  return NewOpenflowActionDlSrcAddrWithBuf(p.Buf), nil
}

func IsOpenflowActionDlSrcAddr(p OpenflowActionHeader) bool {
  return p.Type() == 4 && true
}

func (this *OpenflowActionDlSrcAddr) DlAddr() [6]uint8 {
  offset := this.DlAddrOffset()
  packet_size := this.Size()
  size := packet_size - offset
  count := this.Size() - offset
  i := 0
  var res [6]uint8
  for size > 0 && count > 0 && packet_size > offset {
    elem := uint8(this.Buf[offset])
    if size < 1 {
      break
    }
    size -= 1
    count--
    res[i] = elem
    i++
  }
  return res
}

func (this *OpenflowActionDlSrcAddr) SetDlAddr(d [6]uint8) {
  offset := this.DlAddrOffset()
  for _, e := range d {
    this.Buf[offset] = byte(e); offset++
  }
}

func (this *OpenflowActionDlSrcAddr) DlAddrOffset() int {
  offset := 4
  return offset
}


func (this *OpenflowActionDlSrcAddr) Pad() [6]uint8 {
  offset := this.PadOffset()
  packet_size := this.Size()
  size := packet_size - offset
  count := this.Size() - offset
  i := 0
  var res [6]uint8
  for size > 0 && count > 0 && packet_size > offset {
    elem := uint8(this.Buf[offset])
    if size < 1 {
      break
    }
    size -= 1
    count--
    res[i] = elem
    i++
  }
  return res
}

func (this *OpenflowActionDlSrcAddr) SetPad(p [6]uint8) {
  offset := this.PadOffset()
  for _, e := range p {
    this.Buf[offset] = byte(e); offset++
  }
}

func (this *OpenflowActionDlSrcAddr) PadOffset() int {
  offset := 10
  return offset
}


func NewOpenflowActionDlDstAddrWithBuf(b []byte) OpenflowActionDlDstAddr {
  return OpenflowActionDlDstAddr{OpenflowActionHeader{packet.Packet{Buf: b}}}
}

func NewOpenflowActionDlDstAddr() OpenflowActionDlDstAddr {
  s := 16
  b := make([]byte, s)
  p := OpenflowActionDlDstAddr{OpenflowActionHeader{packet.Packet{Buf: b}}}
  p.Init()
  return p
}

type OpenflowActionDlDstAddr struct {
  OpenflowActionHeader
}

func (this OpenflowActionDlDstAddr) minSize() int {
  return 16
}

type OpenflowActionDlDstAddrConn struct {
  net.Conn
  buf []byte
  offset int
}

func NewOpenflowActionDlDstAddrConn(c net.Conn) OpenflowActionDlDstAddrConn {
  return OpenflowActionDlDstAddrConn {
    Conn: c,
    buf: make([]byte, packet.DefaultBufSize),
  }
}

func (c *OpenflowActionDlDstAddrConn) Write(pkts []OpenflowActionDlDstAddr) error {
  for _, p := range pkts {
    s := p.Size()
    b := p.Buffer()[:s]
    n := 0
    for s > 0 {
      var err error
      if n, err = c.Conn.Write(b); err != nil {
        return fmt.Errorf("Error in write: %v", err)
      }
      s -= n
    }
  }
  return nil
}

func (c *OpenflowActionDlDstAddrConn) Read(pkts []OpenflowActionDlDstAddr) (int, error) {
  if len(c.buf) == c.offset {
    newSize := packet.DefaultBufSize
    if newSize < len(c.buf) {
      newSize = 2 * len(c.buf)
    }

    buf := make([]byte, newSize)
    copy(buf, c.buf[:c.offset])
    c.buf = buf
  }

  r, err := c.Conn.Read(c.buf[c.offset:])
  if err != nil {
    return 0, err
  }

  r += c.offset

  s := 0
  n := 0
  for i := range pkts {
    p := NewOpenflowActionDlDstAddrWithBuf(c.buf)

    pSize := p.Size()
    if r < s+pSize {
      break
    }

    pkts[i] = p
    s += pSize
    n++
  }

  c.offset = r - s
  if c.offset < 0 {
    panic("Invalid value for offset")
  }

  c.buf = c.buf[s:]
  if c.offset < len(c.buf) {
    return n, nil
  }

  buf := make([]byte, packet.DefaultBufSize)
  copy(buf, c.buf[:c.offset])
  c.buf = buf
  return n, nil
}

func (this *OpenflowActionDlDstAddr) Init() {
  this.OpenflowActionHeader.Init()
  this.SetLen(uint16(this.minSize()))
  // Invariants.
  this.SetType(uint16(5)) // type
}

func (this OpenflowActionDlDstAddr) Size() int {
  if len(this.Buf) < this.minSize() {
    return 0
  }

  size := int(this.Len())
  return size
}

func ConvertToOpenflowActionDlDstAddr(p OpenflowActionHeader) (OpenflowActionDlDstAddr, error) {
  if !IsOpenflowActionDlDstAddr(p) {
    return NewOpenflowActionDlDstAddrWithBuf(nil), errors.New("Cannot convert to openflowv10.OpenflowActionDlDstAddr")
  }

  return NewOpenflowActionDlDstAddrWithBuf(p.Buf), nil
}

func IsOpenflowActionDlDstAddr(p OpenflowActionHeader) bool {
  return p.Type() == 5 && true
}

func (this *OpenflowActionDlDstAddr) DlAddr() [6]uint8 {
  offset := this.DlAddrOffset()
  packet_size := this.Size()
  size := packet_size - offset
  count := this.Size() - offset
  i := 0
  var res [6]uint8
  for size > 0 && count > 0 && packet_size > offset {
    elem := uint8(this.Buf[offset])
    if size < 1 {
      break
    }
    size -= 1
    count--
    res[i] = elem
    i++
  }
  return res
}

func (this *OpenflowActionDlDstAddr) SetDlAddr(d [6]uint8) {
  offset := this.DlAddrOffset()
  for _, e := range d {
    this.Buf[offset] = byte(e); offset++
  }
}

func (this *OpenflowActionDlDstAddr) DlAddrOffset() int {
  offset := 4
  return offset
}


func (this *OpenflowActionDlDstAddr) Pad() [6]uint8 {
  offset := this.PadOffset()
  packet_size := this.Size()
  size := packet_size - offset
  count := this.Size() - offset
  i := 0
  var res [6]uint8
  for size > 0 && count > 0 && packet_size > offset {
    elem := uint8(this.Buf[offset])
    if size < 1 {
      break
    }
    size -= 1
    count--
    res[i] = elem
    i++
  }
  return res
}

func (this *OpenflowActionDlDstAddr) SetPad(p [6]uint8) {
  offset := this.PadOffset()
  for _, e := range p {
    this.Buf[offset] = byte(e); offset++
  }
}

func (this *OpenflowActionDlDstAddr) PadOffset() int {
  offset := 10
  return offset
}


func NewOpenflowActionNwSrcAddrWithBuf(b []byte) OpenflowActionNwSrcAddr {
  return OpenflowActionNwSrcAddr{OpenflowActionHeader{packet.Packet{Buf: b}}}
}

func NewOpenflowActionNwSrcAddr() OpenflowActionNwSrcAddr {
  s := 8
  b := make([]byte, s)
  p := OpenflowActionNwSrcAddr{OpenflowActionHeader{packet.Packet{Buf: b}}}
  p.Init()
  return p
}

type OpenflowActionNwSrcAddr struct {
  OpenflowActionHeader
}

func (this OpenflowActionNwSrcAddr) minSize() int {
  return 8
}

type OpenflowActionNwSrcAddrConn struct {
  net.Conn
  buf []byte
  offset int
}

func NewOpenflowActionNwSrcAddrConn(c net.Conn) OpenflowActionNwSrcAddrConn {
  return OpenflowActionNwSrcAddrConn {
    Conn: c,
    buf: make([]byte, packet.DefaultBufSize),
  }
}

func (c *OpenflowActionNwSrcAddrConn) Write(pkts []OpenflowActionNwSrcAddr) error {
  for _, p := range pkts {
    s := p.Size()
    b := p.Buffer()[:s]
    n := 0
    for s > 0 {
      var err error
      if n, err = c.Conn.Write(b); err != nil {
        return fmt.Errorf("Error in write: %v", err)
      }
      s -= n
    }
  }
  return nil
}

func (c *OpenflowActionNwSrcAddrConn) Read(pkts []OpenflowActionNwSrcAddr) (int, error) {
  if len(c.buf) == c.offset {
    newSize := packet.DefaultBufSize
    if newSize < len(c.buf) {
      newSize = 2 * len(c.buf)
    }

    buf := make([]byte, newSize)
    copy(buf, c.buf[:c.offset])
    c.buf = buf
  }

  r, err := c.Conn.Read(c.buf[c.offset:])
  if err != nil {
    return 0, err
  }

  r += c.offset

  s := 0
  n := 0
  for i := range pkts {
    p := NewOpenflowActionNwSrcAddrWithBuf(c.buf)

    pSize := p.Size()
    if r < s+pSize {
      break
    }

    pkts[i] = p
    s += pSize
    n++
  }

  c.offset = r - s
  if c.offset < 0 {
    panic("Invalid value for offset")
  }

  c.buf = c.buf[s:]
  if c.offset < len(c.buf) {
    return n, nil
  }

  buf := make([]byte, packet.DefaultBufSize)
  copy(buf, c.buf[:c.offset])
  c.buf = buf
  return n, nil
}

func (this *OpenflowActionNwSrcAddr) Init() {
  this.OpenflowActionHeader.Init()
  this.SetLen(uint16(this.minSize()))
  // Invariants.
  this.SetType(uint16(6)) // type
}

func (this OpenflowActionNwSrcAddr) Size() int {
  if len(this.Buf) < this.minSize() {
    return 0
  }

  size := int(this.Len())
  return size
}

func ConvertToOpenflowActionNwSrcAddr(p OpenflowActionHeader) (OpenflowActionNwSrcAddr, error) {
  if !IsOpenflowActionNwSrcAddr(p) {
    return NewOpenflowActionNwSrcAddrWithBuf(nil), errors.New("Cannot convert to openflowv10.OpenflowActionNwSrcAddr")
  }

  return NewOpenflowActionNwSrcAddrWithBuf(p.Buf), nil
}

func IsOpenflowActionNwSrcAddr(p OpenflowActionHeader) bool {
  return p.Type() == 6 && true
}

func (this *OpenflowActionNwSrcAddr) NwAddr() uint32 {
  offset := this.NwAddrOffset()
  res := binary.BigEndian.Uint32(this.Buf[offset:])
  return res
}

func (this *OpenflowActionNwSrcAddr) SetNwAddr(n uint32) {
  offset := this.NwAddrOffset()
  binary.BigEndian.PutUint32(this.Buf[offset:], n); offset += 4
}

func (this *OpenflowActionNwSrcAddr) NwAddrOffset() int {
  offset := 4
  return offset
}


func NewOpenflowActionNwDstAddrWithBuf(b []byte) OpenflowActionNwDstAddr {
  return OpenflowActionNwDstAddr{OpenflowActionHeader{packet.Packet{Buf: b}}}
}

func NewOpenflowActionNwDstAddr() OpenflowActionNwDstAddr {
  s := 8
  b := make([]byte, s)
  p := OpenflowActionNwDstAddr{OpenflowActionHeader{packet.Packet{Buf: b}}}
  p.Init()
  return p
}

type OpenflowActionNwDstAddr struct {
  OpenflowActionHeader
}

func (this OpenflowActionNwDstAddr) minSize() int {
  return 8
}

type OpenflowActionNwDstAddrConn struct {
  net.Conn
  buf []byte
  offset int
}

func NewOpenflowActionNwDstAddrConn(c net.Conn) OpenflowActionNwDstAddrConn {
  return OpenflowActionNwDstAddrConn {
    Conn: c,
    buf: make([]byte, packet.DefaultBufSize),
  }
}

func (c *OpenflowActionNwDstAddrConn) Write(pkts []OpenflowActionNwDstAddr) error {
  for _, p := range pkts {
    s := p.Size()
    b := p.Buffer()[:s]
    n := 0
    for s > 0 {
      var err error
      if n, err = c.Conn.Write(b); err != nil {
        return fmt.Errorf("Error in write: %v", err)
      }
      s -= n
    }
  }
  return nil
}

func (c *OpenflowActionNwDstAddrConn) Read(pkts []OpenflowActionNwDstAddr) (int, error) {
  if len(c.buf) == c.offset {
    newSize := packet.DefaultBufSize
    if newSize < len(c.buf) {
      newSize = 2 * len(c.buf)
    }

    buf := make([]byte, newSize)
    copy(buf, c.buf[:c.offset])
    c.buf = buf
  }

  r, err := c.Conn.Read(c.buf[c.offset:])
  if err != nil {
    return 0, err
  }

  r += c.offset

  s := 0
  n := 0
  for i := range pkts {
    p := NewOpenflowActionNwDstAddrWithBuf(c.buf)

    pSize := p.Size()
    if r < s+pSize {
      break
    }

    pkts[i] = p
    s += pSize
    n++
  }

  c.offset = r - s
  if c.offset < 0 {
    panic("Invalid value for offset")
  }

  c.buf = c.buf[s:]
  if c.offset < len(c.buf) {
    return n, nil
  }

  buf := make([]byte, packet.DefaultBufSize)
  copy(buf, c.buf[:c.offset])
  c.buf = buf
  return n, nil
}

func (this *OpenflowActionNwDstAddr) Init() {
  this.OpenflowActionHeader.Init()
  this.SetLen(uint16(this.minSize()))
  // Invariants.
  this.SetType(uint16(7)) // type
}

func (this OpenflowActionNwDstAddr) Size() int {
  if len(this.Buf) < this.minSize() {
    return 0
  }

  size := int(this.Len())
  return size
}

func ConvertToOpenflowActionNwDstAddr(p OpenflowActionHeader) (OpenflowActionNwDstAddr, error) {
  if !IsOpenflowActionNwDstAddr(p) {
    return NewOpenflowActionNwDstAddrWithBuf(nil), errors.New("Cannot convert to openflowv10.OpenflowActionNwDstAddr")
  }

  return NewOpenflowActionNwDstAddrWithBuf(p.Buf), nil
}

func IsOpenflowActionNwDstAddr(p OpenflowActionHeader) bool {
  return p.Type() == 7 && true
}

func (this *OpenflowActionNwDstAddr) NwAddr() uint32 {
  offset := this.NwAddrOffset()
  res := binary.BigEndian.Uint32(this.Buf[offset:])
  return res
}

func (this *OpenflowActionNwDstAddr) SetNwAddr(n uint32) {
  offset := this.NwAddrOffset()
  binary.BigEndian.PutUint32(this.Buf[offset:], n); offset += 4
}

func (this *OpenflowActionNwDstAddr) NwAddrOffset() int {
  offset := 4
  return offset
}


func NewOpenflowActionTpSrcPortWithBuf(b []byte) OpenflowActionTpSrcPort {
  return OpenflowActionTpSrcPort{OpenflowActionHeader{packet.Packet{Buf: b}}}
}

func NewOpenflowActionTpSrcPort() OpenflowActionTpSrcPort {
  s := 8
  b := make([]byte, s)
  p := OpenflowActionTpSrcPort{OpenflowActionHeader{packet.Packet{Buf: b}}}
  p.Init()
  return p
}

type OpenflowActionTpSrcPort struct {
  OpenflowActionHeader
}

func (this OpenflowActionTpSrcPort) minSize() int {
  return 8
}

type OpenflowActionTpSrcPortConn struct {
  net.Conn
  buf []byte
  offset int
}

func NewOpenflowActionTpSrcPortConn(c net.Conn) OpenflowActionTpSrcPortConn {
  return OpenflowActionTpSrcPortConn {
    Conn: c,
    buf: make([]byte, packet.DefaultBufSize),
  }
}

func (c *OpenflowActionTpSrcPortConn) Write(pkts []OpenflowActionTpSrcPort) error {
  for _, p := range pkts {
    s := p.Size()
    b := p.Buffer()[:s]
    n := 0
    for s > 0 {
      var err error
      if n, err = c.Conn.Write(b); err != nil {
        return fmt.Errorf("Error in write: %v", err)
      }
      s -= n
    }
  }
  return nil
}

func (c *OpenflowActionTpSrcPortConn) Read(pkts []OpenflowActionTpSrcPort) (int, error) {
  if len(c.buf) == c.offset {
    newSize := packet.DefaultBufSize
    if newSize < len(c.buf) {
      newSize = 2 * len(c.buf)
    }

    buf := make([]byte, newSize)
    copy(buf, c.buf[:c.offset])
    c.buf = buf
  }

  r, err := c.Conn.Read(c.buf[c.offset:])
  if err != nil {
    return 0, err
  }

  r += c.offset

  s := 0
  n := 0
  for i := range pkts {
    p := NewOpenflowActionTpSrcPortWithBuf(c.buf)

    pSize := p.Size()
    if r < s+pSize {
      break
    }

    pkts[i] = p
    s += pSize
    n++
  }

  c.offset = r - s
  if c.offset < 0 {
    panic("Invalid value for offset")
  }

  c.buf = c.buf[s:]
  if c.offset < len(c.buf) {
    return n, nil
  }

  buf := make([]byte, packet.DefaultBufSize)
  copy(buf, c.buf[:c.offset])
  c.buf = buf
  return n, nil
}

func (this *OpenflowActionTpSrcPort) Init() {
  this.OpenflowActionHeader.Init()
  this.SetLen(uint16(this.minSize()))
  // Invariants.
  this.SetType(uint16(9)) // type
}

func (this OpenflowActionTpSrcPort) Size() int {
  if len(this.Buf) < this.minSize() {
    return 0
  }

  size := int(this.Len())
  return size
}

func ConvertToOpenflowActionTpSrcPort(p OpenflowActionHeader) (OpenflowActionTpSrcPort, error) {
  if !IsOpenflowActionTpSrcPort(p) {
    return NewOpenflowActionTpSrcPortWithBuf(nil), errors.New("Cannot convert to openflowv10.OpenflowActionTpSrcPort")
  }

  return NewOpenflowActionTpSrcPortWithBuf(p.Buf), nil
}

func IsOpenflowActionTpSrcPort(p OpenflowActionHeader) bool {
  return p.Type() == 9 && true
}

func (this *OpenflowActionTpSrcPort) TpPort() uint16 {
  offset := this.TpPortOffset()
  res := binary.BigEndian.Uint16(this.Buf[offset:])
  return res
}

func (this *OpenflowActionTpSrcPort) SetTpPort(t uint16) {
  offset := this.TpPortOffset()
  binary.BigEndian.PutUint16(this.Buf[offset:], t); offset += 2
}

func (this *OpenflowActionTpSrcPort) TpPortOffset() int {
  offset := 4
  return offset
}


func (this *OpenflowActionTpSrcPort) Pad() [2]uint8 {
  offset := this.PadOffset()
  packet_size := this.Size()
  size := packet_size - offset
  count := this.Size() - offset
  i := 0
  var res [2]uint8
  for size > 0 && count > 0 && packet_size > offset {
    elem := uint8(this.Buf[offset])
    if size < 1 {
      break
    }
    size -= 1
    count--
    res[i] = elem
    i++
  }
  return res
}

func (this *OpenflowActionTpSrcPort) SetPad(p [2]uint8) {
  offset := this.PadOffset()
  for _, e := range p {
    this.Buf[offset] = byte(e); offset++
  }
}

func (this *OpenflowActionTpSrcPort) PadOffset() int {
  offset := 6
  return offset
}


func NewOpenflowActionTpDstPortWithBuf(b []byte) OpenflowActionTpDstPort {
  return OpenflowActionTpDstPort{OpenflowActionHeader{packet.Packet{Buf: b}}}
}

func NewOpenflowActionTpDstPort() OpenflowActionTpDstPort {
  s := 8
  b := make([]byte, s)
  p := OpenflowActionTpDstPort{OpenflowActionHeader{packet.Packet{Buf: b}}}
  p.Init()
  return p
}

type OpenflowActionTpDstPort struct {
  OpenflowActionHeader
}

func (this OpenflowActionTpDstPort) minSize() int {
  return 8
}

type OpenflowActionTpDstPortConn struct {
  net.Conn
  buf []byte
  offset int
}

func NewOpenflowActionTpDstPortConn(c net.Conn) OpenflowActionTpDstPortConn {
  return OpenflowActionTpDstPortConn {
    Conn: c,
    buf: make([]byte, packet.DefaultBufSize),
  }
}

func (c *OpenflowActionTpDstPortConn) Write(pkts []OpenflowActionTpDstPort) error {
  for _, p := range pkts {
    s := p.Size()
    b := p.Buffer()[:s]
    n := 0
    for s > 0 {
      var err error
      if n, err = c.Conn.Write(b); err != nil {
        return fmt.Errorf("Error in write: %v", err)
      }
      s -= n
    }
  }
  return nil
}

func (c *OpenflowActionTpDstPortConn) Read(pkts []OpenflowActionTpDstPort) (int, error) {
  if len(c.buf) == c.offset {
    newSize := packet.DefaultBufSize
    if newSize < len(c.buf) {
      newSize = 2 * len(c.buf)
    }

    buf := make([]byte, newSize)
    copy(buf, c.buf[:c.offset])
    c.buf = buf
  }

  r, err := c.Conn.Read(c.buf[c.offset:])
  if err != nil {
    return 0, err
  }

  r += c.offset

  s := 0
  n := 0
  for i := range pkts {
    p := NewOpenflowActionTpDstPortWithBuf(c.buf)

    pSize := p.Size()
    if r < s+pSize {
      break
    }

    pkts[i] = p
    s += pSize
    n++
  }

  c.offset = r - s
  if c.offset < 0 {
    panic("Invalid value for offset")
  }

  c.buf = c.buf[s:]
  if c.offset < len(c.buf) {
    return n, nil
  }

  buf := make([]byte, packet.DefaultBufSize)
  copy(buf, c.buf[:c.offset])
  c.buf = buf
  return n, nil
}

func (this *OpenflowActionTpDstPort) Init() {
  this.OpenflowActionHeader.Init()
  this.SetLen(uint16(this.minSize()))
  // Invariants.
  this.SetType(uint16(10)) // type
}

func (this OpenflowActionTpDstPort) Size() int {
  if len(this.Buf) < this.minSize() {
    return 0
  }

  size := int(this.Len())
  return size
}

func ConvertToOpenflowActionTpDstPort(p OpenflowActionHeader) (OpenflowActionTpDstPort, error) {
  if !IsOpenflowActionTpDstPort(p) {
    return NewOpenflowActionTpDstPortWithBuf(nil), errors.New("Cannot convert to openflowv10.OpenflowActionTpDstPort")
  }

  return NewOpenflowActionTpDstPortWithBuf(p.Buf), nil
}

func IsOpenflowActionTpDstPort(p OpenflowActionHeader) bool {
  return p.Type() == 10 && true
}

func (this *OpenflowActionTpDstPort) TpPort() uint16 {
  offset := this.TpPortOffset()
  res := binary.BigEndian.Uint16(this.Buf[offset:])
  return res
}

func (this *OpenflowActionTpDstPort) SetTpPort(t uint16) {
  offset := this.TpPortOffset()
  binary.BigEndian.PutUint16(this.Buf[offset:], t); offset += 2
}

func (this *OpenflowActionTpDstPort) TpPortOffset() int {
  offset := 4
  return offset
}


func (this *OpenflowActionTpDstPort) Pad() [2]uint8 {
  offset := this.PadOffset()
  packet_size := this.Size()
  size := packet_size - offset
  count := this.Size() - offset
  i := 0
  var res [2]uint8
  for size > 0 && count > 0 && packet_size > offset {
    elem := uint8(this.Buf[offset])
    if size < 1 {
      break
    }
    size -= 1
    count--
    res[i] = elem
    i++
  }
  return res
}

func (this *OpenflowActionTpDstPort) SetPad(p [2]uint8) {
  offset := this.PadOffset()
  for _, e := range p {
    this.Buf[offset] = byte(e); offset++
  }
}

func (this *OpenflowActionTpDstPort) PadOffset() int {
  offset := 6
  return offset
}


func NewOpenflowActionNwTosWithBuf(b []byte) OpenflowActionNwTos {
  return OpenflowActionNwTos{OpenflowActionHeader{packet.Packet{Buf: b}}}
}

func NewOpenflowActionNwTos() OpenflowActionNwTos {
  s := 8
  b := make([]byte, s)
  p := OpenflowActionNwTos{OpenflowActionHeader{packet.Packet{Buf: b}}}
  p.Init()
  return p
}

type OpenflowActionNwTos struct {
  OpenflowActionHeader
}

func (this OpenflowActionNwTos) minSize() int {
  return 8
}

type OpenflowActionNwTosConn struct {
  net.Conn
  buf []byte
  offset int
}

func NewOpenflowActionNwTosConn(c net.Conn) OpenflowActionNwTosConn {
  return OpenflowActionNwTosConn {
    Conn: c,
    buf: make([]byte, packet.DefaultBufSize),
  }
}

func (c *OpenflowActionNwTosConn) Write(pkts []OpenflowActionNwTos) error {
  for _, p := range pkts {
    s := p.Size()
    b := p.Buffer()[:s]
    n := 0
    for s > 0 {
      var err error
      if n, err = c.Conn.Write(b); err != nil {
        return fmt.Errorf("Error in write: %v", err)
      }
      s -= n
    }
  }
  return nil
}

func (c *OpenflowActionNwTosConn) Read(pkts []OpenflowActionNwTos) (int, error) {
  if len(c.buf) == c.offset {
    newSize := packet.DefaultBufSize
    if newSize < len(c.buf) {
      newSize = 2 * len(c.buf)
    }

    buf := make([]byte, newSize)
    copy(buf, c.buf[:c.offset])
    c.buf = buf
  }

  r, err := c.Conn.Read(c.buf[c.offset:])
  if err != nil {
    return 0, err
  }

  r += c.offset

  s := 0
  n := 0
  for i := range pkts {
    p := NewOpenflowActionNwTosWithBuf(c.buf)

    pSize := p.Size()
    if r < s+pSize {
      break
    }

    pkts[i] = p
    s += pSize
    n++
  }

  c.offset = r - s
  if c.offset < 0 {
    panic("Invalid value for offset")
  }

  c.buf = c.buf[s:]
  if c.offset < len(c.buf) {
    return n, nil
  }

  buf := make([]byte, packet.DefaultBufSize)
  copy(buf, c.buf[:c.offset])
  c.buf = buf
  return n, nil
}

func (this *OpenflowActionNwTos) Init() {
  this.OpenflowActionHeader.Init()
  this.SetLen(uint16(this.minSize()))
  // Invariants.
  this.SetType(uint16(8)) // type
}

func (this OpenflowActionNwTos) Size() int {
  if len(this.Buf) < this.minSize() {
    return 0
  }

  size := int(this.Len())
  return size
}

func ConvertToOpenflowActionNwTos(p OpenflowActionHeader) (OpenflowActionNwTos, error) {
  if !IsOpenflowActionNwTos(p) {
    return NewOpenflowActionNwTosWithBuf(nil), errors.New("Cannot convert to openflowv10.OpenflowActionNwTos")
  }

  return NewOpenflowActionNwTosWithBuf(p.Buf), nil
}

func IsOpenflowActionNwTos(p OpenflowActionHeader) bool {
  return p.Type() == 8 && true
}

func (this *OpenflowActionNwTos) NwTos() uint8 {
  offset := this.NwTosOffset()
  res := uint8(this.Buf[offset])
  return res
}

func (this *OpenflowActionNwTos) SetNwTos(n uint8) {
  offset := this.NwTosOffset()
  this.Buf[offset] = byte(n); offset++
}

func (this *OpenflowActionNwTos) NwTosOffset() int {
  offset := 4
  return offset
}


func (this *OpenflowActionNwTos) Pad() [3]uint8 {
  offset := this.PadOffset()
  packet_size := this.Size()
  size := packet_size - offset
  count := this.Size() - offset
  i := 0
  var res [3]uint8
  for size > 0 && count > 0 && packet_size > offset {
    elem := uint8(this.Buf[offset])
    if size < 1 {
      break
    }
    size -= 1
    count--
    res[i] = elem
    i++
  }
  return res
}

func (this *OpenflowActionNwTos) SetPad(p [3]uint8) {
  offset := this.PadOffset()
  for _, e := range p {
    this.Buf[offset] = byte(e); offset++
  }
}

func (this *OpenflowActionNwTos) PadOffset() int {
  offset := 5
  return offset
}


func NewOpenflowActionVendorHeaderWithBuf(b []byte) OpenflowActionVendorHeader {
  return OpenflowActionVendorHeader{OpenflowActionHeader{packet.Packet{Buf: b}}}
}

func NewOpenflowActionVendorHeader() OpenflowActionVendorHeader {
  s := 8
  b := make([]byte, s)
  p := OpenflowActionVendorHeader{OpenflowActionHeader{packet.Packet{Buf: b}}}
  p.Init()
  return p
}

type OpenflowActionVendorHeader struct {
  OpenflowActionHeader
}

func (this OpenflowActionVendorHeader) minSize() int {
  return 8
}

type OpenflowActionVendorHeaderConn struct {
  net.Conn
  buf []byte
  offset int
}

func NewOpenflowActionVendorHeaderConn(c net.Conn) OpenflowActionVendorHeaderConn {
  return OpenflowActionVendorHeaderConn {
    Conn: c,
    buf: make([]byte, packet.DefaultBufSize),
  }
}

func (c *OpenflowActionVendorHeaderConn) Write(pkts []OpenflowActionVendorHeader) error {
  for _, p := range pkts {
    s := p.Size()
    b := p.Buffer()[:s]
    n := 0
    for s > 0 {
      var err error
      if n, err = c.Conn.Write(b); err != nil {
        return fmt.Errorf("Error in write: %v", err)
      }
      s -= n
    }
  }
  return nil
}

func (c *OpenflowActionVendorHeaderConn) Read(pkts []OpenflowActionVendorHeader) (int, error) {
  if len(c.buf) == c.offset {
    newSize := packet.DefaultBufSize
    if newSize < len(c.buf) {
      newSize = 2 * len(c.buf)
    }

    buf := make([]byte, newSize)
    copy(buf, c.buf[:c.offset])
    c.buf = buf
  }

  r, err := c.Conn.Read(c.buf[c.offset:])
  if err != nil {
    return 0, err
  }

  r += c.offset

  s := 0
  n := 0
  for i := range pkts {
    p := NewOpenflowActionVendorHeaderWithBuf(c.buf)

    pSize := p.Size()
    if r < s+pSize {
      break
    }

    pkts[i] = p
    s += pSize
    n++
  }

  c.offset = r - s
  if c.offset < 0 {
    panic("Invalid value for offset")
  }

  c.buf = c.buf[s:]
  if c.offset < len(c.buf) {
    return n, nil
  }

  buf := make([]byte, packet.DefaultBufSize)
  copy(buf, c.buf[:c.offset])
  c.buf = buf
  return n, nil
}

func (this *OpenflowActionVendorHeader) Init() {
  this.OpenflowActionHeader.Init()
  this.SetLen(uint16(this.minSize()))
  // Invariants.
  this.SetType(uint16(65535)) // type
}

func (this OpenflowActionVendorHeader) Size() int {
  if len(this.Buf) < this.minSize() {
    return 0
  }

  size := int(this.Len())
  return size
}

func ConvertToOpenflowActionVendorHeader(p OpenflowActionHeader) (OpenflowActionVendorHeader, error) {
  if !IsOpenflowActionVendorHeader(p) {
    return NewOpenflowActionVendorHeaderWithBuf(nil), errors.New("Cannot convert to openflowv10.OpenflowActionVendorHeader")
  }

  return NewOpenflowActionVendorHeaderWithBuf(p.Buf), nil
}

func IsOpenflowActionVendorHeader(p OpenflowActionHeader) bool {
  return p.Type() == 65535 && true
}

func (this *OpenflowActionVendorHeader) Vendor() uint32 {
  offset := this.VendorOffset()
  res := binary.BigEndian.Uint32(this.Buf[offset:])
  return res
}

func (this *OpenflowActionVendorHeader) SetVendor(v uint32) {
  offset := this.VendorOffset()
  binary.BigEndian.PutUint32(this.Buf[offset:], v); offset += 4
}

func (this *OpenflowActionVendorHeader) VendorOffset() int {
  offset := 4
  return offset
}


func NewOpenflowPacketOutWithBuf(b []byte) OpenflowPacketOut {
  return OpenflowPacketOut{OpenflowHeaderV10{openflow.OpenflowHeader{packet.Packet{Buf: b}}}}
}

func NewOpenflowPacketOut() OpenflowPacketOut {
  s := 16
  b := make([]byte, s)
  p := OpenflowPacketOut{OpenflowHeaderV10{openflow.OpenflowHeader{packet.Packet{Buf: b}}}}
  p.Init()
  return p
}

type OpenflowPacketOut struct {
  OpenflowHeaderV10
}

func (this OpenflowPacketOut) minSize() int {
  return 16
}

type OpenflowPacketOutConn struct {
  net.Conn
  buf []byte
  offset int
}

func NewOpenflowPacketOutConn(c net.Conn) OpenflowPacketOutConn {
  return OpenflowPacketOutConn {
    Conn: c,
    buf: make([]byte, packet.DefaultBufSize),
  }
}

func (c *OpenflowPacketOutConn) Write(pkts []OpenflowPacketOut) error {
  for _, p := range pkts {
    s := p.Size()
    b := p.Buffer()[:s]
    n := 0
    for s > 0 {
      var err error
      if n, err = c.Conn.Write(b); err != nil {
        return fmt.Errorf("Error in write: %v", err)
      }
      s -= n
    }
  }
  return nil
}

func (c *OpenflowPacketOutConn) Read(pkts []OpenflowPacketOut) (int, error) {
  if len(c.buf) == c.offset {
    newSize := packet.DefaultBufSize
    if newSize < len(c.buf) {
      newSize = 2 * len(c.buf)
    }

    buf := make([]byte, newSize)
    copy(buf, c.buf[:c.offset])
    c.buf = buf
  }

  r, err := c.Conn.Read(c.buf[c.offset:])
  if err != nil {
    return 0, err
  }

  r += c.offset

  s := 0
  n := 0
  for i := range pkts {
    p := NewOpenflowPacketOutWithBuf(c.buf)

    pSize := p.Size()
    if r < s+pSize {
      break
    }

    pkts[i] = p
    s += pSize
    n++
  }

  c.offset = r - s
  if c.offset < 0 {
    panic("Invalid value for offset")
  }

  c.buf = c.buf[s:]
  if c.offset < len(c.buf) {
    return n, nil
  }

  buf := make([]byte, packet.DefaultBufSize)
  copy(buf, c.buf[:c.offset])
  c.buf = buf
  return n, nil
}

func (this *OpenflowPacketOut) Init() {
  this.OpenflowHeaderV10.Init()
  this.SetLength(uint16(this.minSize()))
  // Invariants.
  this.SetType(uint8(13)) // type
  this.SetVersion(uint8(1)) // version
}

func (this OpenflowPacketOut) Size() int {
  if len(this.Buf) < this.minSize() {
    return 0
  }

  size := int(this.Length())
  return size
}

func ConvertToOpenflowPacketOut(p OpenflowHeaderV10) (OpenflowPacketOut, error) {
  if !IsOpenflowPacketOut(p) {
    return NewOpenflowPacketOutWithBuf(nil), errors.New("Cannot convert to openflowv10.OpenflowPacketOut")
  }

  return NewOpenflowPacketOutWithBuf(p.Buf), nil
}

func IsOpenflowPacketOut(p OpenflowHeaderV10) bool {
  return p.Type() == 13 && true
}

func (this *OpenflowPacketOut) BufferId() uint32 {
  offset := this.BufferIdOffset()
  res := binary.BigEndian.Uint32(this.Buf[offset:])
  return res
}

func (this *OpenflowPacketOut) SetBufferId(b uint32) {
  offset := this.BufferIdOffset()
  binary.BigEndian.PutUint32(this.Buf[offset:], b); offset += 4
}

func (this *OpenflowPacketOut) BufferIdOffset() int {
  offset := 8
  return offset
}


func (this *OpenflowPacketOut) InPort() uint16 {
  offset := this.InPortOffset()
  res := binary.BigEndian.Uint16(this.Buf[offset:])
  return res
}

func (this *OpenflowPacketOut) SetInPort(i uint16) {
  offset := this.InPortOffset()
  binary.BigEndian.PutUint16(this.Buf[offset:], i); offset += 2
}

func (this *OpenflowPacketOut) InPortOffset() int {
  offset := 12
  return offset
}


func (this *OpenflowPacketOut) ActionsLen() uint16 {
  offset := this.ActionsLenOffset()
  res := binary.BigEndian.Uint16(this.Buf[offset:])
  return res
}

func (this *OpenflowPacketOut) SetActionsLen(a uint16) {
  offset := this.ActionsLenOffset()
  binary.BigEndian.PutUint16(this.Buf[offset:], a); offset += 2
}

func (this *OpenflowPacketOut) ActionsLenOffset() int {
  offset := 14
  return offset
}


func (this *OpenflowPacketOut) Actions() []OpenflowActionHeader {
  offset := this.ActionsOffset()
  packet_size := this.Size()
  size := int(this.ActionsLen())
  count := this.Size() - offset
  var res []OpenflowActionHeader
  for size > 0 && count > 0 && packet_size > offset {
    elem := NewOpenflowActionHeaderWithBuf(this.Buf[offset:])
    if elem.Size() > size {
      break
    }
    size -= elem.Size()
    count--
    res = append(res, elem)
  }
  return res
}

func (this *OpenflowPacketOut) AddActions(a OpenflowActionHeader) {
  offset := this.ActionsOffset()
  offset += this.ActionsSize()
  size := a.Size()
  this.OpenGap(offset, size)
  this.SetLength(uint16(this.Size() + size))
  copy(this.Buf[offset:], a.Buf[:a.Size()]); offset += a.Size()
  this.SetActionsLen(this.ActionsLen() + uint16(size))
}

func (this *OpenflowPacketOut) ActionsOffset() int {
  offset := 16
  return offset
}

func (this *OpenflowPacketOut) ActionsSize() int {
  return int(this.ActionsLen())
}

func (this *OpenflowPacketOut) Data() []uint8 {
  offset := this.DataOffset()
  packet_size := this.Size()
  size := packet_size - offset
  count := this.Size() - offset
  i := 0
  var res []uint8
  for size > 0 && count > 0 && packet_size > offset {
    elem := uint8(this.Buf[offset])
    if size < 1 {
      break
    }
    size -= 1
    count--
    res[i] = elem
    i++
  }
  return res
}

func (this *OpenflowPacketOut) AddData(d uint8) {
  offset := this.DataOffset()
  offset += 1
  size := 1
  this.OpenGap(offset, size)
  this.SetLength(uint16(this.Size() + size))
  this.Buf[offset] = byte(d); offset++
}

func (this *OpenflowPacketOut) DataOffset() int {
  offset := 16
  offset += this.ActionsSize()
  return offset
}

func (this *OpenflowPacketOut) DataSize() int {
  offset := this.DataOffset()
  return this.Size() - offset
}

func NewOpenflowMatchWithBuf(b []byte) OpenflowMatch {
  return OpenflowMatch{packet.Packet{Buf: b}}
}

func NewOpenflowMatch() OpenflowMatch {
  s := 40
  b := make([]byte, s)
  p := OpenflowMatch{packet.Packet{Buf: b}}
  p.Init()
  return p
}

type OpenflowMatch struct {
  packet.Packet
}

func (this OpenflowMatch) minSize() int {
  return 40
}

type OpenflowMatchConn struct {
  net.Conn
  buf []byte
  offset int
}

func NewOpenflowMatchConn(c net.Conn) OpenflowMatchConn {
  return OpenflowMatchConn {
    Conn: c,
    buf: make([]byte, packet.DefaultBufSize),
  }
}

func (c *OpenflowMatchConn) Write(pkts []OpenflowMatch) error {
  for _, p := range pkts {
    s := p.Size()
    b := p.Buffer()[:s]
    n := 0
    for s > 0 {
      var err error
      if n, err = c.Conn.Write(b); err != nil {
        return fmt.Errorf("Error in write: %v", err)
      }
      s -= n
    }
  }
  return nil
}

func (c *OpenflowMatchConn) Read(pkts []OpenflowMatch) (int, error) {
  if len(c.buf) == c.offset {
    newSize := packet.DefaultBufSize
    if newSize < len(c.buf) {
      newSize = 2 * len(c.buf)
    }

    buf := make([]byte, newSize)
    copy(buf, c.buf[:c.offset])
    c.buf = buf
  }

  r, err := c.Conn.Read(c.buf[c.offset:])
  if err != nil {
    return 0, err
  }

  r += c.offset

  s := 0
  n := 0
  for i := range pkts {
    p := NewOpenflowMatchWithBuf(c.buf)

    pSize := p.Size()
    if r < s+pSize {
      break
    }

    pkts[i] = p
    s += pSize
    n++
  }

  c.offset = r - s
  if c.offset < 0 {
    panic("Invalid value for offset")
  }

  c.buf = c.buf[s:]
  if c.offset < len(c.buf) {
    return n, nil
  }

  buf := make([]byte, packet.DefaultBufSize)
  copy(buf, c.buf[:c.offset])
  c.buf = buf
  return n, nil
}

func (this *OpenflowMatch) Init() {
  // Invariants.
}

func (this OpenflowMatch) Size() int {
  return 40
}

func ConvertToOpenflowMatch(p packet.Packet) (OpenflowMatch, error) {
  if !IsOpenflowMatch(p) {
    return NewOpenflowMatchWithBuf(nil), errors.New("Cannot convert to openflowv10.OpenflowMatch")
  }

  return NewOpenflowMatchWithBuf(p.Buf), nil
}

func IsOpenflowMatch(p packet.Packet) bool {
  return true
}

func (this *OpenflowMatch) Wildcards() uint32 {
  offset := this.WildcardsOffset()
  res := binary.BigEndian.Uint32(this.Buf[offset:])
  return res
}

func (this *OpenflowMatch) SetWildcards(w uint32) {
  offset := this.WildcardsOffset()
  binary.BigEndian.PutUint32(this.Buf[offset:], w); offset += 4
}

func (this *OpenflowMatch) WildcardsOffset() int {
  offset := 0
  return offset
}


func (this *OpenflowMatch) InPort() uint16 {
  offset := this.InPortOffset()
  res := binary.BigEndian.Uint16(this.Buf[offset:])
  return res
}

func (this *OpenflowMatch) SetInPort(i uint16) {
  offset := this.InPortOffset()
  binary.BigEndian.PutUint16(this.Buf[offset:], i); offset += 2
}

func (this *OpenflowMatch) InPortOffset() int {
  offset := 4
  return offset
}


func (this *OpenflowMatch) DlSrc() [6]uint8 {
  offset := this.DlSrcOffset()
  packet_size := this.Size()
  size := packet_size - offset
  count := this.Size() - offset
  i := 0
  var res [6]uint8
  for size > 0 && count > 0 && packet_size > offset {
    elem := uint8(this.Buf[offset])
    if size < 1 {
      break
    }
    size -= 1
    count--
    res[i] = elem
    i++
  }
  return res
}

func (this *OpenflowMatch) SetDlSrc(d [6]uint8) {
  offset := this.DlSrcOffset()
  for _, e := range d {
    this.Buf[offset] = byte(e); offset++
  }
}

func (this *OpenflowMatch) DlSrcOffset() int {
  offset := 6
  return offset
}


func (this *OpenflowMatch) DlDst() [6]uint8 {
  offset := this.DlDstOffset()
  packet_size := this.Size()
  size := packet_size - offset
  count := this.Size() - offset
  i := 0
  var res [6]uint8
  for size > 0 && count > 0 && packet_size > offset {
    elem := uint8(this.Buf[offset])
    if size < 1 {
      break
    }
    size -= 1
    count--
    res[i] = elem
    i++
  }
  return res
}

func (this *OpenflowMatch) SetDlDst(d [6]uint8) {
  offset := this.DlDstOffset()
  for _, e := range d {
    this.Buf[offset] = byte(e); offset++
  }
}

func (this *OpenflowMatch) DlDstOffset() int {
  offset := 12
  return offset
}


func (this *OpenflowMatch) DlVlan() uint16 {
  offset := this.DlVlanOffset()
  res := binary.BigEndian.Uint16(this.Buf[offset:])
  return res
}

func (this *OpenflowMatch) SetDlVlan(d uint16) {
  offset := this.DlVlanOffset()
  binary.BigEndian.PutUint16(this.Buf[offset:], d); offset += 2
}

func (this *OpenflowMatch) DlVlanOffset() int {
  offset := 18
  return offset
}


func (this *OpenflowMatch) DlVlanPcp() uint8 {
  offset := this.DlVlanPcpOffset()
  res := uint8(this.Buf[offset])
  return res
}

func (this *OpenflowMatch) SetDlVlanPcp(d uint8) {
  offset := this.DlVlanPcpOffset()
  this.Buf[offset] = byte(d); offset++
}

func (this *OpenflowMatch) DlVlanPcpOffset() int {
  offset := 20
  return offset
}


func (this *OpenflowMatch) Pad1() [1]uint8 {
  offset := this.Pad1Offset()
  packet_size := this.Size()
  size := packet_size - offset
  count := this.Size() - offset
  i := 0
  var res [1]uint8
  for size > 0 && count > 0 && packet_size > offset {
    elem := uint8(this.Buf[offset])
    if size < 1 {
      break
    }
    size -= 1
    count--
    res[i] = elem
    i++
  }
  return res
}

func (this *OpenflowMatch) SetPad1(p [1]uint8) {
  offset := this.Pad1Offset()
  for _, e := range p {
    this.Buf[offset] = byte(e); offset++
  }
}

func (this *OpenflowMatch) Pad1Offset() int {
  offset := 21
  return offset
}


func (this *OpenflowMatch) DlType() uint16 {
  offset := this.DlTypeOffset()
  res := binary.BigEndian.Uint16(this.Buf[offset:])
  return res
}

func (this *OpenflowMatch) SetDlType(d uint16) {
  offset := this.DlTypeOffset()
  binary.BigEndian.PutUint16(this.Buf[offset:], d); offset += 2
}

func (this *OpenflowMatch) DlTypeOffset() int {
  offset := 22
  return offset
}


func (this *OpenflowMatch) NwTos() uint8 {
  offset := this.NwTosOffset()
  res := uint8(this.Buf[offset])
  return res
}

func (this *OpenflowMatch) SetNwTos(n uint8) {
  offset := this.NwTosOffset()
  this.Buf[offset] = byte(n); offset++
}

func (this *OpenflowMatch) NwTosOffset() int {
  offset := 24
  return offset
}


func (this *OpenflowMatch) NwProto() uint8 {
  offset := this.NwProtoOffset()
  res := uint8(this.Buf[offset])
  return res
}

func (this *OpenflowMatch) SetNwProto(n uint8) {
  offset := this.NwProtoOffset()
  this.Buf[offset] = byte(n); offset++
}

func (this *OpenflowMatch) NwProtoOffset() int {
  offset := 25
  return offset
}


func (this *OpenflowMatch) Pad2() [2]uint8 {
  offset := this.Pad2Offset()
  packet_size := this.Size()
  size := packet_size - offset
  count := this.Size() - offset
  i := 0
  var res [2]uint8
  for size > 0 && count > 0 && packet_size > offset {
    elem := uint8(this.Buf[offset])
    if size < 1 {
      break
    }
    size -= 1
    count--
    res[i] = elem
    i++
  }
  return res
}

func (this *OpenflowMatch) SetPad2(p [2]uint8) {
  offset := this.Pad2Offset()
  for _, e := range p {
    this.Buf[offset] = byte(e); offset++
  }
}

func (this *OpenflowMatch) Pad2Offset() int {
  offset := 26
  return offset
}


func (this *OpenflowMatch) NwSrc() uint32 {
  offset := this.NwSrcOffset()
  res := binary.BigEndian.Uint32(this.Buf[offset:])
  return res
}

func (this *OpenflowMatch) SetNwSrc(n uint32) {
  offset := this.NwSrcOffset()
  binary.BigEndian.PutUint32(this.Buf[offset:], n); offset += 4
}

func (this *OpenflowMatch) NwSrcOffset() int {
  offset := 28
  return offset
}


func (this *OpenflowMatch) NwDst() uint32 {
  offset := this.NwDstOffset()
  res := binary.BigEndian.Uint32(this.Buf[offset:])
  return res
}

func (this *OpenflowMatch) SetNwDst(n uint32) {
  offset := this.NwDstOffset()
  binary.BigEndian.PutUint32(this.Buf[offset:], n); offset += 4
}

func (this *OpenflowMatch) NwDstOffset() int {
  offset := 32
  return offset
}


func (this *OpenflowMatch) TpSrc() uint16 {
  offset := this.TpSrcOffset()
  res := binary.BigEndian.Uint16(this.Buf[offset:])
  return res
}

func (this *OpenflowMatch) SetTpSrc(t uint16) {
  offset := this.TpSrcOffset()
  binary.BigEndian.PutUint16(this.Buf[offset:], t); offset += 2
}

func (this *OpenflowMatch) TpSrcOffset() int {
  offset := 36
  return offset
}


func (this *OpenflowMatch) TpDst() uint16 {
  offset := this.TpDstOffset()
  res := binary.BigEndian.Uint16(this.Buf[offset:])
  return res
}

func (this *OpenflowMatch) SetTpDst(t uint16) {
  offset := this.TpDstOffset()
  binary.BigEndian.PutUint16(this.Buf[offset:], t); offset += 2
}

func (this *OpenflowMatch) TpDstOffset() int {
  offset := 38
  return offset
}


func NewOpenflowFlowModWithBuf(b []byte) OpenflowFlowMod {
  return OpenflowFlowMod{OpenflowHeaderV10{openflow.OpenflowHeader{packet.Packet{Buf: b}}}}
}

func NewOpenflowFlowMod() OpenflowFlowMod {
  s := 72
  b := make([]byte, s)
  p := OpenflowFlowMod{OpenflowHeaderV10{openflow.OpenflowHeader{packet.Packet{Buf: b}}}}
  p.Init()
  return p
}

type OpenflowFlowMod struct {
  OpenflowHeaderV10
}

func (this OpenflowFlowMod) minSize() int {
  return 72
}

type OpenflowFlowModConn struct {
  net.Conn
  buf []byte
  offset int
}

func NewOpenflowFlowModConn(c net.Conn) OpenflowFlowModConn {
  return OpenflowFlowModConn {
    Conn: c,
    buf: make([]byte, packet.DefaultBufSize),
  }
}

func (c *OpenflowFlowModConn) Write(pkts []OpenflowFlowMod) error {
  for _, p := range pkts {
    s := p.Size()
    b := p.Buffer()[:s]
    n := 0
    for s > 0 {
      var err error
      if n, err = c.Conn.Write(b); err != nil {
        return fmt.Errorf("Error in write: %v", err)
      }
      s -= n
    }
  }
  return nil
}

func (c *OpenflowFlowModConn) Read(pkts []OpenflowFlowMod) (int, error) {
  if len(c.buf) == c.offset {
    newSize := packet.DefaultBufSize
    if newSize < len(c.buf) {
      newSize = 2 * len(c.buf)
    }

    buf := make([]byte, newSize)
    copy(buf, c.buf[:c.offset])
    c.buf = buf
  }

  r, err := c.Conn.Read(c.buf[c.offset:])
  if err != nil {
    return 0, err
  }

  r += c.offset

  s := 0
  n := 0
  for i := range pkts {
    p := NewOpenflowFlowModWithBuf(c.buf)

    pSize := p.Size()
    if r < s+pSize {
      break
    }

    pkts[i] = p
    s += pSize
    n++
  }

  c.offset = r - s
  if c.offset < 0 {
    panic("Invalid value for offset")
  }

  c.buf = c.buf[s:]
  if c.offset < len(c.buf) {
    return n, nil
  }

  buf := make([]byte, packet.DefaultBufSize)
  copy(buf, c.buf[:c.offset])
  c.buf = buf
  return n, nil
}

func (this *OpenflowFlowMod) Init() {
  this.OpenflowHeaderV10.Init()
  this.SetLength(uint16(this.minSize()))
  // Invariants.
  this.SetType(uint8(14)) // type
  this.SetVersion(uint8(1)) // version
}

func (this OpenflowFlowMod) Size() int {
  if len(this.Buf) < this.minSize() {
    return 0
  }

  size := int(this.Length())
  return size
}

func ConvertToOpenflowFlowMod(p OpenflowHeaderV10) (OpenflowFlowMod, error) {
  if !IsOpenflowFlowMod(p) {
    return NewOpenflowFlowModWithBuf(nil), errors.New("Cannot convert to openflowv10.OpenflowFlowMod")
  }

  return NewOpenflowFlowModWithBuf(p.Buf), nil
}

func IsOpenflowFlowMod(p OpenflowHeaderV10) bool {
  return p.Type() == 14 && true
}

func (this *OpenflowFlowMod) Match() OpenflowMatch {
  offset := this.MatchOffset()
  res := NewOpenflowMatchWithBuf(this.Buf[offset:])
  return res
}

func (this *OpenflowFlowMod) SetMatch(m OpenflowMatch) {
  offset := this.MatchOffset()
  copy(this.Buf[offset:], m.Buf[:m.Size()]); offset += m.Size()
}

func (this *OpenflowFlowMod) MatchOffset() int {
  offset := 8
  return offset
}


func (this *OpenflowFlowMod) Cookie() uint64 {
  offset := this.CookieOffset()
  res := binary.BigEndian.Uint64(this.Buf[offset:])
  return res
}

func (this *OpenflowFlowMod) SetCookie(c uint64) {
  offset := this.CookieOffset()
  binary.BigEndian.PutUint64(this.Buf[offset:], c); offset += 8
}

func (this *OpenflowFlowMod) CookieOffset() int {
  offset := 48
  return offset
}


func (this *OpenflowFlowMod) Command() uint16 {
  offset := this.CommandOffset()
  res := binary.BigEndian.Uint16(this.Buf[offset:])
  return res
}

func (this *OpenflowFlowMod) SetCommand(c uint16) {
  offset := this.CommandOffset()
  binary.BigEndian.PutUint16(this.Buf[offset:], c); offset += 2
}

func (this *OpenflowFlowMod) CommandOffset() int {
  offset := 56
  return offset
}


func (this *OpenflowFlowMod) IdleTimeout() uint16 {
  offset := this.IdleTimeoutOffset()
  res := binary.BigEndian.Uint16(this.Buf[offset:])
  return res
}

func (this *OpenflowFlowMod) SetIdleTimeout(i uint16) {
  offset := this.IdleTimeoutOffset()
  binary.BigEndian.PutUint16(this.Buf[offset:], i); offset += 2
}

func (this *OpenflowFlowMod) IdleTimeoutOffset() int {
  offset := 58
  return offset
}


func (this *OpenflowFlowMod) HardTimeout() uint16 {
  offset := this.HardTimeoutOffset()
  res := binary.BigEndian.Uint16(this.Buf[offset:])
  return res
}

func (this *OpenflowFlowMod) SetHardTimeout(h uint16) {
  offset := this.HardTimeoutOffset()
  binary.BigEndian.PutUint16(this.Buf[offset:], h); offset += 2
}

func (this *OpenflowFlowMod) HardTimeoutOffset() int {
  offset := 60
  return offset
}


func (this *OpenflowFlowMod) Priority() uint16 {
  offset := this.PriorityOffset()
  res := binary.BigEndian.Uint16(this.Buf[offset:])
  return res
}

func (this *OpenflowFlowMod) SetPriority(p uint16) {
  offset := this.PriorityOffset()
  binary.BigEndian.PutUint16(this.Buf[offset:], p); offset += 2
}

func (this *OpenflowFlowMod) PriorityOffset() int {
  offset := 62
  return offset
}


func (this *OpenflowFlowMod) BufferId() uint32 {
  offset := this.BufferIdOffset()
  res := binary.BigEndian.Uint32(this.Buf[offset:])
  return res
}

func (this *OpenflowFlowMod) SetBufferId(b uint32) {
  offset := this.BufferIdOffset()
  binary.BigEndian.PutUint32(this.Buf[offset:], b); offset += 4
}

func (this *OpenflowFlowMod) BufferIdOffset() int {
  offset := 64
  return offset
}


func (this *OpenflowFlowMod) OutPort() uint16 {
  offset := this.OutPortOffset()
  res := binary.BigEndian.Uint16(this.Buf[offset:])
  return res
}

func (this *OpenflowFlowMod) SetOutPort(o uint16) {
  offset := this.OutPortOffset()
  binary.BigEndian.PutUint16(this.Buf[offset:], o); offset += 2
}

func (this *OpenflowFlowMod) OutPortOffset() int {
  offset := 68
  return offset
}


func (this *OpenflowFlowMod) Flags() uint16 {
  offset := this.FlagsOffset()
  res := binary.BigEndian.Uint16(this.Buf[offset:])
  return res
}

func (this *OpenflowFlowMod) SetFlags(f uint16) {
  offset := this.FlagsOffset()
  binary.BigEndian.PutUint16(this.Buf[offset:], f); offset += 2
}

func (this *OpenflowFlowMod) FlagsOffset() int {
  offset := 70
  return offset
}


func (this *OpenflowFlowMod) Actions() []OpenflowActionHeader {
  offset := this.ActionsOffset()
  packet_size := this.Size()
  size := packet_size - offset
  count := this.Size() - offset
  var res []OpenflowActionHeader
  for size > 0 && count > 0 && packet_size > offset {
    elem := NewOpenflowActionHeaderWithBuf(this.Buf[offset:])
    if elem.Size() > size {
      break
    }
    size -= elem.Size()
    count--
    res = append(res, elem)
  }
  return res
}

func (this *OpenflowFlowMod) AddActions(a OpenflowActionHeader) {
  offset := this.ActionsOffset()
  offset += this.ActionsSize()
  size := a.Size()
  this.OpenGap(offset, size)
  this.SetLength(uint16(this.Size() + size))
  copy(this.Buf[offset:], a.Buf[:a.Size()]); offset += a.Size()
}

func (this *OpenflowFlowMod) ActionsOffset() int {
  offset := 72
  return offset
}

func (this *OpenflowFlowMod) ActionsSize() int {
  offset := this.ActionsOffset()
  return this.Size() - offset
}

func NewOpenflowFlowRemovedWithBuf(b []byte) OpenflowFlowRemoved {
  return OpenflowFlowRemoved{OpenflowHeaderV10{openflow.OpenflowHeader{packet.Packet{Buf: b}}}}
}

func NewOpenflowFlowRemoved() OpenflowFlowRemoved {
  s := 88
  b := make([]byte, s)
  p := OpenflowFlowRemoved{OpenflowHeaderV10{openflow.OpenflowHeader{packet.Packet{Buf: b}}}}
  p.Init()
  return p
}

type OpenflowFlowRemoved struct {
  OpenflowHeaderV10
}

func (this OpenflowFlowRemoved) minSize() int {
  return 88
}

type OpenflowFlowRemovedConn struct {
  net.Conn
  buf []byte
  offset int
}

func NewOpenflowFlowRemovedConn(c net.Conn) OpenflowFlowRemovedConn {
  return OpenflowFlowRemovedConn {
    Conn: c,
    buf: make([]byte, packet.DefaultBufSize),
  }
}

func (c *OpenflowFlowRemovedConn) Write(pkts []OpenflowFlowRemoved) error {
  for _, p := range pkts {
    s := p.Size()
    b := p.Buffer()[:s]
    n := 0
    for s > 0 {
      var err error
      if n, err = c.Conn.Write(b); err != nil {
        return fmt.Errorf("Error in write: %v", err)
      }
      s -= n
    }
  }
  return nil
}

func (c *OpenflowFlowRemovedConn) Read(pkts []OpenflowFlowRemoved) (int, error) {
  if len(c.buf) == c.offset {
    newSize := packet.DefaultBufSize
    if newSize < len(c.buf) {
      newSize = 2 * len(c.buf)
    }

    buf := make([]byte, newSize)
    copy(buf, c.buf[:c.offset])
    c.buf = buf
  }

  r, err := c.Conn.Read(c.buf[c.offset:])
  if err != nil {
    return 0, err
  }

  r += c.offset

  s := 0
  n := 0
  for i := range pkts {
    p := NewOpenflowFlowRemovedWithBuf(c.buf)

    pSize := p.Size()
    if r < s+pSize {
      break
    }

    pkts[i] = p
    s += pSize
    n++
  }

  c.offset = r - s
  if c.offset < 0 {
    panic("Invalid value for offset")
  }

  c.buf = c.buf[s:]
  if c.offset < len(c.buf) {
    return n, nil
  }

  buf := make([]byte, packet.DefaultBufSize)
  copy(buf, c.buf[:c.offset])
  c.buf = buf
  return n, nil
}

func (this *OpenflowFlowRemoved) Init() {
  this.OpenflowHeaderV10.Init()
  this.SetLength(uint16(this.minSize()))
  // Invariants.
  this.SetType(uint8(11)) // type
  this.SetVersion(uint8(1)) // version
}

func (this OpenflowFlowRemoved) Size() int {
  if len(this.Buf) < this.minSize() {
    return 0
  }

  size := int(this.Length())
  return size
}

func ConvertToOpenflowFlowRemoved(p OpenflowHeaderV10) (OpenflowFlowRemoved, error) {
  if !IsOpenflowFlowRemoved(p) {
    return NewOpenflowFlowRemovedWithBuf(nil), errors.New("Cannot convert to openflowv10.OpenflowFlowRemoved")
  }

  return NewOpenflowFlowRemovedWithBuf(p.Buf), nil
}

func IsOpenflowFlowRemoved(p OpenflowHeaderV10) bool {
  return p.Type() == 11 && true
}

func (this *OpenflowFlowRemoved) Match() OpenflowMatch {
  offset := this.MatchOffset()
  res := NewOpenflowMatchWithBuf(this.Buf[offset:])
  return res
}

func (this *OpenflowFlowRemoved) SetMatch(m OpenflowMatch) {
  offset := this.MatchOffset()
  copy(this.Buf[offset:], m.Buf[:m.Size()]); offset += m.Size()
}

func (this *OpenflowFlowRemoved) MatchOffset() int {
  offset := 8
  return offset
}


func (this *OpenflowFlowRemoved) Cookie() uint64 {
  offset := this.CookieOffset()
  res := binary.BigEndian.Uint64(this.Buf[offset:])
  return res
}

func (this *OpenflowFlowRemoved) SetCookie(c uint64) {
  offset := this.CookieOffset()
  binary.BigEndian.PutUint64(this.Buf[offset:], c); offset += 8
}

func (this *OpenflowFlowRemoved) CookieOffset() int {
  offset := 48
  return offset
}


func (this *OpenflowFlowRemoved) Priority() uint16 {
  offset := this.PriorityOffset()
  res := binary.BigEndian.Uint16(this.Buf[offset:])
  return res
}

func (this *OpenflowFlowRemoved) SetPriority(p uint16) {
  offset := this.PriorityOffset()
  binary.BigEndian.PutUint16(this.Buf[offset:], p); offset += 2
}

func (this *OpenflowFlowRemoved) PriorityOffset() int {
  offset := 56
  return offset
}


func (this *OpenflowFlowRemoved) Reason() uint8 {
  offset := this.ReasonOffset()
  res := uint8(this.Buf[offset])
  return res
}

func (this *OpenflowFlowRemoved) SetReason(r uint8) {
  offset := this.ReasonOffset()
  this.Buf[offset] = byte(r); offset++
}

func (this *OpenflowFlowRemoved) ReasonOffset() int {
  offset := 58
  return offset
}


func (this *OpenflowFlowRemoved) Pad() [1]uint8 {
  offset := this.PadOffset()
  packet_size := this.Size()
  size := packet_size - offset
  count := this.Size() - offset
  i := 0
  var res [1]uint8
  for size > 0 && count > 0 && packet_size > offset {
    elem := uint8(this.Buf[offset])
    if size < 1 {
      break
    }
    size -= 1
    count--
    res[i] = elem
    i++
  }
  return res
}

func (this *OpenflowFlowRemoved) SetPad(p [1]uint8) {
  offset := this.PadOffset()
  for _, e := range p {
    this.Buf[offset] = byte(e); offset++
  }
}

func (this *OpenflowFlowRemoved) PadOffset() int {
  offset := 59
  return offset
}


func (this *OpenflowFlowRemoved) DurationSec() uint32 {
  offset := this.DurationSecOffset()
  res := binary.BigEndian.Uint32(this.Buf[offset:])
  return res
}

func (this *OpenflowFlowRemoved) SetDurationSec(d uint32) {
  offset := this.DurationSecOffset()
  binary.BigEndian.PutUint32(this.Buf[offset:], d); offset += 4
}

func (this *OpenflowFlowRemoved) DurationSecOffset() int {
  offset := 60
  return offset
}


func (this *OpenflowFlowRemoved) DurationNsec() uint32 {
  offset := this.DurationNsecOffset()
  res := binary.BigEndian.Uint32(this.Buf[offset:])
  return res
}

func (this *OpenflowFlowRemoved) SetDurationNsec(d uint32) {
  offset := this.DurationNsecOffset()
  binary.BigEndian.PutUint32(this.Buf[offset:], d); offset += 4
}

func (this *OpenflowFlowRemoved) DurationNsecOffset() int {
  offset := 64
  return offset
}


func (this *OpenflowFlowRemoved) IdleTimeout() uint16 {
  offset := this.IdleTimeoutOffset()
  res := binary.BigEndian.Uint16(this.Buf[offset:])
  return res
}

func (this *OpenflowFlowRemoved) SetIdleTimeout(i uint16) {
  offset := this.IdleTimeoutOffset()
  binary.BigEndian.PutUint16(this.Buf[offset:], i); offset += 2
}

func (this *OpenflowFlowRemoved) IdleTimeoutOffset() int {
  offset := 68
  return offset
}


func (this *OpenflowFlowRemoved) Pad2() [2]uint8 {
  offset := this.Pad2Offset()
  packet_size := this.Size()
  size := packet_size - offset
  count := this.Size() - offset
  i := 0
  var res [2]uint8
  for size > 0 && count > 0 && packet_size > offset {
    elem := uint8(this.Buf[offset])
    if size < 1 {
      break
    }
    size -= 1
    count--
    res[i] = elem
    i++
  }
  return res
}

func (this *OpenflowFlowRemoved) SetPad2(p [2]uint8) {
  offset := this.Pad2Offset()
  for _, e := range p {
    this.Buf[offset] = byte(e); offset++
  }
}

func (this *OpenflowFlowRemoved) Pad2Offset() int {
  offset := 70
  return offset
}


func (this *OpenflowFlowRemoved) PacketCount() uint64 {
  offset := this.PacketCountOffset()
  res := binary.BigEndian.Uint64(this.Buf[offset:])
  return res
}

func (this *OpenflowFlowRemoved) SetPacketCount(p uint64) {
  offset := this.PacketCountOffset()
  binary.BigEndian.PutUint64(this.Buf[offset:], p); offset += 8
}

func (this *OpenflowFlowRemoved) PacketCountOffset() int {
  offset := 72
  return offset
}


func (this *OpenflowFlowRemoved) ByteCount() uint64 {
  offset := this.ByteCountOffset()
  res := binary.BigEndian.Uint64(this.Buf[offset:])
  return res
}

func (this *OpenflowFlowRemoved) SetByteCount(b uint64) {
  offset := this.ByteCountOffset()
  binary.BigEndian.PutUint64(this.Buf[offset:], b); offset += 8
}

func (this *OpenflowFlowRemoved) ByteCountOffset() int {
  offset := 80
  return offset
}


func NewOpenflowErrorMsgWithBuf(b []byte) OpenflowErrorMsg {
  return OpenflowErrorMsg{OpenflowHeaderV10{openflow.OpenflowHeader{packet.Packet{Buf: b}}}}
}

func NewOpenflowErrorMsg() OpenflowErrorMsg {
  s := 12
  b := make([]byte, s)
  p := OpenflowErrorMsg{OpenflowHeaderV10{openflow.OpenflowHeader{packet.Packet{Buf: b}}}}
  p.Init()
  return p
}

type OpenflowErrorMsg struct {
  OpenflowHeaderV10
}

func (this OpenflowErrorMsg) minSize() int {
  return 12
}

type OpenflowErrorMsgConn struct {
  net.Conn
  buf []byte
  offset int
}

func NewOpenflowErrorMsgConn(c net.Conn) OpenflowErrorMsgConn {
  return OpenflowErrorMsgConn {
    Conn: c,
    buf: make([]byte, packet.DefaultBufSize),
  }
}

func (c *OpenflowErrorMsgConn) Write(pkts []OpenflowErrorMsg) error {
  for _, p := range pkts {
    s := p.Size()
    b := p.Buffer()[:s]
    n := 0
    for s > 0 {
      var err error
      if n, err = c.Conn.Write(b); err != nil {
        return fmt.Errorf("Error in write: %v", err)
      }
      s -= n
    }
  }
  return nil
}

func (c *OpenflowErrorMsgConn) Read(pkts []OpenflowErrorMsg) (int, error) {
  if len(c.buf) == c.offset {
    newSize := packet.DefaultBufSize
    if newSize < len(c.buf) {
      newSize = 2 * len(c.buf)
    }

    buf := make([]byte, newSize)
    copy(buf, c.buf[:c.offset])
    c.buf = buf
  }

  r, err := c.Conn.Read(c.buf[c.offset:])
  if err != nil {
    return 0, err
  }

  r += c.offset

  s := 0
  n := 0
  for i := range pkts {
    p := NewOpenflowErrorMsgWithBuf(c.buf)

    pSize := p.Size()
    if r < s+pSize {
      break
    }

    pkts[i] = p
    s += pSize
    n++
  }

  c.offset = r - s
  if c.offset < 0 {
    panic("Invalid value for offset")
  }

  c.buf = c.buf[s:]
  if c.offset < len(c.buf) {
    return n, nil
  }

  buf := make([]byte, packet.DefaultBufSize)
  copy(buf, c.buf[:c.offset])
  c.buf = buf
  return n, nil
}

func (this *OpenflowErrorMsg) Init() {
  this.OpenflowHeaderV10.Init()
  this.SetLength(uint16(this.minSize()))
  // Invariants.
  this.SetType(uint8(1)) // type
  this.SetVersion(uint8(1)) // version
}

func (this OpenflowErrorMsg) Size() int {
  if len(this.Buf) < this.minSize() {
    return 0
  }

  size := int(this.Length())
  return size
}

func ConvertToOpenflowErrorMsg(p OpenflowHeaderV10) (OpenflowErrorMsg, error) {
  if !IsOpenflowErrorMsg(p) {
    return NewOpenflowErrorMsgWithBuf(nil), errors.New("Cannot convert to openflowv10.OpenflowErrorMsg")
  }

  return NewOpenflowErrorMsgWithBuf(p.Buf), nil
}

func IsOpenflowErrorMsg(p OpenflowHeaderV10) bool {
  return p.Type() == 1 && true
}

func (this *OpenflowErrorMsg) ErrType() uint16 {
  offset := this.ErrTypeOffset()
  res := binary.BigEndian.Uint16(this.Buf[offset:])
  return res
}

func (this *OpenflowErrorMsg) SetErrType(e uint16) {
  offset := this.ErrTypeOffset()
  binary.BigEndian.PutUint16(this.Buf[offset:], e); offset += 2
}

func (this *OpenflowErrorMsg) ErrTypeOffset() int {
  offset := 8
  return offset
}


func (this *OpenflowErrorMsg) Code() uint16 {
  offset := this.CodeOffset()
  res := binary.BigEndian.Uint16(this.Buf[offset:])
  return res
}

func (this *OpenflowErrorMsg) SetCode(c uint16) {
  offset := this.CodeOffset()
  binary.BigEndian.PutUint16(this.Buf[offset:], c); offset += 2
}

func (this *OpenflowErrorMsg) CodeOffset() int {
  offset := 10
  return offset
}


func (this *OpenflowErrorMsg) Data() []uint8 {
  offset := this.DataOffset()
  packet_size := this.Size()
  size := packet_size - offset
  count := this.Size() - offset
  i := 0
  var res []uint8
  for size > 0 && count > 0 && packet_size > offset {
    elem := uint8(this.Buf[offset])
    if size < 1 {
      break
    }
    size -= 1
    count--
    res[i] = elem
    i++
  }
  return res
}

func (this *OpenflowErrorMsg) AddData(d uint8) {
  offset := this.DataOffset()
  offset += 1
  size := 1
  this.OpenGap(offset, size)
  this.SetLength(uint16(this.Size() + size))
  this.Buf[offset] = byte(d); offset++
}

func (this *OpenflowErrorMsg) DataOffset() int {
  offset := 12
  return offset
}

func (this *OpenflowErrorMsg) DataSize() int {
  offset := this.DataOffset()
  return this.Size() - offset
}

func NewOpenflowStatsRequestWithBuf(b []byte) OpenflowStatsRequest {
  return OpenflowStatsRequest{OpenflowHeaderV10{openflow.OpenflowHeader{packet.Packet{Buf: b}}}}
}

func NewOpenflowStatsRequest() OpenflowStatsRequest {
  s := 12
  b := make([]byte, s)
  p := OpenflowStatsRequest{OpenflowHeaderV10{openflow.OpenflowHeader{packet.Packet{Buf: b}}}}
  p.Init()
  return p
}

type OpenflowStatsRequest struct {
  OpenflowHeaderV10
}

func (this OpenflowStatsRequest) minSize() int {
  return 12
}

type OpenflowStatsRequestConn struct {
  net.Conn
  buf []byte
  offset int
}

func NewOpenflowStatsRequestConn(c net.Conn) OpenflowStatsRequestConn {
  return OpenflowStatsRequestConn {
    Conn: c,
    buf: make([]byte, packet.DefaultBufSize),
  }
}

func (c *OpenflowStatsRequestConn) Write(pkts []OpenflowStatsRequest) error {
  for _, p := range pkts {
    s := p.Size()
    b := p.Buffer()[:s]
    n := 0
    for s > 0 {
      var err error
      if n, err = c.Conn.Write(b); err != nil {
        return fmt.Errorf("Error in write: %v", err)
      }
      s -= n
    }
  }
  return nil
}

func (c *OpenflowStatsRequestConn) Read(pkts []OpenflowStatsRequest) (int, error) {
  if len(c.buf) == c.offset {
    newSize := packet.DefaultBufSize
    if newSize < len(c.buf) {
      newSize = 2 * len(c.buf)
    }

    buf := make([]byte, newSize)
    copy(buf, c.buf[:c.offset])
    c.buf = buf
  }

  r, err := c.Conn.Read(c.buf[c.offset:])
  if err != nil {
    return 0, err
  }

  r += c.offset

  s := 0
  n := 0
  for i := range pkts {
    p := NewOpenflowStatsRequestWithBuf(c.buf)

    pSize := p.Size()
    if r < s+pSize {
      break
    }

    pkts[i] = p
    s += pSize
    n++
  }

  c.offset = r - s
  if c.offset < 0 {
    panic("Invalid value for offset")
  }

  c.buf = c.buf[s:]
  if c.offset < len(c.buf) {
    return n, nil
  }

  buf := make([]byte, packet.DefaultBufSize)
  copy(buf, c.buf[:c.offset])
  c.buf = buf
  return n, nil
}

func (this *OpenflowStatsRequest) Init() {
  this.OpenflowHeaderV10.Init()
  this.SetLength(uint16(this.minSize()))
  // Invariants.
  this.SetType(uint8(16)) // type
  this.SetVersion(uint8(1)) // version
}

func (this OpenflowStatsRequest) Size() int {
  if len(this.Buf) < this.minSize() {
    return 0
  }

  size := int(this.Length())
  return size
}

func ConvertToOpenflowStatsRequest(p OpenflowHeaderV10) (OpenflowStatsRequest, error) {
  if !IsOpenflowStatsRequest(p) {
    return NewOpenflowStatsRequestWithBuf(nil), errors.New("Cannot convert to openflowv10.OpenflowStatsRequest")
  }

  return NewOpenflowStatsRequestWithBuf(p.Buf), nil
}

func IsOpenflowStatsRequest(p OpenflowHeaderV10) bool {
  return p.Type() == 16 && true
}

func (this *OpenflowStatsRequest) StatsType() uint16 {
  offset := this.StatsTypeOffset()
  res := binary.BigEndian.Uint16(this.Buf[offset:])
  return res
}

func (this *OpenflowStatsRequest) SetStatsType(s uint16) {
  offset := this.StatsTypeOffset()
  binary.BigEndian.PutUint16(this.Buf[offset:], s); offset += 2
}

func (this *OpenflowStatsRequest) StatsTypeOffset() int {
  offset := 8
  return offset
}


func (this *OpenflowStatsRequest) Flags() uint16 {
  offset := this.FlagsOffset()
  res := binary.BigEndian.Uint16(this.Buf[offset:])
  return res
}

func (this *OpenflowStatsRequest) SetFlags(f uint16) {
  offset := this.FlagsOffset()
  binary.BigEndian.PutUint16(this.Buf[offset:], f); offset += 2
}

func (this *OpenflowStatsRequest) FlagsOffset() int {
  offset := 10
  return offset
}


func NewOpenflowStatsReplyWithBuf(b []byte) OpenflowStatsReply {
  return OpenflowStatsReply{OpenflowHeaderV10{openflow.OpenflowHeader{packet.Packet{Buf: b}}}}
}

func NewOpenflowStatsReply() OpenflowStatsReply {
  s := 12
  b := make([]byte, s)
  p := OpenflowStatsReply{OpenflowHeaderV10{openflow.OpenflowHeader{packet.Packet{Buf: b}}}}
  p.Init()
  return p
}

type OpenflowStatsReply struct {
  OpenflowHeaderV10
}

func (this OpenflowStatsReply) minSize() int {
  return 12
}

type OpenflowStatsReplyConn struct {
  net.Conn
  buf []byte
  offset int
}

func NewOpenflowStatsReplyConn(c net.Conn) OpenflowStatsReplyConn {
  return OpenflowStatsReplyConn {
    Conn: c,
    buf: make([]byte, packet.DefaultBufSize),
  }
}

func (c *OpenflowStatsReplyConn) Write(pkts []OpenflowStatsReply) error {
  for _, p := range pkts {
    s := p.Size()
    b := p.Buffer()[:s]
    n := 0
    for s > 0 {
      var err error
      if n, err = c.Conn.Write(b); err != nil {
        return fmt.Errorf("Error in write: %v", err)
      }
      s -= n
    }
  }
  return nil
}

func (c *OpenflowStatsReplyConn) Read(pkts []OpenflowStatsReply) (int, error) {
  if len(c.buf) == c.offset {
    newSize := packet.DefaultBufSize
    if newSize < len(c.buf) {
      newSize = 2 * len(c.buf)
    }

    buf := make([]byte, newSize)
    copy(buf, c.buf[:c.offset])
    c.buf = buf
  }

  r, err := c.Conn.Read(c.buf[c.offset:])
  if err != nil {
    return 0, err
  }

  r += c.offset

  s := 0
  n := 0
  for i := range pkts {
    p := NewOpenflowStatsReplyWithBuf(c.buf)

    pSize := p.Size()
    if r < s+pSize {
      break
    }

    pkts[i] = p
    s += pSize
    n++
  }

  c.offset = r - s
  if c.offset < 0 {
    panic("Invalid value for offset")
  }

  c.buf = c.buf[s:]
  if c.offset < len(c.buf) {
    return n, nil
  }

  buf := make([]byte, packet.DefaultBufSize)
  copy(buf, c.buf[:c.offset])
  c.buf = buf
  return n, nil
}

func (this *OpenflowStatsReply) Init() {
  this.OpenflowHeaderV10.Init()
  this.SetLength(uint16(this.minSize()))
  // Invariants.
  this.SetType(uint8(17)) // type
  this.SetVersion(uint8(1)) // version
}

func (this OpenflowStatsReply) Size() int {
  if len(this.Buf) < this.minSize() {
    return 0
  }

  size := int(this.Length())
  return size
}

func ConvertToOpenflowStatsReply(p OpenflowHeaderV10) (OpenflowStatsReply, error) {
  if !IsOpenflowStatsReply(p) {
    return NewOpenflowStatsReplyWithBuf(nil), errors.New("Cannot convert to openflowv10.OpenflowStatsReply")
  }

  return NewOpenflowStatsReplyWithBuf(p.Buf), nil
}

func IsOpenflowStatsReply(p OpenflowHeaderV10) bool {
  return p.Type() == 17 && true
}

func (this *OpenflowStatsReply) StatsType() uint16 {
  offset := this.StatsTypeOffset()
  res := binary.BigEndian.Uint16(this.Buf[offset:])
  return res
}

func (this *OpenflowStatsReply) SetStatsType(s uint16) {
  offset := this.StatsTypeOffset()
  binary.BigEndian.PutUint16(this.Buf[offset:], s); offset += 2
}

func (this *OpenflowStatsReply) StatsTypeOffset() int {
  offset := 8
  return offset
}


func (this *OpenflowStatsReply) Flags() uint16 {
  offset := this.FlagsOffset()
  res := binary.BigEndian.Uint16(this.Buf[offset:])
  return res
}

func (this *OpenflowStatsReply) SetFlags(f uint16) {
  offset := this.FlagsOffset()
  binary.BigEndian.PutUint16(this.Buf[offset:], f); offset += 2
}

func (this *OpenflowStatsReply) FlagsOffset() int {
  offset := 10
  return offset
}


func NewOpenflowDescStatsWithBuf(b []byte) OpenflowDescStats {
  return OpenflowDescStats{OpenflowStatsReply{OpenflowHeaderV10{openflow.OpenflowHeader{packet.Packet{Buf: b}}}}}
}

func NewOpenflowDescStats() OpenflowDescStats {
  s := 1068
  b := make([]byte, s)
  p := OpenflowDescStats{OpenflowStatsReply{OpenflowHeaderV10{openflow.OpenflowHeader{packet.Packet{Buf: b}}}}}
  p.Init()
  return p
}

type OpenflowDescStats struct {
  OpenflowStatsReply
}

func (this OpenflowDescStats) minSize() int {
  return 1068
}

type OpenflowDescStatsConn struct {
  net.Conn
  buf []byte
  offset int
}

func NewOpenflowDescStatsConn(c net.Conn) OpenflowDescStatsConn {
  return OpenflowDescStatsConn {
    Conn: c,
    buf: make([]byte, packet.DefaultBufSize),
  }
}

func (c *OpenflowDescStatsConn) Write(pkts []OpenflowDescStats) error {
  for _, p := range pkts {
    s := p.Size()
    b := p.Buffer()[:s]
    n := 0
    for s > 0 {
      var err error
      if n, err = c.Conn.Write(b); err != nil {
        return fmt.Errorf("Error in write: %v", err)
      }
      s -= n
    }
  }
  return nil
}

func (c *OpenflowDescStatsConn) Read(pkts []OpenflowDescStats) (int, error) {
  if len(c.buf) == c.offset {
    newSize := packet.DefaultBufSize
    if newSize < len(c.buf) {
      newSize = 2 * len(c.buf)
    }

    buf := make([]byte, newSize)
    copy(buf, c.buf[:c.offset])
    c.buf = buf
  }

  r, err := c.Conn.Read(c.buf[c.offset:])
  if err != nil {
    return 0, err
  }

  r += c.offset

  s := 0
  n := 0
  for i := range pkts {
    p := NewOpenflowDescStatsWithBuf(c.buf)

    pSize := p.Size()
    if r < s+pSize {
      break
    }

    pkts[i] = p
    s += pSize
    n++
  }

  c.offset = r - s
  if c.offset < 0 {
    panic("Invalid value for offset")
  }

  c.buf = c.buf[s:]
  if c.offset < len(c.buf) {
    return n, nil
  }

  buf := make([]byte, packet.DefaultBufSize)
  copy(buf, c.buf[:c.offset])
  c.buf = buf
  return n, nil
}

func (this *OpenflowDescStats) Init() {
  this.OpenflowStatsReply.Init()
  this.SetLength(uint16(this.minSize()))
  // Invariants.
  this.SetStatsType(uint16(0)) // stats_type
  this.SetType(uint8(17)) // type
  this.SetVersion(uint8(1)) // version
}

func (this OpenflowDescStats) Size() int {
  if len(this.Buf) < this.minSize() {
    return 0
  }

  size := int(this.Length())
  return size
}

func ConvertToOpenflowDescStats(p OpenflowStatsReply) (OpenflowDescStats, error) {
  if !IsOpenflowDescStats(p) {
    return NewOpenflowDescStatsWithBuf(nil), errors.New("Cannot convert to openflowv10.OpenflowDescStats")
  }

  return NewOpenflowDescStatsWithBuf(p.Buf), nil
}

func IsOpenflowDescStats(p OpenflowStatsReply) bool {
  return p.StatsType() == 0 && true
}

func (this *OpenflowDescStats) MfrDesc() [256]int8 {
  offset := this.MfrDescOffset()
  packet_size := this.Size()
  size := packet_size - offset
  count := this.Size() - offset
  i := 0
  var res [256]int8
  for size > 0 && count > 0 && packet_size > offset {
    elem := int8(this.Buf[offset])
    if size < 1 {
      break
    }
    size -= 1
    count--
    res[i] = elem
    i++
  }
  return res
}

func (this *OpenflowDescStats) SetMfrDesc(m [256]int8) {
  offset := this.MfrDescOffset()
  for _, e := range m {
    this.Buf[offset] = byte(e); offset++
  }
}

func (this *OpenflowDescStats) MfrDescOffset() int {
  offset := 12
  return offset
}


func (this *OpenflowDescStats) HwDesc() [256]int8 {
  offset := this.HwDescOffset()
  packet_size := this.Size()
  size := packet_size - offset
  count := this.Size() - offset
  i := 0
  var res [256]int8
  for size > 0 && count > 0 && packet_size > offset {
    elem := int8(this.Buf[offset])
    if size < 1 {
      break
    }
    size -= 1
    count--
    res[i] = elem
    i++
  }
  return res
}

func (this *OpenflowDescStats) SetHwDesc(h [256]int8) {
  offset := this.HwDescOffset()
  for _, e := range h {
    this.Buf[offset] = byte(e); offset++
  }
}

func (this *OpenflowDescStats) HwDescOffset() int {
  offset := 268
  return offset
}


func (this *OpenflowDescStats) SwDesc() [256]int8 {
  offset := this.SwDescOffset()
  packet_size := this.Size()
  size := packet_size - offset
  count := this.Size() - offset
  i := 0
  var res [256]int8
  for size > 0 && count > 0 && packet_size > offset {
    elem := int8(this.Buf[offset])
    if size < 1 {
      break
    }
    size -= 1
    count--
    res[i] = elem
    i++
  }
  return res
}

func (this *OpenflowDescStats) SetSwDesc(s [256]int8) {
  offset := this.SwDescOffset()
  for _, e := range s {
    this.Buf[offset] = byte(e); offset++
  }
}

func (this *OpenflowDescStats) SwDescOffset() int {
  offset := 524
  return offset
}


func (this *OpenflowDescStats) SerialNum() [32]int8 {
  offset := this.SerialNumOffset()
  packet_size := this.Size()
  size := packet_size - offset
  count := this.Size() - offset
  i := 0
  var res [32]int8
  for size > 0 && count > 0 && packet_size > offset {
    elem := int8(this.Buf[offset])
    if size < 1 {
      break
    }
    size -= 1
    count--
    res[i] = elem
    i++
  }
  return res
}

func (this *OpenflowDescStats) SetSerialNum(s [32]int8) {
  offset := this.SerialNumOffset()
  for _, e := range s {
    this.Buf[offset] = byte(e); offset++
  }
}

func (this *OpenflowDescStats) SerialNumOffset() int {
  offset := 780
  return offset
}


func (this *OpenflowDescStats) DpDesc() [256]int8 {
  offset := this.DpDescOffset()
  packet_size := this.Size()
  size := packet_size - offset
  count := this.Size() - offset
  i := 0
  var res [256]int8
  for size > 0 && count > 0 && packet_size > offset {
    elem := int8(this.Buf[offset])
    if size < 1 {
      break
    }
    size -= 1
    count--
    res[i] = elem
    i++
  }
  return res
}

func (this *OpenflowDescStats) SetDpDesc(d [256]int8) {
  offset := this.DpDescOffset()
  for _, e := range d {
    this.Buf[offset] = byte(e); offset++
  }
}

func (this *OpenflowDescStats) DpDescOffset() int {
  offset := 812
  return offset
}


func NewOpenflowFlowStatsRequestWithBuf(b []byte) OpenflowFlowStatsRequest {
  return OpenflowFlowStatsRequest{OpenflowStatsRequest{OpenflowHeaderV10{openflow.OpenflowHeader{packet.Packet{Buf: b}}}}}
}

func NewOpenflowFlowStatsRequest() OpenflowFlowStatsRequest {
  s := 56
  b := make([]byte, s)
  p := OpenflowFlowStatsRequest{OpenflowStatsRequest{OpenflowHeaderV10{openflow.OpenflowHeader{packet.Packet{Buf: b}}}}}
  p.Init()
  return p
}

type OpenflowFlowStatsRequest struct {
  OpenflowStatsRequest
}

func (this OpenflowFlowStatsRequest) minSize() int {
  return 56
}

type OpenflowFlowStatsRequestConn struct {
  net.Conn
  buf []byte
  offset int
}

func NewOpenflowFlowStatsRequestConn(c net.Conn) OpenflowFlowStatsRequestConn {
  return OpenflowFlowStatsRequestConn {
    Conn: c,
    buf: make([]byte, packet.DefaultBufSize),
  }
}

func (c *OpenflowFlowStatsRequestConn) Write(pkts []OpenflowFlowStatsRequest) error {
  for _, p := range pkts {
    s := p.Size()
    b := p.Buffer()[:s]
    n := 0
    for s > 0 {
      var err error
      if n, err = c.Conn.Write(b); err != nil {
        return fmt.Errorf("Error in write: %v", err)
      }
      s -= n
    }
  }
  return nil
}

func (c *OpenflowFlowStatsRequestConn) Read(pkts []OpenflowFlowStatsRequest) (int, error) {
  if len(c.buf) == c.offset {
    newSize := packet.DefaultBufSize
    if newSize < len(c.buf) {
      newSize = 2 * len(c.buf)
    }

    buf := make([]byte, newSize)
    copy(buf, c.buf[:c.offset])
    c.buf = buf
  }

  r, err := c.Conn.Read(c.buf[c.offset:])
  if err != nil {
    return 0, err
  }

  r += c.offset

  s := 0
  n := 0
  for i := range pkts {
    p := NewOpenflowFlowStatsRequestWithBuf(c.buf)

    pSize := p.Size()
    if r < s+pSize {
      break
    }

    pkts[i] = p
    s += pSize
    n++
  }

  c.offset = r - s
  if c.offset < 0 {
    panic("Invalid value for offset")
  }

  c.buf = c.buf[s:]
  if c.offset < len(c.buf) {
    return n, nil
  }

  buf := make([]byte, packet.DefaultBufSize)
  copy(buf, c.buf[:c.offset])
  c.buf = buf
  return n, nil
}

func (this *OpenflowFlowStatsRequest) Init() {
  this.OpenflowStatsRequest.Init()
  this.SetLength(uint16(this.minSize()))
  // Invariants.
  this.SetStatsType(uint16(1)) // stats_type
  this.SetType(uint8(16)) // type
  this.SetVersion(uint8(1)) // version
}

func (this OpenflowFlowStatsRequest) Size() int {
  if len(this.Buf) < this.minSize() {
    return 0
  }

  size := int(this.Length())
  return size
}

func ConvertToOpenflowFlowStatsRequest(p OpenflowStatsRequest) (OpenflowFlowStatsRequest, error) {
  if !IsOpenflowFlowStatsRequest(p) {
    return NewOpenflowFlowStatsRequestWithBuf(nil), errors.New("Cannot convert to openflowv10.OpenflowFlowStatsRequest")
  }

  return NewOpenflowFlowStatsRequestWithBuf(p.Buf), nil
}

func IsOpenflowFlowStatsRequest(p OpenflowStatsRequest) bool {
  return p.StatsType() == 1 && true
}

func (this *OpenflowFlowStatsRequest) Match() OpenflowMatch {
  offset := this.MatchOffset()
  res := NewOpenflowMatchWithBuf(this.Buf[offset:])
  return res
}

func (this *OpenflowFlowStatsRequest) SetMatch(m OpenflowMatch) {
  offset := this.MatchOffset()
  copy(this.Buf[offset:], m.Buf[:m.Size()]); offset += m.Size()
}

func (this *OpenflowFlowStatsRequest) MatchOffset() int {
  offset := 12
  return offset
}


func (this *OpenflowFlowStatsRequest) TableId() uint8 {
  offset := this.TableIdOffset()
  res := uint8(this.Buf[offset])
  return res
}

func (this *OpenflowFlowStatsRequest) SetTableId(t uint8) {
  offset := this.TableIdOffset()
  this.Buf[offset] = byte(t); offset++
}

func (this *OpenflowFlowStatsRequest) TableIdOffset() int {
  offset := 52
  return offset
}


func (this *OpenflowFlowStatsRequest) Pad() uint8 {
  offset := this.PadOffset()
  res := uint8(this.Buf[offset])
  return res
}

func (this *OpenflowFlowStatsRequest) SetPad(p uint8) {
  offset := this.PadOffset()
  this.Buf[offset] = byte(p); offset++
}

func (this *OpenflowFlowStatsRequest) PadOffset() int {
  offset := 53
  return offset
}


func (this *OpenflowFlowStatsRequest) OutPort() uint16 {
  offset := this.OutPortOffset()
  res := binary.BigEndian.Uint16(this.Buf[offset:])
  return res
}

func (this *OpenflowFlowStatsRequest) SetOutPort(o uint16) {
  offset := this.OutPortOffset()
  binary.BigEndian.PutUint16(this.Buf[offset:], o); offset += 2
}

func (this *OpenflowFlowStatsRequest) OutPortOffset() int {
  offset := 54
  return offset
}


func NewOpenflowFlowStatsWithBuf(b []byte) OpenflowFlowStats {
  return OpenflowFlowStats{packet.Packet{Buf: b}}
}

func NewOpenflowFlowStats() OpenflowFlowStats {
  s := 88
  b := make([]byte, s)
  p := OpenflowFlowStats{packet.Packet{Buf: b}}
  p.Init()
  return p
}

type OpenflowFlowStats struct {
  packet.Packet
}

func (this OpenflowFlowStats) minSize() int {
  return 88
}

type OpenflowFlowStatsConn struct {
  net.Conn
  buf []byte
  offset int
}

func NewOpenflowFlowStatsConn(c net.Conn) OpenflowFlowStatsConn {
  return OpenflowFlowStatsConn {
    Conn: c,
    buf: make([]byte, packet.DefaultBufSize),
  }
}

func (c *OpenflowFlowStatsConn) Write(pkts []OpenflowFlowStats) error {
  for _, p := range pkts {
    s := p.Size()
    b := p.Buffer()[:s]
    n := 0
    for s > 0 {
      var err error
      if n, err = c.Conn.Write(b); err != nil {
        return fmt.Errorf("Error in write: %v", err)
      }
      s -= n
    }
  }
  return nil
}

func (c *OpenflowFlowStatsConn) Read(pkts []OpenflowFlowStats) (int, error) {
  if len(c.buf) == c.offset {
    newSize := packet.DefaultBufSize
    if newSize < len(c.buf) {
      newSize = 2 * len(c.buf)
    }

    buf := make([]byte, newSize)
    copy(buf, c.buf[:c.offset])
    c.buf = buf
  }

  r, err := c.Conn.Read(c.buf[c.offset:])
  if err != nil {
    return 0, err
  }

  r += c.offset

  s := 0
  n := 0
  for i := range pkts {
    p := NewOpenflowFlowStatsWithBuf(c.buf)

    pSize := p.Size()
    if r < s+pSize {
      break
    }

    pkts[i] = p
    s += pSize
    n++
  }

  c.offset = r - s
  if c.offset < 0 {
    panic("Invalid value for offset")
  }

  c.buf = c.buf[s:]
  if c.offset < len(c.buf) {
    return n, nil
  }

  buf := make([]byte, packet.DefaultBufSize)
  copy(buf, c.buf[:c.offset])
  c.buf = buf
  return n, nil
}

func (this *OpenflowFlowStats) Init() {
  this.SetLength(uint16(this.minSize()))
  // Invariants.
}

func (this OpenflowFlowStats) Size() int {
  if len(this.Buf) < this.minSize() {
    return 0
  }

  size := int(this.Length())
  return size
}

func ConvertToOpenflowFlowStats(p packet.Packet) (OpenflowFlowStats, error) {
  if !IsOpenflowFlowStats(p) {
    return NewOpenflowFlowStatsWithBuf(nil), errors.New("Cannot convert to openflowv10.OpenflowFlowStats")
  }

  return NewOpenflowFlowStatsWithBuf(p.Buf), nil
}

func IsOpenflowFlowStats(p packet.Packet) bool {
  return true
}

func (this *OpenflowFlowStats) Length() uint16 {
  offset := this.LengthOffset()
  res := binary.BigEndian.Uint16(this.Buf[offset:])
  return res
}

func (this *OpenflowFlowStats) SetLength(l uint16) {
  offset := this.LengthOffset()
  binary.BigEndian.PutUint16(this.Buf[offset:], l); offset += 2
}

func (this *OpenflowFlowStats) LengthOffset() int {
  offset := 0
  return offset
}


func (this *OpenflowFlowStats) TableId() uint8 {
  offset := this.TableIdOffset()
  res := uint8(this.Buf[offset])
  return res
}

func (this *OpenflowFlowStats) SetTableId(t uint8) {
  offset := this.TableIdOffset()
  this.Buf[offset] = byte(t); offset++
}

func (this *OpenflowFlowStats) TableIdOffset() int {
  offset := 2
  return offset
}


func (this *OpenflowFlowStats) Pad() uint8 {
  offset := this.PadOffset()
  res := uint8(this.Buf[offset])
  return res
}

func (this *OpenflowFlowStats) SetPad(p uint8) {
  offset := this.PadOffset()
  this.Buf[offset] = byte(p); offset++
}

func (this *OpenflowFlowStats) PadOffset() int {
  offset := 3
  return offset
}


func (this *OpenflowFlowStats) Match() OpenflowMatch {
  offset := this.MatchOffset()
  res := NewOpenflowMatchWithBuf(this.Buf[offset:])
  return res
}

func (this *OpenflowFlowStats) SetMatch(m OpenflowMatch) {
  offset := this.MatchOffset()
  copy(this.Buf[offset:], m.Buf[:m.Size()]); offset += m.Size()
}

func (this *OpenflowFlowStats) MatchOffset() int {
  offset := 4
  return offset
}


func (this *OpenflowFlowStats) DurationSec() uint32 {
  offset := this.DurationSecOffset()
  res := binary.BigEndian.Uint32(this.Buf[offset:])
  return res
}

func (this *OpenflowFlowStats) SetDurationSec(d uint32) {
  offset := this.DurationSecOffset()
  binary.BigEndian.PutUint32(this.Buf[offset:], d); offset += 4
}

func (this *OpenflowFlowStats) DurationSecOffset() int {
  offset := 44
  return offset
}


func (this *OpenflowFlowStats) DurationNsec() uint32 {
  offset := this.DurationNsecOffset()
  res := binary.BigEndian.Uint32(this.Buf[offset:])
  return res
}

func (this *OpenflowFlowStats) SetDurationNsec(d uint32) {
  offset := this.DurationNsecOffset()
  binary.BigEndian.PutUint32(this.Buf[offset:], d); offset += 4
}

func (this *OpenflowFlowStats) DurationNsecOffset() int {
  offset := 48
  return offset
}


func (this *OpenflowFlowStats) Priority() uint16 {
  offset := this.PriorityOffset()
  res := binary.BigEndian.Uint16(this.Buf[offset:])
  return res
}

func (this *OpenflowFlowStats) SetPriority(p uint16) {
  offset := this.PriorityOffset()
  binary.BigEndian.PutUint16(this.Buf[offset:], p); offset += 2
}

func (this *OpenflowFlowStats) PriorityOffset() int {
  offset := 52
  return offset
}


func (this *OpenflowFlowStats) IdleTimeout() uint16 {
  offset := this.IdleTimeoutOffset()
  res := binary.BigEndian.Uint16(this.Buf[offset:])
  return res
}

func (this *OpenflowFlowStats) SetIdleTimeout(i uint16) {
  offset := this.IdleTimeoutOffset()
  binary.BigEndian.PutUint16(this.Buf[offset:], i); offset += 2
}

func (this *OpenflowFlowStats) IdleTimeoutOffset() int {
  offset := 54
  return offset
}


func (this *OpenflowFlowStats) HardTimeout() uint16 {
  offset := this.HardTimeoutOffset()
  res := binary.BigEndian.Uint16(this.Buf[offset:])
  return res
}

func (this *OpenflowFlowStats) SetHardTimeout(h uint16) {
  offset := this.HardTimeoutOffset()
  binary.BigEndian.PutUint16(this.Buf[offset:], h); offset += 2
}

func (this *OpenflowFlowStats) HardTimeoutOffset() int {
  offset := 56
  return offset
}


func (this *OpenflowFlowStats) Pad2() [6]uint8 {
  offset := this.Pad2Offset()
  packet_size := this.Size()
  size := packet_size - offset
  count := this.Size() - offset
  i := 0
  var res [6]uint8
  for size > 0 && count > 0 && packet_size > offset {
    elem := uint8(this.Buf[offset])
    if size < 1 {
      break
    }
    size -= 1
    count--
    res[i] = elem
    i++
  }
  return res
}

func (this *OpenflowFlowStats) SetPad2(p [6]uint8) {
  offset := this.Pad2Offset()
  for _, e := range p {
    this.Buf[offset] = byte(e); offset++
  }
}

func (this *OpenflowFlowStats) Pad2Offset() int {
  offset := 58
  return offset
}


func (this *OpenflowFlowStats) Cookie() uint64 {
  offset := this.CookieOffset()
  res := binary.BigEndian.Uint64(this.Buf[offset:])
  return res
}

func (this *OpenflowFlowStats) SetCookie(c uint64) {
  offset := this.CookieOffset()
  binary.BigEndian.PutUint64(this.Buf[offset:], c); offset += 8
}

func (this *OpenflowFlowStats) CookieOffset() int {
  offset := 64
  return offset
}


func (this *OpenflowFlowStats) PacketCount() uint64 {
  offset := this.PacketCountOffset()
  res := binary.BigEndian.Uint64(this.Buf[offset:])
  return res
}

func (this *OpenflowFlowStats) SetPacketCount(p uint64) {
  offset := this.PacketCountOffset()
  binary.BigEndian.PutUint64(this.Buf[offset:], p); offset += 8
}

func (this *OpenflowFlowStats) PacketCountOffset() int {
  offset := 72
  return offset
}


func (this *OpenflowFlowStats) ByteCount() uint64 {
  offset := this.ByteCountOffset()
  res := binary.BigEndian.Uint64(this.Buf[offset:])
  return res
}

func (this *OpenflowFlowStats) SetByteCount(b uint64) {
  offset := this.ByteCountOffset()
  binary.BigEndian.PutUint64(this.Buf[offset:], b); offset += 8
}

func (this *OpenflowFlowStats) ByteCountOffset() int {
  offset := 80
  return offset
}


func (this *OpenflowFlowStats) Actions() []OpenflowActionHeader {
  offset := this.ActionsOffset()
  packet_size := this.Size()
  size := packet_size - offset
  count := this.Size() - offset
  var res []OpenflowActionHeader
  for size > 0 && count > 0 && packet_size > offset {
    elem := NewOpenflowActionHeaderWithBuf(this.Buf[offset:])
    if elem.Size() > size {
      break
    }
    size -= elem.Size()
    count--
    res = append(res, elem)
  }
  return res
}

func (this *OpenflowFlowStats) AddActions(a OpenflowActionHeader) {
  offset := this.ActionsOffset()
  offset += this.ActionsSize()
  size := a.Size()
  this.OpenGap(offset, size)
  this.SetLength(uint16(this.Size() + size))
  copy(this.Buf[offset:], a.Buf[:a.Size()]); offset += a.Size()
}

func (this *OpenflowFlowStats) ActionsOffset() int {
  offset := 88
  return offset
}

func (this *OpenflowFlowStats) ActionsSize() int {
  offset := this.ActionsOffset()
  return this.Size() - offset
}

func NewOpenflowFlowStatsReplyWithBuf(b []byte) OpenflowFlowStatsReply {
  return OpenflowFlowStatsReply{OpenflowStatsReply{OpenflowHeaderV10{openflow.OpenflowHeader{packet.Packet{Buf: b}}}}}
}

func NewOpenflowFlowStatsReply() OpenflowFlowStatsReply {
  s := 12
  b := make([]byte, s)
  p := OpenflowFlowStatsReply{OpenflowStatsReply{OpenflowHeaderV10{openflow.OpenflowHeader{packet.Packet{Buf: b}}}}}
  p.Init()
  return p
}

type OpenflowFlowStatsReply struct {
  OpenflowStatsReply
}

func (this OpenflowFlowStatsReply) minSize() int {
  return 12
}

type OpenflowFlowStatsReplyConn struct {
  net.Conn
  buf []byte
  offset int
}

func NewOpenflowFlowStatsReplyConn(c net.Conn) OpenflowFlowStatsReplyConn {
  return OpenflowFlowStatsReplyConn {
    Conn: c,
    buf: make([]byte, packet.DefaultBufSize),
  }
}

func (c *OpenflowFlowStatsReplyConn) Write(pkts []OpenflowFlowStatsReply) error {
  for _, p := range pkts {
    s := p.Size()
    b := p.Buffer()[:s]
    n := 0
    for s > 0 {
      var err error
      if n, err = c.Conn.Write(b); err != nil {
        return fmt.Errorf("Error in write: %v", err)
      }
      s -= n
    }
  }
  return nil
}

func (c *OpenflowFlowStatsReplyConn) Read(pkts []OpenflowFlowStatsReply) (int, error) {
  if len(c.buf) == c.offset {
    newSize := packet.DefaultBufSize
    if newSize < len(c.buf) {
      newSize = 2 * len(c.buf)
    }

    buf := make([]byte, newSize)
    copy(buf, c.buf[:c.offset])
    c.buf = buf
  }

  r, err := c.Conn.Read(c.buf[c.offset:])
  if err != nil {
    return 0, err
  }

  r += c.offset

  s := 0
  n := 0
  for i := range pkts {
    p := NewOpenflowFlowStatsReplyWithBuf(c.buf)

    pSize := p.Size()
    if r < s+pSize {
      break
    }

    pkts[i] = p
    s += pSize
    n++
  }

  c.offset = r - s
  if c.offset < 0 {
    panic("Invalid value for offset")
  }

  c.buf = c.buf[s:]
  if c.offset < len(c.buf) {
    return n, nil
  }

  buf := make([]byte, packet.DefaultBufSize)
  copy(buf, c.buf[:c.offset])
  c.buf = buf
  return n, nil
}

func (this *OpenflowFlowStatsReply) Init() {
  this.OpenflowStatsReply.Init()
  this.SetLength(uint16(this.minSize()))
  // Invariants.
  this.SetStatsType(uint16(1)) // stats_type
  this.SetType(uint8(17)) // type
  this.SetVersion(uint8(1)) // version
}

func (this OpenflowFlowStatsReply) Size() int {
  if len(this.Buf) < this.minSize() {
    return 0
  }

  size := int(this.Length())
  return size
}

func ConvertToOpenflowFlowStatsReply(p OpenflowStatsReply) (OpenflowFlowStatsReply, error) {
  if !IsOpenflowFlowStatsReply(p) {
    return NewOpenflowFlowStatsReplyWithBuf(nil), errors.New("Cannot convert to openflowv10.OpenflowFlowStatsReply")
  }

  return NewOpenflowFlowStatsReplyWithBuf(p.Buf), nil
}

func IsOpenflowFlowStatsReply(p OpenflowStatsReply) bool {
  return p.StatsType() == 1 && true
}

func (this *OpenflowFlowStatsReply) FlowStats() []OpenflowFlowStats {
  offset := this.FlowStatsOffset()
  packet_size := this.Size()
  size := packet_size - offset
  count := this.Size() - offset
  var res []OpenflowFlowStats
  for size > 0 && count > 0 && packet_size > offset {
    elem := NewOpenflowFlowStatsWithBuf(this.Buf[offset:])
    if elem.Size() > size {
      break
    }
    size -= elem.Size()
    count--
    res = append(res, elem)
  }
  return res
}

func (this *OpenflowFlowStatsReply) AddFlowStats(f OpenflowFlowStats) {
  offset := this.FlowStatsOffset()
  offset += this.FlowStatsSize()
  size := f.Size()
  this.OpenGap(offset, size)
  this.SetLength(uint16(this.Size() + size))
  copy(this.Buf[offset:], f.Buf[:f.Size()]); offset += f.Size()
}

func (this *OpenflowFlowStatsReply) FlowStatsOffset() int {
  offset := 12
  return offset
}

func (this *OpenflowFlowStatsReply) FlowStatsSize() int {
  offset := this.FlowStatsOffset()
  return this.Size() - offset
}

func NewOpenflowAggregateStatsRequestWithBuf(b []byte) OpenflowAggregateStatsRequest {
  return OpenflowAggregateStatsRequest{OpenflowStatsRequest{OpenflowHeaderV10{openflow.OpenflowHeader{packet.Packet{Buf: b}}}}}
}

func NewOpenflowAggregateStatsRequest() OpenflowAggregateStatsRequest {
  s := 56
  b := make([]byte, s)
  p := OpenflowAggregateStatsRequest{OpenflowStatsRequest{OpenflowHeaderV10{openflow.OpenflowHeader{packet.Packet{Buf: b}}}}}
  p.Init()
  return p
}

type OpenflowAggregateStatsRequest struct {
  OpenflowStatsRequest
}

func (this OpenflowAggregateStatsRequest) minSize() int {
  return 56
}

type OpenflowAggregateStatsRequestConn struct {
  net.Conn
  buf []byte
  offset int
}

func NewOpenflowAggregateStatsRequestConn(c net.Conn) OpenflowAggregateStatsRequestConn {
  return OpenflowAggregateStatsRequestConn {
    Conn: c,
    buf: make([]byte, packet.DefaultBufSize),
  }
}

func (c *OpenflowAggregateStatsRequestConn) Write(pkts []OpenflowAggregateStatsRequest) error {
  for _, p := range pkts {
    s := p.Size()
    b := p.Buffer()[:s]
    n := 0
    for s > 0 {
      var err error
      if n, err = c.Conn.Write(b); err != nil {
        return fmt.Errorf("Error in write: %v", err)
      }
      s -= n
    }
  }
  return nil
}

func (c *OpenflowAggregateStatsRequestConn) Read(pkts []OpenflowAggregateStatsRequest) (int, error) {
  if len(c.buf) == c.offset {
    newSize := packet.DefaultBufSize
    if newSize < len(c.buf) {
      newSize = 2 * len(c.buf)
    }

    buf := make([]byte, newSize)
    copy(buf, c.buf[:c.offset])
    c.buf = buf
  }

  r, err := c.Conn.Read(c.buf[c.offset:])
  if err != nil {
    return 0, err
  }

  r += c.offset

  s := 0
  n := 0
  for i := range pkts {
    p := NewOpenflowAggregateStatsRequestWithBuf(c.buf)

    pSize := p.Size()
    if r < s+pSize {
      break
    }

    pkts[i] = p
    s += pSize
    n++
  }

  c.offset = r - s
  if c.offset < 0 {
    panic("Invalid value for offset")
  }

  c.buf = c.buf[s:]
  if c.offset < len(c.buf) {
    return n, nil
  }

  buf := make([]byte, packet.DefaultBufSize)
  copy(buf, c.buf[:c.offset])
  c.buf = buf
  return n, nil
}

func (this *OpenflowAggregateStatsRequest) Init() {
  this.OpenflowStatsRequest.Init()
  this.SetLength(uint16(this.minSize()))
  // Invariants.
  this.SetStatsType(uint16(2)) // stats_type
  this.SetType(uint8(16)) // type
  this.SetVersion(uint8(1)) // version
}

func (this OpenflowAggregateStatsRequest) Size() int {
  if len(this.Buf) < this.minSize() {
    return 0
  }

  size := int(this.Length())
  return size
}

func ConvertToOpenflowAggregateStatsRequest(p OpenflowStatsRequest) (OpenflowAggregateStatsRequest, error) {
  if !IsOpenflowAggregateStatsRequest(p) {
    return NewOpenflowAggregateStatsRequestWithBuf(nil), errors.New("Cannot convert to openflowv10.OpenflowAggregateStatsRequest")
  }

  return NewOpenflowAggregateStatsRequestWithBuf(p.Buf), nil
}

func IsOpenflowAggregateStatsRequest(p OpenflowStatsRequest) bool {
  return p.StatsType() == 2 && true
}

func (this *OpenflowAggregateStatsRequest) Match() OpenflowMatch {
  offset := this.MatchOffset()
  res := NewOpenflowMatchWithBuf(this.Buf[offset:])
  return res
}

func (this *OpenflowAggregateStatsRequest) SetMatch(m OpenflowMatch) {
  offset := this.MatchOffset()
  copy(this.Buf[offset:], m.Buf[:m.Size()]); offset += m.Size()
}

func (this *OpenflowAggregateStatsRequest) MatchOffset() int {
  offset := 12
  return offset
}


func (this *OpenflowAggregateStatsRequest) TableId() uint8 {
  offset := this.TableIdOffset()
  res := uint8(this.Buf[offset])
  return res
}

func (this *OpenflowAggregateStatsRequest) SetTableId(t uint8) {
  offset := this.TableIdOffset()
  this.Buf[offset] = byte(t); offset++
}

func (this *OpenflowAggregateStatsRequest) TableIdOffset() int {
  offset := 52
  return offset
}


func (this *OpenflowAggregateStatsRequest) Pad() uint8 {
  offset := this.PadOffset()
  res := uint8(this.Buf[offset])
  return res
}

func (this *OpenflowAggregateStatsRequest) SetPad(p uint8) {
  offset := this.PadOffset()
  this.Buf[offset] = byte(p); offset++
}

func (this *OpenflowAggregateStatsRequest) PadOffset() int {
  offset := 53
  return offset
}


func (this *OpenflowAggregateStatsRequest) OutPort() uint16 {
  offset := this.OutPortOffset()
  res := binary.BigEndian.Uint16(this.Buf[offset:])
  return res
}

func (this *OpenflowAggregateStatsRequest) SetOutPort(o uint16) {
  offset := this.OutPortOffset()
  binary.BigEndian.PutUint16(this.Buf[offset:], o); offset += 2
}

func (this *OpenflowAggregateStatsRequest) OutPortOffset() int {
  offset := 54
  return offset
}


func NewOpenflowAggregateStatsReplyWithBuf(b []byte) OpenflowAggregateStatsReply {
  return OpenflowAggregateStatsReply{OpenflowStatsReply{OpenflowHeaderV10{openflow.OpenflowHeader{packet.Packet{Buf: b}}}}}
}

func NewOpenflowAggregateStatsReply() OpenflowAggregateStatsReply {
  s := 36
  b := make([]byte, s)
  p := OpenflowAggregateStatsReply{OpenflowStatsReply{OpenflowHeaderV10{openflow.OpenflowHeader{packet.Packet{Buf: b}}}}}
  p.Init()
  return p
}

type OpenflowAggregateStatsReply struct {
  OpenflowStatsReply
}

func (this OpenflowAggregateStatsReply) minSize() int {
  return 36
}

type OpenflowAggregateStatsReplyConn struct {
  net.Conn
  buf []byte
  offset int
}

func NewOpenflowAggregateStatsReplyConn(c net.Conn) OpenflowAggregateStatsReplyConn {
  return OpenflowAggregateStatsReplyConn {
    Conn: c,
    buf: make([]byte, packet.DefaultBufSize),
  }
}

func (c *OpenflowAggregateStatsReplyConn) Write(pkts []OpenflowAggregateStatsReply) error {
  for _, p := range pkts {
    s := p.Size()
    b := p.Buffer()[:s]
    n := 0
    for s > 0 {
      var err error
      if n, err = c.Conn.Write(b); err != nil {
        return fmt.Errorf("Error in write: %v", err)
      }
      s -= n
    }
  }
  return nil
}

func (c *OpenflowAggregateStatsReplyConn) Read(pkts []OpenflowAggregateStatsReply) (int, error) {
  if len(c.buf) == c.offset {
    newSize := packet.DefaultBufSize
    if newSize < len(c.buf) {
      newSize = 2 * len(c.buf)
    }

    buf := make([]byte, newSize)
    copy(buf, c.buf[:c.offset])
    c.buf = buf
  }

  r, err := c.Conn.Read(c.buf[c.offset:])
  if err != nil {
    return 0, err
  }

  r += c.offset

  s := 0
  n := 0
  for i := range pkts {
    p := NewOpenflowAggregateStatsReplyWithBuf(c.buf)

    pSize := p.Size()
    if r < s+pSize {
      break
    }

    pkts[i] = p
    s += pSize
    n++
  }

  c.offset = r - s
  if c.offset < 0 {
    panic("Invalid value for offset")
  }

  c.buf = c.buf[s:]
  if c.offset < len(c.buf) {
    return n, nil
  }

  buf := make([]byte, packet.DefaultBufSize)
  copy(buf, c.buf[:c.offset])
  c.buf = buf
  return n, nil
}

func (this *OpenflowAggregateStatsReply) Init() {
  this.OpenflowStatsReply.Init()
  this.SetLength(uint16(this.minSize()))
  // Invariants.
  this.SetStatsType(uint16(2)) // stats_type
  this.SetType(uint8(17)) // type
  this.SetVersion(uint8(1)) // version
}

func (this OpenflowAggregateStatsReply) Size() int {
  if len(this.Buf) < this.minSize() {
    return 0
  }

  size := int(this.Length())
  return size
}

func ConvertToOpenflowAggregateStatsReply(p OpenflowStatsReply) (OpenflowAggregateStatsReply, error) {
  if !IsOpenflowAggregateStatsReply(p) {
    return NewOpenflowAggregateStatsReplyWithBuf(nil), errors.New("Cannot convert to openflowv10.OpenflowAggregateStatsReply")
  }

  return NewOpenflowAggregateStatsReplyWithBuf(p.Buf), nil
}

func IsOpenflowAggregateStatsReply(p OpenflowStatsReply) bool {
  return p.StatsType() == 2 && true
}

func (this *OpenflowAggregateStatsReply) PacketCount() uint64 {
  offset := this.PacketCountOffset()
  res := binary.BigEndian.Uint64(this.Buf[offset:])
  return res
}

func (this *OpenflowAggregateStatsReply) SetPacketCount(p uint64) {
  offset := this.PacketCountOffset()
  binary.BigEndian.PutUint64(this.Buf[offset:], p); offset += 8
}

func (this *OpenflowAggregateStatsReply) PacketCountOffset() int {
  offset := 12
  return offset
}


func (this *OpenflowAggregateStatsReply) ByteCount() uint64 {
  offset := this.ByteCountOffset()
  res := binary.BigEndian.Uint64(this.Buf[offset:])
  return res
}

func (this *OpenflowAggregateStatsReply) SetByteCount(b uint64) {
  offset := this.ByteCountOffset()
  binary.BigEndian.PutUint64(this.Buf[offset:], b); offset += 8
}

func (this *OpenflowAggregateStatsReply) ByteCountOffset() int {
  offset := 20
  return offset
}


func (this *OpenflowAggregateStatsReply) FlowCount() uint32 {
  offset := this.FlowCountOffset()
  res := binary.BigEndian.Uint32(this.Buf[offset:])
  return res
}

func (this *OpenflowAggregateStatsReply) SetFlowCount(f uint32) {
  offset := this.FlowCountOffset()
  binary.BigEndian.PutUint32(this.Buf[offset:], f); offset += 4
}

func (this *OpenflowAggregateStatsReply) FlowCountOffset() int {
  offset := 28
  return offset
}


func (this *OpenflowAggregateStatsReply) Pad() [4]uint8 {
  offset := this.PadOffset()
  packet_size := this.Size()
  size := packet_size - offset
  count := this.Size() - offset
  i := 0
  var res [4]uint8
  for size > 0 && count > 0 && packet_size > offset {
    elem := uint8(this.Buf[offset])
    if size < 1 {
      break
    }
    size -= 1
    count--
    res[i] = elem
    i++
  }
  return res
}

func (this *OpenflowAggregateStatsReply) SetPad(p [4]uint8) {
  offset := this.PadOffset()
  for _, e := range p {
    this.Buf[offset] = byte(e); offset++
  }
}

func (this *OpenflowAggregateStatsReply) PadOffset() int {
  offset := 32
  return offset
}


func NewOpenflowTableStatsWithBuf(b []byte) OpenflowTableStats {
  return OpenflowTableStats{OpenflowStatsReply{OpenflowHeaderV10{openflow.OpenflowHeader{packet.Packet{Buf: b}}}}}
}

func NewOpenflowTableStats() OpenflowTableStats {
  s := 76
  b := make([]byte, s)
  p := OpenflowTableStats{OpenflowStatsReply{OpenflowHeaderV10{openflow.OpenflowHeader{packet.Packet{Buf: b}}}}}
  p.Init()
  return p
}

type OpenflowTableStats struct {
  OpenflowStatsReply
}

func (this OpenflowTableStats) minSize() int {
  return 76
}

type OpenflowTableStatsConn struct {
  net.Conn
  buf []byte
  offset int
}

func NewOpenflowTableStatsConn(c net.Conn) OpenflowTableStatsConn {
  return OpenflowTableStatsConn {
    Conn: c,
    buf: make([]byte, packet.DefaultBufSize),
  }
}

func (c *OpenflowTableStatsConn) Write(pkts []OpenflowTableStats) error {
  for _, p := range pkts {
    s := p.Size()
    b := p.Buffer()[:s]
    n := 0
    for s > 0 {
      var err error
      if n, err = c.Conn.Write(b); err != nil {
        return fmt.Errorf("Error in write: %v", err)
      }
      s -= n
    }
  }
  return nil
}

func (c *OpenflowTableStatsConn) Read(pkts []OpenflowTableStats) (int, error) {
  if len(c.buf) == c.offset {
    newSize := packet.DefaultBufSize
    if newSize < len(c.buf) {
      newSize = 2 * len(c.buf)
    }

    buf := make([]byte, newSize)
    copy(buf, c.buf[:c.offset])
    c.buf = buf
  }

  r, err := c.Conn.Read(c.buf[c.offset:])
  if err != nil {
    return 0, err
  }

  r += c.offset

  s := 0
  n := 0
  for i := range pkts {
    p := NewOpenflowTableStatsWithBuf(c.buf)

    pSize := p.Size()
    if r < s+pSize {
      break
    }

    pkts[i] = p
    s += pSize
    n++
  }

  c.offset = r - s
  if c.offset < 0 {
    panic("Invalid value for offset")
  }

  c.buf = c.buf[s:]
  if c.offset < len(c.buf) {
    return n, nil
  }

  buf := make([]byte, packet.DefaultBufSize)
  copy(buf, c.buf[:c.offset])
  c.buf = buf
  return n, nil
}

func (this *OpenflowTableStats) Init() {
  this.OpenflowStatsReply.Init()
  this.SetLength(uint16(this.minSize()))
  // Invariants.
  this.SetStatsType(uint16(3)) // stats_type
  this.SetType(uint8(17)) // type
  this.SetVersion(uint8(1)) // version
}

func (this OpenflowTableStats) Size() int {
  if len(this.Buf) < this.minSize() {
    return 0
  }

  size := int(this.Length())
  return size
}

func ConvertToOpenflowTableStats(p OpenflowStatsReply) (OpenflowTableStats, error) {
  if !IsOpenflowTableStats(p) {
    return NewOpenflowTableStatsWithBuf(nil), errors.New("Cannot convert to openflowv10.OpenflowTableStats")
  }

  return NewOpenflowTableStatsWithBuf(p.Buf), nil
}

func IsOpenflowTableStats(p OpenflowStatsReply) bool {
  return p.StatsType() == 3 && true
}

func (this *OpenflowTableStats) TableId() uint8 {
  offset := this.TableIdOffset()
  res := uint8(this.Buf[offset])
  return res
}

func (this *OpenflowTableStats) SetTableId(t uint8) {
  offset := this.TableIdOffset()
  this.Buf[offset] = byte(t); offset++
}

func (this *OpenflowTableStats) TableIdOffset() int {
  offset := 12
  return offset
}


func (this *OpenflowTableStats) Pad() [3]uint8 {
  offset := this.PadOffset()
  packet_size := this.Size()
  size := packet_size - offset
  count := this.Size() - offset
  i := 0
  var res [3]uint8
  for size > 0 && count > 0 && packet_size > offset {
    elem := uint8(this.Buf[offset])
    if size < 1 {
      break
    }
    size -= 1
    count--
    res[i] = elem
    i++
  }
  return res
}

func (this *OpenflowTableStats) SetPad(p [3]uint8) {
  offset := this.PadOffset()
  for _, e := range p {
    this.Buf[offset] = byte(e); offset++
  }
}

func (this *OpenflowTableStats) PadOffset() int {
  offset := 13
  return offset
}


func (this *OpenflowTableStats) Name() [32]int8 {
  offset := this.NameOffset()
  packet_size := this.Size()
  size := packet_size - offset
  count := this.Size() - offset
  i := 0
  var res [32]int8
  for size > 0 && count > 0 && packet_size > offset {
    elem := int8(this.Buf[offset])
    if size < 1 {
      break
    }
    size -= 1
    count--
    res[i] = elem
    i++
  }
  return res
}

func (this *OpenflowTableStats) SetName(n [32]int8) {
  offset := this.NameOffset()
  for _, e := range n {
    this.Buf[offset] = byte(e); offset++
  }
}

func (this *OpenflowTableStats) NameOffset() int {
  offset := 16
  return offset
}


func (this *OpenflowTableStats) Wildcards() uint32 {
  offset := this.WildcardsOffset()
  res := binary.BigEndian.Uint32(this.Buf[offset:])
  return res
}

func (this *OpenflowTableStats) SetWildcards(w uint32) {
  offset := this.WildcardsOffset()
  binary.BigEndian.PutUint32(this.Buf[offset:], w); offset += 4
}

func (this *OpenflowTableStats) WildcardsOffset() int {
  offset := 48
  return offset
}


func (this *OpenflowTableStats) MaxEntries() uint32 {
  offset := this.MaxEntriesOffset()
  res := binary.BigEndian.Uint32(this.Buf[offset:])
  return res
}

func (this *OpenflowTableStats) SetMaxEntries(m uint32) {
  offset := this.MaxEntriesOffset()
  binary.BigEndian.PutUint32(this.Buf[offset:], m); offset += 4
}

func (this *OpenflowTableStats) MaxEntriesOffset() int {
  offset := 52
  return offset
}


func (this *OpenflowTableStats) ActiveCount() uint32 {
  offset := this.ActiveCountOffset()
  res := binary.BigEndian.Uint32(this.Buf[offset:])
  return res
}

func (this *OpenflowTableStats) SetActiveCount(a uint32) {
  offset := this.ActiveCountOffset()
  binary.BigEndian.PutUint32(this.Buf[offset:], a); offset += 4
}

func (this *OpenflowTableStats) ActiveCountOffset() int {
  offset := 56
  return offset
}


func (this *OpenflowTableStats) LookupCount() uint64 {
  offset := this.LookupCountOffset()
  res := binary.BigEndian.Uint64(this.Buf[offset:])
  return res
}

func (this *OpenflowTableStats) SetLookupCount(l uint64) {
  offset := this.LookupCountOffset()
  binary.BigEndian.PutUint64(this.Buf[offset:], l); offset += 8
}

func (this *OpenflowTableStats) LookupCountOffset() int {
  offset := 60
  return offset
}


func (this *OpenflowTableStats) MatchedCount() uint64 {
  offset := this.MatchedCountOffset()
  res := binary.BigEndian.Uint64(this.Buf[offset:])
  return res
}

func (this *OpenflowTableStats) SetMatchedCount(m uint64) {
  offset := this.MatchedCountOffset()
  binary.BigEndian.PutUint64(this.Buf[offset:], m); offset += 8
}

func (this *OpenflowTableStats) MatchedCountOffset() int {
  offset := 68
  return offset
}


func NewOpenflowPortStatsRequestWithBuf(b []byte) OpenflowPortStatsRequest {
  return OpenflowPortStatsRequest{OpenflowStatsRequest{OpenflowHeaderV10{openflow.OpenflowHeader{packet.Packet{Buf: b}}}}}
}

func NewOpenflowPortStatsRequest() OpenflowPortStatsRequest {
  s := 20
  b := make([]byte, s)
  p := OpenflowPortStatsRequest{OpenflowStatsRequest{OpenflowHeaderV10{openflow.OpenflowHeader{packet.Packet{Buf: b}}}}}
  p.Init()
  return p
}

type OpenflowPortStatsRequest struct {
  OpenflowStatsRequest
}

func (this OpenflowPortStatsRequest) minSize() int {
  return 20
}

type OpenflowPortStatsRequestConn struct {
  net.Conn
  buf []byte
  offset int
}

func NewOpenflowPortStatsRequestConn(c net.Conn) OpenflowPortStatsRequestConn {
  return OpenflowPortStatsRequestConn {
    Conn: c,
    buf: make([]byte, packet.DefaultBufSize),
  }
}

func (c *OpenflowPortStatsRequestConn) Write(pkts []OpenflowPortStatsRequest) error {
  for _, p := range pkts {
    s := p.Size()
    b := p.Buffer()[:s]
    n := 0
    for s > 0 {
      var err error
      if n, err = c.Conn.Write(b); err != nil {
        return fmt.Errorf("Error in write: %v", err)
      }
      s -= n
    }
  }
  return nil
}

func (c *OpenflowPortStatsRequestConn) Read(pkts []OpenflowPortStatsRequest) (int, error) {
  if len(c.buf) == c.offset {
    newSize := packet.DefaultBufSize
    if newSize < len(c.buf) {
      newSize = 2 * len(c.buf)
    }

    buf := make([]byte, newSize)
    copy(buf, c.buf[:c.offset])
    c.buf = buf
  }

  r, err := c.Conn.Read(c.buf[c.offset:])
  if err != nil {
    return 0, err
  }

  r += c.offset

  s := 0
  n := 0
  for i := range pkts {
    p := NewOpenflowPortStatsRequestWithBuf(c.buf)

    pSize := p.Size()
    if r < s+pSize {
      break
    }

    pkts[i] = p
    s += pSize
    n++
  }

  c.offset = r - s
  if c.offset < 0 {
    panic("Invalid value for offset")
  }

  c.buf = c.buf[s:]
  if c.offset < len(c.buf) {
    return n, nil
  }

  buf := make([]byte, packet.DefaultBufSize)
  copy(buf, c.buf[:c.offset])
  c.buf = buf
  return n, nil
}

func (this *OpenflowPortStatsRequest) Init() {
  this.OpenflowStatsRequest.Init()
  this.SetLength(uint16(this.minSize()))
  // Invariants.
  this.SetStatsType(uint16(4)) // stats_type
  this.SetType(uint8(16)) // type
  this.SetVersion(uint8(1)) // version
}

func (this OpenflowPortStatsRequest) Size() int {
  if len(this.Buf) < this.minSize() {
    return 0
  }

  size := int(this.Length())
  return size
}

func ConvertToOpenflowPortStatsRequest(p OpenflowStatsRequest) (OpenflowPortStatsRequest, error) {
  if !IsOpenflowPortStatsRequest(p) {
    return NewOpenflowPortStatsRequestWithBuf(nil), errors.New("Cannot convert to openflowv10.OpenflowPortStatsRequest")
  }

  return NewOpenflowPortStatsRequestWithBuf(p.Buf), nil
}

func IsOpenflowPortStatsRequest(p OpenflowStatsRequest) bool {
  return p.StatsType() == 4 && true
}

func (this *OpenflowPortStatsRequest) PortNo() uint16 {
  offset := this.PortNoOffset()
  res := binary.BigEndian.Uint16(this.Buf[offset:])
  return res
}

func (this *OpenflowPortStatsRequest) SetPortNo(p uint16) {
  offset := this.PortNoOffset()
  binary.BigEndian.PutUint16(this.Buf[offset:], p); offset += 2
}

func (this *OpenflowPortStatsRequest) PortNoOffset() int {
  offset := 12
  return offset
}


func (this *OpenflowPortStatsRequest) Pad() [6]uint8 {
  offset := this.PadOffset()
  packet_size := this.Size()
  size := packet_size - offset
  count := this.Size() - offset
  i := 0
  var res [6]uint8
  for size > 0 && count > 0 && packet_size > offset {
    elem := uint8(this.Buf[offset])
    if size < 1 {
      break
    }
    size -= 1
    count--
    res[i] = elem
    i++
  }
  return res
}

func (this *OpenflowPortStatsRequest) SetPad(p [6]uint8) {
  offset := this.PadOffset()
  for _, e := range p {
    this.Buf[offset] = byte(e); offset++
  }
}

func (this *OpenflowPortStatsRequest) PadOffset() int {
  offset := 14
  return offset
}


func NewOpenflowPortStatsWithBuf(b []byte) OpenflowPortStats {
  return OpenflowPortStats{OpenflowStatsReply{OpenflowHeaderV10{openflow.OpenflowHeader{packet.Packet{Buf: b}}}}}
}

func NewOpenflowPortStats() OpenflowPortStats {
  s := 116
  b := make([]byte, s)
  p := OpenflowPortStats{OpenflowStatsReply{OpenflowHeaderV10{openflow.OpenflowHeader{packet.Packet{Buf: b}}}}}
  p.Init()
  return p
}

type OpenflowPortStats struct {
  OpenflowStatsReply
}

func (this OpenflowPortStats) minSize() int {
  return 116
}

type OpenflowPortStatsConn struct {
  net.Conn
  buf []byte
  offset int
}

func NewOpenflowPortStatsConn(c net.Conn) OpenflowPortStatsConn {
  return OpenflowPortStatsConn {
    Conn: c,
    buf: make([]byte, packet.DefaultBufSize),
  }
}

func (c *OpenflowPortStatsConn) Write(pkts []OpenflowPortStats) error {
  for _, p := range pkts {
    s := p.Size()
    b := p.Buffer()[:s]
    n := 0
    for s > 0 {
      var err error
      if n, err = c.Conn.Write(b); err != nil {
        return fmt.Errorf("Error in write: %v", err)
      }
      s -= n
    }
  }
  return nil
}

func (c *OpenflowPortStatsConn) Read(pkts []OpenflowPortStats) (int, error) {
  if len(c.buf) == c.offset {
    newSize := packet.DefaultBufSize
    if newSize < len(c.buf) {
      newSize = 2 * len(c.buf)
    }

    buf := make([]byte, newSize)
    copy(buf, c.buf[:c.offset])
    c.buf = buf
  }

  r, err := c.Conn.Read(c.buf[c.offset:])
  if err != nil {
    return 0, err
  }

  r += c.offset

  s := 0
  n := 0
  for i := range pkts {
    p := NewOpenflowPortStatsWithBuf(c.buf)

    pSize := p.Size()
    if r < s+pSize {
      break
    }

    pkts[i] = p
    s += pSize
    n++
  }

  c.offset = r - s
  if c.offset < 0 {
    panic("Invalid value for offset")
  }

  c.buf = c.buf[s:]
  if c.offset < len(c.buf) {
    return n, nil
  }

  buf := make([]byte, packet.DefaultBufSize)
  copy(buf, c.buf[:c.offset])
  c.buf = buf
  return n, nil
}

func (this *OpenflowPortStats) Init() {
  this.OpenflowStatsReply.Init()
  this.SetLength(uint16(this.minSize()))
  // Invariants.
  this.SetStatsType(uint16(4)) // stats_type
  this.SetType(uint8(17)) // type
  this.SetVersion(uint8(1)) // version
}

func (this OpenflowPortStats) Size() int {
  if len(this.Buf) < this.minSize() {
    return 0
  }

  size := int(this.Length())
  return size
}

func ConvertToOpenflowPortStats(p OpenflowStatsReply) (OpenflowPortStats, error) {
  if !IsOpenflowPortStats(p) {
    return NewOpenflowPortStatsWithBuf(nil), errors.New("Cannot convert to openflowv10.OpenflowPortStats")
  }

  return NewOpenflowPortStatsWithBuf(p.Buf), nil
}

func IsOpenflowPortStats(p OpenflowStatsReply) bool {
  return p.StatsType() == 4 && true
}

func (this *OpenflowPortStats) PortNo() uint16 {
  offset := this.PortNoOffset()
  res := binary.BigEndian.Uint16(this.Buf[offset:])
  return res
}

func (this *OpenflowPortStats) SetPortNo(p uint16) {
  offset := this.PortNoOffset()
  binary.BigEndian.PutUint16(this.Buf[offset:], p); offset += 2
}

func (this *OpenflowPortStats) PortNoOffset() int {
  offset := 12
  return offset
}


func (this *OpenflowPortStats) Pad() [6]uint8 {
  offset := this.PadOffset()
  packet_size := this.Size()
  size := packet_size - offset
  count := this.Size() - offset
  i := 0
  var res [6]uint8
  for size > 0 && count > 0 && packet_size > offset {
    elem := uint8(this.Buf[offset])
    if size < 1 {
      break
    }
    size -= 1
    count--
    res[i] = elem
    i++
  }
  return res
}

func (this *OpenflowPortStats) SetPad(p [6]uint8) {
  offset := this.PadOffset()
  for _, e := range p {
    this.Buf[offset] = byte(e); offset++
  }
}

func (this *OpenflowPortStats) PadOffset() int {
  offset := 14
  return offset
}


func (this *OpenflowPortStats) RxPackets() uint64 {
  offset := this.RxPacketsOffset()
  res := binary.BigEndian.Uint64(this.Buf[offset:])
  return res
}

func (this *OpenflowPortStats) SetRxPackets(r uint64) {
  offset := this.RxPacketsOffset()
  binary.BigEndian.PutUint64(this.Buf[offset:], r); offset += 8
}

func (this *OpenflowPortStats) RxPacketsOffset() int {
  offset := 20
  return offset
}


func (this *OpenflowPortStats) TxPackets() uint64 {
  offset := this.TxPacketsOffset()
  res := binary.BigEndian.Uint64(this.Buf[offset:])
  return res
}

func (this *OpenflowPortStats) SetTxPackets(t uint64) {
  offset := this.TxPacketsOffset()
  binary.BigEndian.PutUint64(this.Buf[offset:], t); offset += 8
}

func (this *OpenflowPortStats) TxPacketsOffset() int {
  offset := 28
  return offset
}


func (this *OpenflowPortStats) RxBytes() uint64 {
  offset := this.RxBytesOffset()
  res := binary.BigEndian.Uint64(this.Buf[offset:])
  return res
}

func (this *OpenflowPortStats) SetRxBytes(r uint64) {
  offset := this.RxBytesOffset()
  binary.BigEndian.PutUint64(this.Buf[offset:], r); offset += 8
}

func (this *OpenflowPortStats) RxBytesOffset() int {
  offset := 36
  return offset
}


func (this *OpenflowPortStats) TxBytes() uint64 {
  offset := this.TxBytesOffset()
  res := binary.BigEndian.Uint64(this.Buf[offset:])
  return res
}

func (this *OpenflowPortStats) SetTxBytes(t uint64) {
  offset := this.TxBytesOffset()
  binary.BigEndian.PutUint64(this.Buf[offset:], t); offset += 8
}

func (this *OpenflowPortStats) TxBytesOffset() int {
  offset := 44
  return offset
}


func (this *OpenflowPortStats) RxDropped() uint64 {
  offset := this.RxDroppedOffset()
  res := binary.BigEndian.Uint64(this.Buf[offset:])
  return res
}

func (this *OpenflowPortStats) SetRxDropped(r uint64) {
  offset := this.RxDroppedOffset()
  binary.BigEndian.PutUint64(this.Buf[offset:], r); offset += 8
}

func (this *OpenflowPortStats) RxDroppedOffset() int {
  offset := 52
  return offset
}


func (this *OpenflowPortStats) TxDropped() uint64 {
  offset := this.TxDroppedOffset()
  res := binary.BigEndian.Uint64(this.Buf[offset:])
  return res
}

func (this *OpenflowPortStats) SetTxDropped(t uint64) {
  offset := this.TxDroppedOffset()
  binary.BigEndian.PutUint64(this.Buf[offset:], t); offset += 8
}

func (this *OpenflowPortStats) TxDroppedOffset() int {
  offset := 60
  return offset
}


func (this *OpenflowPortStats) RxErrors() uint64 {
  offset := this.RxErrorsOffset()
  res := binary.BigEndian.Uint64(this.Buf[offset:])
  return res
}

func (this *OpenflowPortStats) SetRxErrors(r uint64) {
  offset := this.RxErrorsOffset()
  binary.BigEndian.PutUint64(this.Buf[offset:], r); offset += 8
}

func (this *OpenflowPortStats) RxErrorsOffset() int {
  offset := 68
  return offset
}


func (this *OpenflowPortStats) TxErrors() uint64 {
  offset := this.TxErrorsOffset()
  res := binary.BigEndian.Uint64(this.Buf[offset:])
  return res
}

func (this *OpenflowPortStats) SetTxErrors(t uint64) {
  offset := this.TxErrorsOffset()
  binary.BigEndian.PutUint64(this.Buf[offset:], t); offset += 8
}

func (this *OpenflowPortStats) TxErrorsOffset() int {
  offset := 76
  return offset
}


func (this *OpenflowPortStats) RxFrameErr() uint64 {
  offset := this.RxFrameErrOffset()
  res := binary.BigEndian.Uint64(this.Buf[offset:])
  return res
}

func (this *OpenflowPortStats) SetRxFrameErr(r uint64) {
  offset := this.RxFrameErrOffset()
  binary.BigEndian.PutUint64(this.Buf[offset:], r); offset += 8
}

func (this *OpenflowPortStats) RxFrameErrOffset() int {
  offset := 84
  return offset
}


func (this *OpenflowPortStats) RxOverErr() uint64 {
  offset := this.RxOverErrOffset()
  res := binary.BigEndian.Uint64(this.Buf[offset:])
  return res
}

func (this *OpenflowPortStats) SetRxOverErr(r uint64) {
  offset := this.RxOverErrOffset()
  binary.BigEndian.PutUint64(this.Buf[offset:], r); offset += 8
}

func (this *OpenflowPortStats) RxOverErrOffset() int {
  offset := 92
  return offset
}


func (this *OpenflowPortStats) RxCrcErr() uint64 {
  offset := this.RxCrcErrOffset()
  res := binary.BigEndian.Uint64(this.Buf[offset:])
  return res
}

func (this *OpenflowPortStats) SetRxCrcErr(r uint64) {
  offset := this.RxCrcErrOffset()
  binary.BigEndian.PutUint64(this.Buf[offset:], r); offset += 8
}

func (this *OpenflowPortStats) RxCrcErrOffset() int {
  offset := 100
  return offset
}


func (this *OpenflowPortStats) Collisions() uint64 {
  offset := this.CollisionsOffset()
  res := binary.BigEndian.Uint64(this.Buf[offset:])
  return res
}

func (this *OpenflowPortStats) SetCollisions(c uint64) {
  offset := this.CollisionsOffset()
  binary.BigEndian.PutUint64(this.Buf[offset:], c); offset += 8
}

func (this *OpenflowPortStats) CollisionsOffset() int {
  offset := 108
  return offset
}


func NewOpenflowVendorHeaderWithBuf(b []byte) OpenflowVendorHeader {
  return OpenflowVendorHeader{OpenflowHeaderV10{openflow.OpenflowHeader{packet.Packet{Buf: b}}}}
}

func NewOpenflowVendorHeader() OpenflowVendorHeader {
  s := 12
  b := make([]byte, s)
  p := OpenflowVendorHeader{OpenflowHeaderV10{openflow.OpenflowHeader{packet.Packet{Buf: b}}}}
  p.Init()
  return p
}

type OpenflowVendorHeader struct {
  OpenflowHeaderV10
}

func (this OpenflowVendorHeader) minSize() int {
  return 12
}

type OpenflowVendorHeaderConn struct {
  net.Conn
  buf []byte
  offset int
}

func NewOpenflowVendorHeaderConn(c net.Conn) OpenflowVendorHeaderConn {
  return OpenflowVendorHeaderConn {
    Conn: c,
    buf: make([]byte, packet.DefaultBufSize),
  }
}

func (c *OpenflowVendorHeaderConn) Write(pkts []OpenflowVendorHeader) error {
  for _, p := range pkts {
    s := p.Size()
    b := p.Buffer()[:s]
    n := 0
    for s > 0 {
      var err error
      if n, err = c.Conn.Write(b); err != nil {
        return fmt.Errorf("Error in write: %v", err)
      }
      s -= n
    }
  }
  return nil
}

func (c *OpenflowVendorHeaderConn) Read(pkts []OpenflowVendorHeader) (int, error) {
  if len(c.buf) == c.offset {
    newSize := packet.DefaultBufSize
    if newSize < len(c.buf) {
      newSize = 2 * len(c.buf)
    }

    buf := make([]byte, newSize)
    copy(buf, c.buf[:c.offset])
    c.buf = buf
  }

  r, err := c.Conn.Read(c.buf[c.offset:])
  if err != nil {
    return 0, err
  }

  r += c.offset

  s := 0
  n := 0
  for i := range pkts {
    p := NewOpenflowVendorHeaderWithBuf(c.buf)

    pSize := p.Size()
    if r < s+pSize {
      break
    }

    pkts[i] = p
    s += pSize
    n++
  }

  c.offset = r - s
  if c.offset < 0 {
    panic("Invalid value for offset")
  }

  c.buf = c.buf[s:]
  if c.offset < len(c.buf) {
    return n, nil
  }

  buf := make([]byte, packet.DefaultBufSize)
  copy(buf, c.buf[:c.offset])
  c.buf = buf
  return n, nil
}

func (this *OpenflowVendorHeader) Init() {
  this.OpenflowHeaderV10.Init()
  this.SetLength(uint16(this.minSize()))
  // Invariants.
  this.SetType(uint8(4)) // type
  this.SetVersion(uint8(1)) // version
}

func (this OpenflowVendorHeader) Size() int {
  if len(this.Buf) < this.minSize() {
    return 0
  }

  size := int(this.Length())
  return size
}

func ConvertToOpenflowVendorHeader(p OpenflowHeaderV10) (OpenflowVendorHeader, error) {
  if !IsOpenflowVendorHeader(p) {
    return NewOpenflowVendorHeaderWithBuf(nil), errors.New("Cannot convert to openflowv10.OpenflowVendorHeader")
  }

  return NewOpenflowVendorHeaderWithBuf(p.Buf), nil
}

func IsOpenflowVendorHeader(p OpenflowHeaderV10) bool {
  return p.Type() == 4 && true
}

func (this *OpenflowVendorHeader) Vendor() uint32 {
  offset := this.VendorOffset()
  res := binary.BigEndian.Uint32(this.Buf[offset:])
  return res
}

func (this *OpenflowVendorHeader) SetVendor(v uint32) {
  offset := this.VendorOffset()
  binary.BigEndian.PutUint32(this.Buf[offset:], v); offset += 4
}

func (this *OpenflowVendorHeader) VendorOffset() int {
  offset := 8
  return offset
}


func NewOpenflowQueuePropHeaderWithBuf(b []byte) OpenflowQueuePropHeader {
  return OpenflowQueuePropHeader{packet.Packet{Buf: b}}
}

func NewOpenflowQueuePropHeader() OpenflowQueuePropHeader {
  s := 8
  b := make([]byte, s)
  p := OpenflowQueuePropHeader{packet.Packet{Buf: b}}
  p.Init()
  return p
}

type OpenflowQueuePropHeader struct {
  packet.Packet
}

func (this OpenflowQueuePropHeader) minSize() int {
  return 8
}

type OpenflowQueuePropHeaderConn struct {
  net.Conn
  buf []byte
  offset int
}

func NewOpenflowQueuePropHeaderConn(c net.Conn) OpenflowQueuePropHeaderConn {
  return OpenflowQueuePropHeaderConn {
    Conn: c,
    buf: make([]byte, packet.DefaultBufSize),
  }
}

func (c *OpenflowQueuePropHeaderConn) Write(pkts []OpenflowQueuePropHeader) error {
  for _, p := range pkts {
    s := p.Size()
    b := p.Buffer()[:s]
    n := 0
    for s > 0 {
      var err error
      if n, err = c.Conn.Write(b); err != nil {
        return fmt.Errorf("Error in write: %v", err)
      }
      s -= n
    }
  }
  return nil
}

func (c *OpenflowQueuePropHeaderConn) Read(pkts []OpenflowQueuePropHeader) (int, error) {
  if len(c.buf) == c.offset {
    newSize := packet.DefaultBufSize
    if newSize < len(c.buf) {
      newSize = 2 * len(c.buf)
    }

    buf := make([]byte, newSize)
    copy(buf, c.buf[:c.offset])
    c.buf = buf
  }

  r, err := c.Conn.Read(c.buf[c.offset:])
  if err != nil {
    return 0, err
  }

  r += c.offset

  s := 0
  n := 0
  for i := range pkts {
    p := NewOpenflowQueuePropHeaderWithBuf(c.buf)

    pSize := p.Size()
    if r < s+pSize {
      break
    }

    pkts[i] = p
    s += pSize
    n++
  }

  c.offset = r - s
  if c.offset < 0 {
    panic("Invalid value for offset")
  }

  c.buf = c.buf[s:]
  if c.offset < len(c.buf) {
    return n, nil
  }

  buf := make([]byte, packet.DefaultBufSize)
  copy(buf, c.buf[:c.offset])
  c.buf = buf
  return n, nil
}

func (this *OpenflowQueuePropHeader) Init() {
  this.SetLen(uint16(this.minSize()))
  // Invariants.
}

func (this OpenflowQueuePropHeader) Size() int {
  if len(this.Buf) < this.minSize() {
    return 0
  }

  size := int(this.Len())
  return size
}

func ConvertToOpenflowQueuePropHeader(p packet.Packet) (OpenflowQueuePropHeader, error) {
  if !IsOpenflowQueuePropHeader(p) {
    return NewOpenflowQueuePropHeaderWithBuf(nil), errors.New("Cannot convert to openflowv10.OpenflowQueuePropHeader")
  }

  return NewOpenflowQueuePropHeaderWithBuf(p.Buf), nil
}

func IsOpenflowQueuePropHeader(p packet.Packet) bool {
  return true
}

func (this *OpenflowQueuePropHeader) Property() uint16 {
  offset := this.PropertyOffset()
  res := binary.BigEndian.Uint16(this.Buf[offset:])
  return res
}

func (this *OpenflowQueuePropHeader) SetProperty(p uint16) {
  offset := this.PropertyOffset()
  binary.BigEndian.PutUint16(this.Buf[offset:], p); offset += 2
}

func (this *OpenflowQueuePropHeader) PropertyOffset() int {
  offset := 0
  return offset
}


func (this *OpenflowQueuePropHeader) Len() uint16 {
  offset := this.LenOffset()
  res := binary.BigEndian.Uint16(this.Buf[offset:])
  return res
}

func (this *OpenflowQueuePropHeader) SetLen(l uint16) {
  offset := this.LenOffset()
  binary.BigEndian.PutUint16(this.Buf[offset:], l); offset += 2
}

func (this *OpenflowQueuePropHeader) LenOffset() int {
  offset := 2
  return offset
}


func (this *OpenflowQueuePropHeader) Pad() [4]uint8 {
  offset := this.PadOffset()
  packet_size := this.Size()
  size := packet_size - offset
  count := this.Size() - offset
  i := 0
  var res [4]uint8
  for size > 0 && count > 0 && packet_size > offset {
    elem := uint8(this.Buf[offset])
    if size < 1 {
      break
    }
    size -= 1
    count--
    res[i] = elem
    i++
  }
  return res
}

func (this *OpenflowQueuePropHeader) SetPad(p [4]uint8) {
  offset := this.PadOffset()
  for _, e := range p {
    this.Buf[offset] = byte(e); offset++
  }
}

func (this *OpenflowQueuePropHeader) PadOffset() int {
  offset := 4
  return offset
}


func NewOpenflowQueuePropMinRateWithBuf(b []byte) OpenflowQueuePropMinRate {
  return OpenflowQueuePropMinRate{OpenflowQueuePropHeader{packet.Packet{Buf: b}}}
}

func NewOpenflowQueuePropMinRate() OpenflowQueuePropMinRate {
  s := 16
  b := make([]byte, s)
  p := OpenflowQueuePropMinRate{OpenflowQueuePropHeader{packet.Packet{Buf: b}}}
  p.Init()
  return p
}

type OpenflowQueuePropMinRate struct {
  OpenflowQueuePropHeader
}

func (this OpenflowQueuePropMinRate) minSize() int {
  return 16
}

type OpenflowQueuePropMinRateConn struct {
  net.Conn
  buf []byte
  offset int
}

func NewOpenflowQueuePropMinRateConn(c net.Conn) OpenflowQueuePropMinRateConn {
  return OpenflowQueuePropMinRateConn {
    Conn: c,
    buf: make([]byte, packet.DefaultBufSize),
  }
}

func (c *OpenflowQueuePropMinRateConn) Write(pkts []OpenflowQueuePropMinRate) error {
  for _, p := range pkts {
    s := p.Size()
    b := p.Buffer()[:s]
    n := 0
    for s > 0 {
      var err error
      if n, err = c.Conn.Write(b); err != nil {
        return fmt.Errorf("Error in write: %v", err)
      }
      s -= n
    }
  }
  return nil
}

func (c *OpenflowQueuePropMinRateConn) Read(pkts []OpenflowQueuePropMinRate) (int, error) {
  if len(c.buf) == c.offset {
    newSize := packet.DefaultBufSize
    if newSize < len(c.buf) {
      newSize = 2 * len(c.buf)
    }

    buf := make([]byte, newSize)
    copy(buf, c.buf[:c.offset])
    c.buf = buf
  }

  r, err := c.Conn.Read(c.buf[c.offset:])
  if err != nil {
    return 0, err
  }

  r += c.offset

  s := 0
  n := 0
  for i := range pkts {
    p := NewOpenflowQueuePropMinRateWithBuf(c.buf)

    pSize := p.Size()
    if r < s+pSize {
      break
    }

    pkts[i] = p
    s += pSize
    n++
  }

  c.offset = r - s
  if c.offset < 0 {
    panic("Invalid value for offset")
  }

  c.buf = c.buf[s:]
  if c.offset < len(c.buf) {
    return n, nil
  }

  buf := make([]byte, packet.DefaultBufSize)
  copy(buf, c.buf[:c.offset])
  c.buf = buf
  return n, nil
}

func (this *OpenflowQueuePropMinRate) Init() {
  this.OpenflowQueuePropHeader.Init()
  this.SetLen(uint16(this.minSize()))
  // Invariants.
  this.SetProperty(uint16(1)) // property
}

func (this OpenflowQueuePropMinRate) Size() int {
  if len(this.Buf) < this.minSize() {
    return 0
  }

  size := int(this.Len())
  return size
}

func ConvertToOpenflowQueuePropMinRate(p OpenflowQueuePropHeader) (OpenflowQueuePropMinRate, error) {
  if !IsOpenflowQueuePropMinRate(p) {
    return NewOpenflowQueuePropMinRateWithBuf(nil), errors.New("Cannot convert to openflowv10.OpenflowQueuePropMinRate")
  }

  return NewOpenflowQueuePropMinRateWithBuf(p.Buf), nil
}

func IsOpenflowQueuePropMinRate(p OpenflowQueuePropHeader) bool {
  return p.Property() == 1 && true
}

func (this *OpenflowQueuePropMinRate) Rate() uint16 {
  offset := this.RateOffset()
  res := binary.BigEndian.Uint16(this.Buf[offset:])
  return res
}

func (this *OpenflowQueuePropMinRate) SetRate(r uint16) {
  offset := this.RateOffset()
  binary.BigEndian.PutUint16(this.Buf[offset:], r); offset += 2
}

func (this *OpenflowQueuePropMinRate) RateOffset() int {
  offset := 8
  return offset
}


func (this *OpenflowQueuePropMinRate) Pad() [6]uint8 {
  offset := this.PadOffset()
  packet_size := this.Size()
  size := packet_size - offset
  count := this.Size() - offset
  i := 0
  var res [6]uint8
  for size > 0 && count > 0 && packet_size > offset {
    elem := uint8(this.Buf[offset])
    if size < 1 {
      break
    }
    size -= 1
    count--
    res[i] = elem
    i++
  }
  return res
}

func (this *OpenflowQueuePropMinRate) SetPad(p [6]uint8) {
  offset := this.PadOffset()
  for _, e := range p {
    this.Buf[offset] = byte(e); offset++
  }
}

func (this *OpenflowQueuePropMinRate) PadOffset() int {
  offset := 10
  return offset
}


func NewOpenflowPacketQueueWithBuf(b []byte) OpenflowPacketQueue {
  return OpenflowPacketQueue{packet.Packet{Buf: b}}
}

func NewOpenflowPacketQueue() OpenflowPacketQueue {
  s := 8
  b := make([]byte, s)
  p := OpenflowPacketQueue{packet.Packet{Buf: b}}
  p.Init()
  return p
}

type OpenflowPacketQueue struct {
  packet.Packet
}

func (this OpenflowPacketQueue) minSize() int {
  return 8
}

type OpenflowPacketQueueConn struct {
  net.Conn
  buf []byte
  offset int
}

func NewOpenflowPacketQueueConn(c net.Conn) OpenflowPacketQueueConn {
  return OpenflowPacketQueueConn {
    Conn: c,
    buf: make([]byte, packet.DefaultBufSize),
  }
}

func (c *OpenflowPacketQueueConn) Write(pkts []OpenflowPacketQueue) error {
  for _, p := range pkts {
    s := p.Size()
    b := p.Buffer()[:s]
    n := 0
    for s > 0 {
      var err error
      if n, err = c.Conn.Write(b); err != nil {
        return fmt.Errorf("Error in write: %v", err)
      }
      s -= n
    }
  }
  return nil
}

func (c *OpenflowPacketQueueConn) Read(pkts []OpenflowPacketQueue) (int, error) {
  if len(c.buf) == c.offset {
    newSize := packet.DefaultBufSize
    if newSize < len(c.buf) {
      newSize = 2 * len(c.buf)
    }

    buf := make([]byte, newSize)
    copy(buf, c.buf[:c.offset])
    c.buf = buf
  }

  r, err := c.Conn.Read(c.buf[c.offset:])
  if err != nil {
    return 0, err
  }

  r += c.offset

  s := 0
  n := 0
  for i := range pkts {
    p := NewOpenflowPacketQueueWithBuf(c.buf)

    pSize := p.Size()
    if r < s+pSize {
      break
    }

    pkts[i] = p
    s += pSize
    n++
  }

  c.offset = r - s
  if c.offset < 0 {
    panic("Invalid value for offset")
  }

  c.buf = c.buf[s:]
  if c.offset < len(c.buf) {
    return n, nil
  }

  buf := make([]byte, packet.DefaultBufSize)
  copy(buf, c.buf[:c.offset])
  c.buf = buf
  return n, nil
}

func (this *OpenflowPacketQueue) Init() {
  this.SetLen(uint16(this.minSize()))
  // Invariants.
}

func (this OpenflowPacketQueue) Size() int {
  if len(this.Buf) < this.minSize() {
    return 0
  }

  size := int(this.Len())
  return size
}

func ConvertToOpenflowPacketQueue(p packet.Packet) (OpenflowPacketQueue, error) {
  if !IsOpenflowPacketQueue(p) {
    return NewOpenflowPacketQueueWithBuf(nil), errors.New("Cannot convert to openflowv10.OpenflowPacketQueue")
  }

  return NewOpenflowPacketQueueWithBuf(p.Buf), nil
}

func IsOpenflowPacketQueue(p packet.Packet) bool {
  return true
}

func (this *OpenflowPacketQueue) QueueId() uint32 {
  offset := this.QueueIdOffset()
  res := binary.BigEndian.Uint32(this.Buf[offset:])
  return res
}

func (this *OpenflowPacketQueue) SetQueueId(q uint32) {
  offset := this.QueueIdOffset()
  binary.BigEndian.PutUint32(this.Buf[offset:], q); offset += 4
}

func (this *OpenflowPacketQueue) QueueIdOffset() int {
  offset := 0
  return offset
}


func (this *OpenflowPacketQueue) Len() uint16 {
  offset := this.LenOffset()
  res := binary.BigEndian.Uint16(this.Buf[offset:])
  return res
}

func (this *OpenflowPacketQueue) SetLen(l uint16) {
  offset := this.LenOffset()
  binary.BigEndian.PutUint16(this.Buf[offset:], l); offset += 2
}

func (this *OpenflowPacketQueue) LenOffset() int {
  offset := 4
  return offset
}


func (this *OpenflowPacketQueue) Pad() [2]uint8 {
  offset := this.PadOffset()
  packet_size := this.Size()
  size := packet_size - offset
  count := this.Size() - offset
  i := 0
  var res [2]uint8
  for size > 0 && count > 0 && packet_size > offset {
    elem := uint8(this.Buf[offset])
    if size < 1 {
      break
    }
    size -= 1
    count--
    res[i] = elem
    i++
  }
  return res
}

func (this *OpenflowPacketQueue) SetPad(p [2]uint8) {
  offset := this.PadOffset()
  for _, e := range p {
    this.Buf[offset] = byte(e); offset++
  }
}

func (this *OpenflowPacketQueue) PadOffset() int {
  offset := 6
  return offset
}


func (this *OpenflowPacketQueue) Properties() []OpenflowQueuePropHeader {
  offset := this.PropertiesOffset()
  packet_size := this.Size()
  size := packet_size - offset
  count := this.Size() - offset
  var res []OpenflowQueuePropHeader
  for size > 0 && count > 0 && packet_size > offset {
    elem := NewOpenflowQueuePropHeaderWithBuf(this.Buf[offset:])
    if elem.Size() > size {
      break
    }
    size -= elem.Size()
    count--
    res = append(res, elem)
  }
  return res
}

func (this *OpenflowPacketQueue) AddProperties(p OpenflowQueuePropHeader) {
  offset := this.PropertiesOffset()
  offset += this.PropertiesSize()
  size := p.Size()
  this.OpenGap(offset, size)
  this.SetLen(uint16(this.Size() + size))
  copy(this.Buf[offset:], p.Buf[:p.Size()]); offset += p.Size()
}

func (this *OpenflowPacketQueue) PropertiesOffset() int {
  offset := 8
  return offset
}

func (this *OpenflowPacketQueue) PropertiesSize() int {
  offset := this.PropertiesOffset()
  return this.Size() - offset
}

func NewOpenflowQueueGetConfigRequestWithBuf(b []byte) OpenflowQueueGetConfigRequest {
  return OpenflowQueueGetConfigRequest{OpenflowHeaderV10{openflow.OpenflowHeader{packet.Packet{Buf: b}}}}
}

func NewOpenflowQueueGetConfigRequest() OpenflowQueueGetConfigRequest {
  s := 10
  b := make([]byte, s)
  p := OpenflowQueueGetConfigRequest{OpenflowHeaderV10{openflow.OpenflowHeader{packet.Packet{Buf: b}}}}
  p.Init()
  return p
}

type OpenflowQueueGetConfigRequest struct {
  OpenflowHeaderV10
}

func (this OpenflowQueueGetConfigRequest) minSize() int {
  return 10
}

type OpenflowQueueGetConfigRequestConn struct {
  net.Conn
  buf []byte
  offset int
}

func NewOpenflowQueueGetConfigRequestConn(c net.Conn) OpenflowQueueGetConfigRequestConn {
  return OpenflowQueueGetConfigRequestConn {
    Conn: c,
    buf: make([]byte, packet.DefaultBufSize),
  }
}

func (c *OpenflowQueueGetConfigRequestConn) Write(pkts []OpenflowQueueGetConfigRequest) error {
  for _, p := range pkts {
    s := p.Size()
    b := p.Buffer()[:s]
    n := 0
    for s > 0 {
      var err error
      if n, err = c.Conn.Write(b); err != nil {
        return fmt.Errorf("Error in write: %v", err)
      }
      s -= n
    }
  }
  return nil
}

func (c *OpenflowQueueGetConfigRequestConn) Read(pkts []OpenflowQueueGetConfigRequest) (int, error) {
  if len(c.buf) == c.offset {
    newSize := packet.DefaultBufSize
    if newSize < len(c.buf) {
      newSize = 2 * len(c.buf)
    }

    buf := make([]byte, newSize)
    copy(buf, c.buf[:c.offset])
    c.buf = buf
  }

  r, err := c.Conn.Read(c.buf[c.offset:])
  if err != nil {
    return 0, err
  }

  r += c.offset

  s := 0
  n := 0
  for i := range pkts {
    p := NewOpenflowQueueGetConfigRequestWithBuf(c.buf)

    pSize := p.Size()
    if r < s+pSize {
      break
    }

    pkts[i] = p
    s += pSize
    n++
  }

  c.offset = r - s
  if c.offset < 0 {
    panic("Invalid value for offset")
  }

  c.buf = c.buf[s:]
  if c.offset < len(c.buf) {
    return n, nil
  }

  buf := make([]byte, packet.DefaultBufSize)
  copy(buf, c.buf[:c.offset])
  c.buf = buf
  return n, nil
}

func (this *OpenflowQueueGetConfigRequest) Init() {
  this.OpenflowHeaderV10.Init()
  this.SetLength(uint16(this.minSize()))
  // Invariants.
  this.SetType(uint8(21)) // type
  this.SetVersion(uint8(1)) // version
}

func (this OpenflowQueueGetConfigRequest) Size() int {
  if len(this.Buf) < this.minSize() {
    return 0
  }

  size := int(this.Length())
  return size
}

func ConvertToOpenflowQueueGetConfigRequest(p OpenflowHeaderV10) (OpenflowQueueGetConfigRequest, error) {
  if !IsOpenflowQueueGetConfigRequest(p) {
    return NewOpenflowQueueGetConfigRequestWithBuf(nil), errors.New("Cannot convert to openflowv10.OpenflowQueueGetConfigRequest")
  }

  return NewOpenflowQueueGetConfigRequestWithBuf(p.Buf), nil
}

func IsOpenflowQueueGetConfigRequest(p OpenflowHeaderV10) bool {
  return p.Type() == 21 && true
}

func (this *OpenflowQueueGetConfigRequest) Port() uint16 {
  offset := this.PortOffset()
  res := binary.BigEndian.Uint16(this.Buf[offset:])
  return res
}

func (this *OpenflowQueueGetConfigRequest) SetPort(p uint16) {
  offset := this.PortOffset()
  binary.BigEndian.PutUint16(this.Buf[offset:], p); offset += 2
}

func (this *OpenflowQueueGetConfigRequest) PortOffset() int {
  offset := 8
  return offset
}


func (this *OpenflowQueueGetConfigRequest) Pad() []uint8 {
  offset := this.PadOffset()
  packet_size := this.Size()
  size := packet_size - offset
  count := this.Size() - offset
  i := 0
  var res []uint8
  for size > 0 && count > 0 && packet_size > offset {
    elem := uint8(this.Buf[offset])
    if size < 1 {
      break
    }
    size -= 1
    count--
    res[i] = elem
    i++
  }
  return res
}

func (this *OpenflowQueueGetConfigRequest) AddPad(p uint8) {
  offset := this.PadOffset()
  offset += 1
  size := 1
  this.OpenGap(offset, size)
  this.SetLength(uint16(this.Size() + size))
  this.Buf[offset] = byte(p); offset++
}

func (this *OpenflowQueueGetConfigRequest) PadOffset() int {
  offset := 10
  return offset
}

func (this *OpenflowQueueGetConfigRequest) PadSize() int {
  offset := this.PadOffset()
  return this.Size() - offset
}

func NewOpenflowQueueGetConfigReplyWithBuf(b []byte) OpenflowQueueGetConfigReply {
  return OpenflowQueueGetConfigReply{OpenflowHeaderV10{openflow.OpenflowHeader{packet.Packet{Buf: b}}}}
}

func NewOpenflowQueueGetConfigReply() OpenflowQueueGetConfigReply {
  s := 16
  b := make([]byte, s)
  p := OpenflowQueueGetConfigReply{OpenflowHeaderV10{openflow.OpenflowHeader{packet.Packet{Buf: b}}}}
  p.Init()
  return p
}

type OpenflowQueueGetConfigReply struct {
  OpenflowHeaderV10
}

func (this OpenflowQueueGetConfigReply) minSize() int {
  return 16
}

type OpenflowQueueGetConfigReplyConn struct {
  net.Conn
  buf []byte
  offset int
}

func NewOpenflowQueueGetConfigReplyConn(c net.Conn) OpenflowQueueGetConfigReplyConn {
  return OpenflowQueueGetConfigReplyConn {
    Conn: c,
    buf: make([]byte, packet.DefaultBufSize),
  }
}

func (c *OpenflowQueueGetConfigReplyConn) Write(pkts []OpenflowQueueGetConfigReply) error {
  for _, p := range pkts {
    s := p.Size()
    b := p.Buffer()[:s]
    n := 0
    for s > 0 {
      var err error
      if n, err = c.Conn.Write(b); err != nil {
        return fmt.Errorf("Error in write: %v", err)
      }
      s -= n
    }
  }
  return nil
}

func (c *OpenflowQueueGetConfigReplyConn) Read(pkts []OpenflowQueueGetConfigReply) (int, error) {
  if len(c.buf) == c.offset {
    newSize := packet.DefaultBufSize
    if newSize < len(c.buf) {
      newSize = 2 * len(c.buf)
    }

    buf := make([]byte, newSize)
    copy(buf, c.buf[:c.offset])
    c.buf = buf
  }

  r, err := c.Conn.Read(c.buf[c.offset:])
  if err != nil {
    return 0, err
  }

  r += c.offset

  s := 0
  n := 0
  for i := range pkts {
    p := NewOpenflowQueueGetConfigReplyWithBuf(c.buf)

    pSize := p.Size()
    if r < s+pSize {
      break
    }

    pkts[i] = p
    s += pSize
    n++
  }

  c.offset = r - s
  if c.offset < 0 {
    panic("Invalid value for offset")
  }

  c.buf = c.buf[s:]
  if c.offset < len(c.buf) {
    return n, nil
  }

  buf := make([]byte, packet.DefaultBufSize)
  copy(buf, c.buf[:c.offset])
  c.buf = buf
  return n, nil
}

func (this *OpenflowQueueGetConfigReply) Init() {
  this.OpenflowHeaderV10.Init()
  this.SetLength(uint16(this.minSize()))
  // Invariants.
  this.SetType(uint8(21)) // type
  this.SetVersion(uint8(1)) // version
}

func (this OpenflowQueueGetConfigReply) Size() int {
  if len(this.Buf) < this.minSize() {
    return 0
  }

  size := int(this.Length())
  return size
}

func ConvertToOpenflowQueueGetConfigReply(p OpenflowHeaderV10) (OpenflowQueueGetConfigReply, error) {
  if !IsOpenflowQueueGetConfigReply(p) {
    return NewOpenflowQueueGetConfigReplyWithBuf(nil), errors.New("Cannot convert to openflowv10.OpenflowQueueGetConfigReply")
  }

  return NewOpenflowQueueGetConfigReplyWithBuf(p.Buf), nil
}

func IsOpenflowQueueGetConfigReply(p OpenflowHeaderV10) bool {
  return p.Type() == 21 && true
}

func (this *OpenflowQueueGetConfigReply) Port() uint16 {
  offset := this.PortOffset()
  res := binary.BigEndian.Uint16(this.Buf[offset:])
  return res
}

func (this *OpenflowQueueGetConfigReply) SetPort(p uint16) {
  offset := this.PortOffset()
  binary.BigEndian.PutUint16(this.Buf[offset:], p); offset += 2
}

func (this *OpenflowQueueGetConfigReply) PortOffset() int {
  offset := 8
  return offset
}


func (this *OpenflowQueueGetConfigReply) Pad() [6]uint8 {
  offset := this.PadOffset()
  packet_size := this.Size()
  size := packet_size - offset
  count := this.Size() - offset
  i := 0
  var res [6]uint8
  for size > 0 && count > 0 && packet_size > offset {
    elem := uint8(this.Buf[offset])
    if size < 1 {
      break
    }
    size -= 1
    count--
    res[i] = elem
    i++
  }
  return res
}

func (this *OpenflowQueueGetConfigReply) SetPad(p [6]uint8) {
  offset := this.PadOffset()
  for _, e := range p {
    this.Buf[offset] = byte(e); offset++
  }
}

func (this *OpenflowQueueGetConfigReply) PadOffset() int {
  offset := 10
  return offset
}


func (this *OpenflowQueueGetConfigReply) Queues() []OpenflowPacketQueue {
  offset := this.QueuesOffset()
  packet_size := this.Size()
  size := packet_size - offset
  count := this.Size() - offset
  var res []OpenflowPacketQueue
  for size > 0 && count > 0 && packet_size > offset {
    elem := NewOpenflowPacketQueueWithBuf(this.Buf[offset:])
    if elem.Size() > size {
      break
    }
    size -= elem.Size()
    count--
    res = append(res, elem)
  }
  return res
}

func (this *OpenflowQueueGetConfigReply) AddQueues(q OpenflowPacketQueue) {
  offset := this.QueuesOffset()
  offset += this.QueuesSize()
  size := q.Size()
  this.OpenGap(offset, size)
  this.SetLength(uint16(this.Size() + size))
  copy(this.Buf[offset:], q.Buf[:q.Size()]); offset += q.Size()
}

func (this *OpenflowQueueGetConfigReply) QueuesOffset() int {
  offset := 16
  return offset
}

func (this *OpenflowQueueGetConfigReply) QueuesSize() int {
  offset := this.QueuesOffset()
  return this.Size() - offset
}

func NewOpenflowActionEnqueueWithBuf(b []byte) OpenflowActionEnqueue {
  return OpenflowActionEnqueue{OpenflowActionHeader{packet.Packet{Buf: b}}}
}

func NewOpenflowActionEnqueue() OpenflowActionEnqueue {
  s := 16
  b := make([]byte, s)
  p := OpenflowActionEnqueue{OpenflowActionHeader{packet.Packet{Buf: b}}}
  p.Init()
  return p
}

type OpenflowActionEnqueue struct {
  OpenflowActionHeader
}

func (this OpenflowActionEnqueue) minSize() int {
  return 16
}

type OpenflowActionEnqueueConn struct {
  net.Conn
  buf []byte
  offset int
}

func NewOpenflowActionEnqueueConn(c net.Conn) OpenflowActionEnqueueConn {
  return OpenflowActionEnqueueConn {
    Conn: c,
    buf: make([]byte, packet.DefaultBufSize),
  }
}

func (c *OpenflowActionEnqueueConn) Write(pkts []OpenflowActionEnqueue) error {
  for _, p := range pkts {
    s := p.Size()
    b := p.Buffer()[:s]
    n := 0
    for s > 0 {
      var err error
      if n, err = c.Conn.Write(b); err != nil {
        return fmt.Errorf("Error in write: %v", err)
      }
      s -= n
    }
  }
  return nil
}

func (c *OpenflowActionEnqueueConn) Read(pkts []OpenflowActionEnqueue) (int, error) {
  if len(c.buf) == c.offset {
    newSize := packet.DefaultBufSize
    if newSize < len(c.buf) {
      newSize = 2 * len(c.buf)
    }

    buf := make([]byte, newSize)
    copy(buf, c.buf[:c.offset])
    c.buf = buf
  }

  r, err := c.Conn.Read(c.buf[c.offset:])
  if err != nil {
    return 0, err
  }

  r += c.offset

  s := 0
  n := 0
  for i := range pkts {
    p := NewOpenflowActionEnqueueWithBuf(c.buf)

    pSize := p.Size()
    if r < s+pSize {
      break
    }

    pkts[i] = p
    s += pSize
    n++
  }

  c.offset = r - s
  if c.offset < 0 {
    panic("Invalid value for offset")
  }

  c.buf = c.buf[s:]
  if c.offset < len(c.buf) {
    return n, nil
  }

  buf := make([]byte, packet.DefaultBufSize)
  copy(buf, c.buf[:c.offset])
  c.buf = buf
  return n, nil
}

func (this *OpenflowActionEnqueue) Init() {
  this.OpenflowActionHeader.Init()
  this.SetLen(uint16(this.minSize()))
  // Invariants.
  this.SetType(uint16(11)) // type
}

func (this OpenflowActionEnqueue) Size() int {
  if len(this.Buf) < this.minSize() {
    return 0
  }

  size := int(this.Len())
  return size
}

func ConvertToOpenflowActionEnqueue(p OpenflowActionHeader) (OpenflowActionEnqueue, error) {
  if !IsOpenflowActionEnqueue(p) {
    return NewOpenflowActionEnqueueWithBuf(nil), errors.New("Cannot convert to openflowv10.OpenflowActionEnqueue")
  }

  return NewOpenflowActionEnqueueWithBuf(p.Buf), nil
}

func IsOpenflowActionEnqueue(p OpenflowActionHeader) bool {
  return p.Type() == 11 && true
}

func (this *OpenflowActionEnqueue) Port() uint16 {
  offset := this.PortOffset()
  res := binary.BigEndian.Uint16(this.Buf[offset:])
  return res
}

func (this *OpenflowActionEnqueue) SetPort(p uint16) {
  offset := this.PortOffset()
  binary.BigEndian.PutUint16(this.Buf[offset:], p); offset += 2
}

func (this *OpenflowActionEnqueue) PortOffset() int {
  offset := 4
  return offset
}


func (this *OpenflowActionEnqueue) Pad() [6]uint8 {
  offset := this.PadOffset()
  packet_size := this.Size()
  size := packet_size - offset
  count := this.Size() - offset
  i := 0
  var res [6]uint8
  for size > 0 && count > 0 && packet_size > offset {
    elem := uint8(this.Buf[offset])
    if size < 1 {
      break
    }
    size -= 1
    count--
    res[i] = elem
    i++
  }
  return res
}

func (this *OpenflowActionEnqueue) SetPad(p [6]uint8) {
  offset := this.PadOffset()
  for _, e := range p {
    this.Buf[offset] = byte(e); offset++
  }
}

func (this *OpenflowActionEnqueue) PadOffset() int {
  offset := 6
  return offset
}


func (this *OpenflowActionEnqueue) QueueId() uint32 {
  offset := this.QueueIdOffset()
  res := binary.BigEndian.Uint32(this.Buf[offset:])
  return res
}

func (this *OpenflowActionEnqueue) SetQueueId(q uint32) {
  offset := this.QueueIdOffset()
  binary.BigEndian.PutUint32(this.Buf[offset:], q); offset += 4
}

func (this *OpenflowActionEnqueue) QueueIdOffset() int {
  offset := 12
  return offset
}


func NewOpenflowQueueStatsRequestWithBuf(b []byte) OpenflowQueueStatsRequest {
  return OpenflowQueueStatsRequest{OpenflowStatsRequest{OpenflowHeaderV10{openflow.OpenflowHeader{packet.Packet{Buf: b}}}}}
}

func NewOpenflowQueueStatsRequest() OpenflowQueueStatsRequest {
  s := 20
  b := make([]byte, s)
  p := OpenflowQueueStatsRequest{OpenflowStatsRequest{OpenflowHeaderV10{openflow.OpenflowHeader{packet.Packet{Buf: b}}}}}
  p.Init()
  return p
}

type OpenflowQueueStatsRequest struct {
  OpenflowStatsRequest
}

func (this OpenflowQueueStatsRequest) minSize() int {
  return 20
}

type OpenflowQueueStatsRequestConn struct {
  net.Conn
  buf []byte
  offset int
}

func NewOpenflowQueueStatsRequestConn(c net.Conn) OpenflowQueueStatsRequestConn {
  return OpenflowQueueStatsRequestConn {
    Conn: c,
    buf: make([]byte, packet.DefaultBufSize),
  }
}

func (c *OpenflowQueueStatsRequestConn) Write(pkts []OpenflowQueueStatsRequest) error {
  for _, p := range pkts {
    s := p.Size()
    b := p.Buffer()[:s]
    n := 0
    for s > 0 {
      var err error
      if n, err = c.Conn.Write(b); err != nil {
        return fmt.Errorf("Error in write: %v", err)
      }
      s -= n
    }
  }
  return nil
}

func (c *OpenflowQueueStatsRequestConn) Read(pkts []OpenflowQueueStatsRequest) (int, error) {
  if len(c.buf) == c.offset {
    newSize := packet.DefaultBufSize
    if newSize < len(c.buf) {
      newSize = 2 * len(c.buf)
    }

    buf := make([]byte, newSize)
    copy(buf, c.buf[:c.offset])
    c.buf = buf
  }

  r, err := c.Conn.Read(c.buf[c.offset:])
  if err != nil {
    return 0, err
  }

  r += c.offset

  s := 0
  n := 0
  for i := range pkts {
    p := NewOpenflowQueueStatsRequestWithBuf(c.buf)

    pSize := p.Size()
    if r < s+pSize {
      break
    }

    pkts[i] = p
    s += pSize
    n++
  }

  c.offset = r - s
  if c.offset < 0 {
    panic("Invalid value for offset")
  }

  c.buf = c.buf[s:]
  if c.offset < len(c.buf) {
    return n, nil
  }

  buf := make([]byte, packet.DefaultBufSize)
  copy(buf, c.buf[:c.offset])
  c.buf = buf
  return n, nil
}

func (this *OpenflowQueueStatsRequest) Init() {
  this.OpenflowStatsRequest.Init()
  this.SetLength(uint16(this.minSize()))
  // Invariants.
  this.SetStatsType(uint16(5)) // stats_type
  this.SetType(uint8(16)) // type
  this.SetVersion(uint8(1)) // version
}

func (this OpenflowQueueStatsRequest) Size() int {
  if len(this.Buf) < this.minSize() {
    return 0
  }

  size := int(this.Length())
  return size
}

func ConvertToOpenflowQueueStatsRequest(p OpenflowStatsRequest) (OpenflowQueueStatsRequest, error) {
  if !IsOpenflowQueueStatsRequest(p) {
    return NewOpenflowQueueStatsRequestWithBuf(nil), errors.New("Cannot convert to openflowv10.OpenflowQueueStatsRequest")
  }

  return NewOpenflowQueueStatsRequestWithBuf(p.Buf), nil
}

func IsOpenflowQueueStatsRequest(p OpenflowStatsRequest) bool {
  return p.StatsType() == 5 && true
}

func (this *OpenflowQueueStatsRequest) PortNo() uint16 {
  offset := this.PortNoOffset()
  res := binary.BigEndian.Uint16(this.Buf[offset:])
  return res
}

func (this *OpenflowQueueStatsRequest) SetPortNo(p uint16) {
  offset := this.PortNoOffset()
  binary.BigEndian.PutUint16(this.Buf[offset:], p); offset += 2
}

func (this *OpenflowQueueStatsRequest) PortNoOffset() int {
  offset := 12
  return offset
}


func (this *OpenflowQueueStatsRequest) Pad() [2]uint8 {
  offset := this.PadOffset()
  packet_size := this.Size()
  size := packet_size - offset
  count := this.Size() - offset
  i := 0
  var res [2]uint8
  for size > 0 && count > 0 && packet_size > offset {
    elem := uint8(this.Buf[offset])
    if size < 1 {
      break
    }
    size -= 1
    count--
    res[i] = elem
    i++
  }
  return res
}

func (this *OpenflowQueueStatsRequest) SetPad(p [2]uint8) {
  offset := this.PadOffset()
  for _, e := range p {
    this.Buf[offset] = byte(e); offset++
  }
}

func (this *OpenflowQueueStatsRequest) PadOffset() int {
  offset := 14
  return offset
}


func (this *OpenflowQueueStatsRequest) QueueId() uint32 {
  offset := this.QueueIdOffset()
  res := binary.BigEndian.Uint32(this.Buf[offset:])
  return res
}

func (this *OpenflowQueueStatsRequest) SetQueueId(q uint32) {
  offset := this.QueueIdOffset()
  binary.BigEndian.PutUint32(this.Buf[offset:], q); offset += 4
}

func (this *OpenflowQueueStatsRequest) QueueIdOffset() int {
  offset := 16
  return offset
}


func NewOpenflowQueueStatsWithBuf(b []byte) OpenflowQueueStats {
  return OpenflowQueueStats{OpenflowStatsReply{OpenflowHeaderV10{openflow.OpenflowHeader{packet.Packet{Buf: b}}}}}
}

func NewOpenflowQueueStats() OpenflowQueueStats {
  s := 44
  b := make([]byte, s)
  p := OpenflowQueueStats{OpenflowStatsReply{OpenflowHeaderV10{openflow.OpenflowHeader{packet.Packet{Buf: b}}}}}
  p.Init()
  return p
}

type OpenflowQueueStats struct {
  OpenflowStatsReply
}

func (this OpenflowQueueStats) minSize() int {
  return 44
}

type OpenflowQueueStatsConn struct {
  net.Conn
  buf []byte
  offset int
}

func NewOpenflowQueueStatsConn(c net.Conn) OpenflowQueueStatsConn {
  return OpenflowQueueStatsConn {
    Conn: c,
    buf: make([]byte, packet.DefaultBufSize),
  }
}

func (c *OpenflowQueueStatsConn) Write(pkts []OpenflowQueueStats) error {
  for _, p := range pkts {
    s := p.Size()
    b := p.Buffer()[:s]
    n := 0
    for s > 0 {
      var err error
      if n, err = c.Conn.Write(b); err != nil {
        return fmt.Errorf("Error in write: %v", err)
      }
      s -= n
    }
  }
  return nil
}

func (c *OpenflowQueueStatsConn) Read(pkts []OpenflowQueueStats) (int, error) {
  if len(c.buf) == c.offset {
    newSize := packet.DefaultBufSize
    if newSize < len(c.buf) {
      newSize = 2 * len(c.buf)
    }

    buf := make([]byte, newSize)
    copy(buf, c.buf[:c.offset])
    c.buf = buf
  }

  r, err := c.Conn.Read(c.buf[c.offset:])
  if err != nil {
    return 0, err
  }

  r += c.offset

  s := 0
  n := 0
  for i := range pkts {
    p := NewOpenflowQueueStatsWithBuf(c.buf)

    pSize := p.Size()
    if r < s+pSize {
      break
    }

    pkts[i] = p
    s += pSize
    n++
  }

  c.offset = r - s
  if c.offset < 0 {
    panic("Invalid value for offset")
  }

  c.buf = c.buf[s:]
  if c.offset < len(c.buf) {
    return n, nil
  }

  buf := make([]byte, packet.DefaultBufSize)
  copy(buf, c.buf[:c.offset])
  c.buf = buf
  return n, nil
}

func (this *OpenflowQueueStats) Init() {
  this.OpenflowStatsReply.Init()
  this.SetLength(uint16(this.minSize()))
  // Invariants.
  this.SetStatsType(uint16(5)) // stats_type
  this.SetType(uint8(17)) // type
  this.SetVersion(uint8(1)) // version
}

func (this OpenflowQueueStats) Size() int {
  if len(this.Buf) < this.minSize() {
    return 0
  }

  size := int(this.Length())
  return size
}

func ConvertToOpenflowQueueStats(p OpenflowStatsReply) (OpenflowQueueStats, error) {
  if !IsOpenflowQueueStats(p) {
    return NewOpenflowQueueStatsWithBuf(nil), errors.New("Cannot convert to openflowv10.OpenflowQueueStats")
  }

  return NewOpenflowQueueStatsWithBuf(p.Buf), nil
}

func IsOpenflowQueueStats(p OpenflowStatsReply) bool {
  return p.StatsType() == 5 && true
}

func (this *OpenflowQueueStats) PortNo() uint16 {
  offset := this.PortNoOffset()
  res := binary.BigEndian.Uint16(this.Buf[offset:])
  return res
}

func (this *OpenflowQueueStats) SetPortNo(p uint16) {
  offset := this.PortNoOffset()
  binary.BigEndian.PutUint16(this.Buf[offset:], p); offset += 2
}

func (this *OpenflowQueueStats) PortNoOffset() int {
  offset := 12
  return offset
}


func (this *OpenflowQueueStats) Pad() [2]uint8 {
  offset := this.PadOffset()
  packet_size := this.Size()
  size := packet_size - offset
  count := this.Size() - offset
  i := 0
  var res [2]uint8
  for size > 0 && count > 0 && packet_size > offset {
    elem := uint8(this.Buf[offset])
    if size < 1 {
      break
    }
    size -= 1
    count--
    res[i] = elem
    i++
  }
  return res
}

func (this *OpenflowQueueStats) SetPad(p [2]uint8) {
  offset := this.PadOffset()
  for _, e := range p {
    this.Buf[offset] = byte(e); offset++
  }
}

func (this *OpenflowQueueStats) PadOffset() int {
  offset := 14
  return offset
}


func (this *OpenflowQueueStats) QueueId() uint32 {
  offset := this.QueueIdOffset()
  res := binary.BigEndian.Uint32(this.Buf[offset:])
  return res
}

func (this *OpenflowQueueStats) SetQueueId(q uint32) {
  offset := this.QueueIdOffset()
  binary.BigEndian.PutUint32(this.Buf[offset:], q); offset += 4
}

func (this *OpenflowQueueStats) QueueIdOffset() int {
  offset := 16
  return offset
}


func (this *OpenflowQueueStats) TxBytes() uint64 {
  offset := this.TxBytesOffset()
  res := binary.BigEndian.Uint64(this.Buf[offset:])
  return res
}

func (this *OpenflowQueueStats) SetTxBytes(t uint64) {
  offset := this.TxBytesOffset()
  binary.BigEndian.PutUint64(this.Buf[offset:], t); offset += 8
}

func (this *OpenflowQueueStats) TxBytesOffset() int {
  offset := 20
  return offset
}


func (this *OpenflowQueueStats) TxPackets() uint64 {
  offset := this.TxPacketsOffset()
  res := binary.BigEndian.Uint64(this.Buf[offset:])
  return res
}

func (this *OpenflowQueueStats) SetTxPackets(t uint64) {
  offset := this.TxPacketsOffset()
  binary.BigEndian.PutUint64(this.Buf[offset:], t); offset += 8
}

func (this *OpenflowQueueStats) TxPacketsOffset() int {
  offset := 28
  return offset
}


func (this *OpenflowQueueStats) TxErrors() uint64 {
  offset := this.TxErrorsOffset()
  res := binary.BigEndian.Uint64(this.Buf[offset:])
  return res
}

func (this *OpenflowQueueStats) SetTxErrors(t uint64) {
  offset := this.TxErrorsOffset()
  binary.BigEndian.PutUint64(this.Buf[offset:], t); offset += 8
}

func (this *OpenflowQueueStats) TxErrorsOffset() int {
  offset := 36
  return offset
}