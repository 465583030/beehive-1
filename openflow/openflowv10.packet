# Copyright (C) 2013-2014, The Beehive project authors.
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

# Implemented based on openflow.h version 1.
# Author: Soheil Hassas Yeganeh <soheil@cs.toronto.edu>
include <openflow.packet>;

# OpenFlow port numbers. Physical ports start from 1.
enum OpenflowPorts {
  OFPP_MAX = 0xff00,

  # Fake output "ports".
  OFPP_IN_PORT = 0xfff8,  # Send the packet out the input port.  This
                          # virtual port must be explicitly used
                          # in order to send back out of the input
                          # port.
  OFPP_TABLE = 0xfff9,  # Perform actions in flow table.
                        # NB: This can only be the destination
                        # port for packet-out messages.
  OFPP_NORMAL = 0xfffa,  # Process with normal L2/L3 switching.
  OFPP_FLOOD = 0xfffb,  # All physical ports except input port and
                        #   those disabled by STP.
  OFPP_ALL = 0xfffc,  # All physical ports except input port.
  OFPP_CONTROLLER = 0xfffd,  # Send to controller.
  OFPP_LOCAL = 0xfffe,  # Local openflow "port".
  OFPP_NONE = 0xffff   # Not associated with a physical port.
}

enum Openflow10Type {
  # Asynchronous messages.
  OFPT_PACKET_IN = 10,           # Async message
  OFPT_FLOW_REMOVED = 11,        # Async message
  OFPT_PORT_STATUS = 12,         # Async message

  # Controller command messages.
  OFPT_PACKET_OUT = 13,          # Controller/switch message
  OFPT_FLOW_MOD = 14,            # Controller/switch message
  OFPT_PORT_MOD = 15,            # Controller/switch message

  # Statistics messages.
  OFPT_STATS_REQUEST = 16,       # Controller/switch message
  OFPT_STATS_REPLY = 17,         # Controller/switch message

  # Barrier messages.
  OFPT_BARRIER_REQUEST = 18,     # Controller/switch message
  OFPT_BARRIER_REPLY = 19,       # Controller/switch message

  # Queue Configuration messages.
  OFPT_QUEUE_GET_CONFIG_REQUEST = 20,  # Controller/switch message
  OFPT_QUEUE_GET_CONFIG_REPLY = 21     # Controller/switch message
}

@type_selector(version = openflow.OpenflowVersions.OPENFLOW_1_0)
packet OpenflowHeaderV10(openflow.OpenflowHeader) {
}

@type_selector(version = openflow.OpenflowVersions.OPENFLOW_1_0)
packet OpenflowHello(openflow.OpenflowHello) {
}

@type_selector(type = openflow.OpenflowType.OFPT_ECHO_REQUEST)
packet OpenflowEchoRequest(OpenflowHeaderV10) {
}

@type_selector(type = openflow.OpenflowType.OFPT_ECHO_REPLY)
packet OpenflowEchoReply(OpenflowHeaderV10) {
}

@type_selector(type = openflow.OpenflowType.OFPT_FEATURES_REQUEST)
packet OpenflowFeaturesRequest(OpenflowHeaderV10) {
}

# Get switch configuration.
@type_selector(type = openflow.OpenflowType.OFPT_GET_CONFIG_REQUEST)
packet OpenflowGetConfigRequest(OpenflowHeaderV10) {
}

enum OpenflowConfigFlags {
  # Handling of IP fragments.
  OFPC_FRAG_NORMAL = 0,  # No special handling for fragments.
  OFPC_FRAG_DROP = 1,    # Drop fragments.
  OFPC_FRAG_REASM = 2,   # Reassemble (only if OFPC_IP_REASM set).
  OFPC_FRAG_MASK = 3
}

# Config request reply.
@type_selector(type = openflow.OpenflowType.OFPT_GET_CONFIG_REPLY)
packet OpenflowSwitchGetConfigReply(OpenflowHeaderV10) {
  uint16 flags;          # OFPC_* flags.
  uint16 miss_send_len;  # Max bytes of new flow that datapath should
                         # send to the controller.
}

# Set switch config.
@type_selector(type = openflow.OpenflowType.OFPT_SET_CONFIG)
packet OpenflowSwitchSetConfig(OpenflowHeaderV10) {
  uint16 flags;          # OFPC_* flags.
  uint16 miss_send_len;  # Max bytes of new flow that datapath should
                         # send to the controller.
}

# Capabilities supported by the datapath.
enum OpenflowCapabilities {
  OFPC_FLOW_STATS = 1,      # Flow statistics.
  OFPC_TABLE_STATS = 2,     # Table statistics.
  OFPC_PORT_STATS = 4,      # Port statistics.
  OFPC_STP = 8,             # 802.1d spanning tree.
  OFPC_RESERVED = 16,       # Reserved, must be zero.
  OFPC_IP_REASM = 32,       # Can reassemble IP fragments.
  OFPC_QUEUE_STATS = 64,    # Queue statistics.
  OFPC_ARP_MATCH_IP = 128   # Match IP addresses in ARP pkts.
}

# Flags to indicate behavior of the physical port. These flags are
# used in OpenflowPhysicalPort to describe the current configuration. They are
# used in the ofp_port_mod message to configure the port's behavior.
enum OpenflowPortConfig {
  OFPPC_PORT_DOWN = 1,      # Port is administratively down.

  OFPPC_NO_STP = 2,         # Disable 802.1D spanning tree on port.
  OFPPC_NO_RECV = 4,        # Drop all packets except 802.1D spanning
                            # tree packets.
  OFPPC_NO_RECV_STP = 8,    # Drop received 802.1D STP packets.
  OFPPC_NO_FLOOD = 16,      # Do not include this port when flooding.
  OFPPC_NO_FWD = 32,        # Drop packets forwarded to port.
  OFPPC_NO_PACKET_IN = 64   # Do not send packet-in msgs for port.
}

# Current state of the physical port.  These are not configurable from
# the controller.
enum OpenflowPortState {
  OFPPS_LINK_DOWN = 1,  # No physical link present.

  # The OFPPS_STP_* bits have no effect on switch operation. The
  # controller must adjust OFPPC_NO_RECV, OFPPC_NO_FWD, and
  # OFPPC_NO_PACKET_IN appropriately to fully implement an 802.1D spanning
  # tree.
  OFPPS_STP_LISTEN = 0,     # Not learning or relaying frames.
  OFPPS_STP_LEARN = 256,    # Learning but not relaying frames.
  OFPPS_STP_FORWARD = 512,  # Learning and relaying frames.
  OFPPS_STP_BLOCK = 768,    # Not part of spanning tree.
  OFPPS_STP_MASK = 768      # Bit mask for OFPPS_STP_* values.
}

# Features of physical ports available in a datapath.
enum OpenflowPortFeatures {
  OFPPF_10MB_HD = 0,  # 10 Mb half-duplex rate support.
  OFPPF_10MB_FD = 2,  # 10 Mb full-duplex rate support.
  OFPPF_100MB_HD = 4,  # 100 Mb half-duplex rate support.
  OFPPF_100MB_FD = 8,  # 100 Mb full-duplex rate support.
  OFPPF_1GB_HD = 16,  # 1 Gb half-duplex rate support.
  OFPPF_1GB_FD = 32,  # 1 Gb full-duplex rate support.
  OFPPF_10GB_FD = 64,  # 10 Gb full-duplex rate support.
  OFPPF_COPPER = 128,  # Copper medium.
  OFPPF_FIBER = 256,  # Fiber medium.
  OFPPF_AUTONEG = 512,  # Auto-negotiation.
  OFPPF_PAUSE = 1024,  # Pause.
  OFPPF_PAUSE_ASYM = 2048  # Asymmetric pause.
}

# Represents a switch port.
@bigendian
packet OpenflowPhysicalPort {
  uint16 port_no;
  @repeated(count = 6) uint8 hw_addr;
  @repeated(count = 16) char name;

  uint32 config;  # Bitmap of OpenflowPortConfig
  uint32 state;  # Bitmap of OpenflowPortState

  # All the followings are bitmaps of OpenflowPortFeatures.
  uint32 curr;
  uint32 advertised;
  uint32 supported;
  uint32 peer;
}

@type_selector(type = openflow.OpenflowType.OFPT_FEATURES_REPLY)
packet OpenflowFeaturesReply(OpenflowHeaderV10) {
  uint64 datapath_id;
  uint32 n_buffers;

  uint8 n_tables;
  @repeated(count = 3) uint8 pad;

  # Features.
  uint32 capabilities;
  uint32 actions;

  # Port info.
  @repeated OpenflowPhysicalPort ports;
}

# What changed about the physical port.
enum OpenflowPortReason {
  OFPPR_ADD = 0,              # The port was added.
  OFPPR_DELETE = 1,           # The port was removed.
  OFPPR_MODIFY = 2            # Some attribute of the port has changed.
}

@type_selector(type = Openflow10Type.OFPT_PORT_STATUS)
packet OpenflowPortStatus(OpenflowHeaderV10) {
  uint8 reason;  # Set from OpenflowPortReason.
  @repeated(count = 7) uint8 pad;
  OpenflowPhysicalPort desc;
}

# Modify behavior of the physical port.
@type_selector(type = Openflow10Type.OFPT_PORT_MOD)
packet OpenflowPortMod(OpenflowHeaderV10) {
  uint16 port_no;
  @repeated(count = 6) uint8 hw_addr;  # The hardware address is not
                                    # configurable.  This is used to
                                    # sanity-check the request, so it must
                                    # be the same as returned in an
                                    # OpenflowPhysicalPort packet.
  uint32 config;  # Bitmap of OFPPC_* flags.
  uint32 mask;  # Bitmap of OFPPC_* flags to be changed.

  uint32 advertise;  # Bitmap of "OpenflowPortFeatures"s.  Zero all
                     # bits to prevent any action taking place.
  @repeated(count = 4) uint8 pad;  # Pad to 64-bits.
}

# Why is this packet being sent to the controller?
enum OpenflowPacketInReason {
  OFPR_NO_MATCH = 0,          # No matching flow.
  OFPR_ACTION = 1             # Action explicitly output to controller.
}

# Packet received on port (datapath -> controller).
@type_selector(type = Openflow10Type.OFPT_PACKET_IN)
packet OpenflowPacketIn(OpenflowHeaderV10) {
  uint32 buffer_id;     # ID assigned by datapath.
  uint16 total_len;     # Full length of frame.
  uint16 in_port;       # Port on which frame was received.
  uint8 reason;         # Reason packet is being sent (one of OFPR_*)
  uint8 pad;

  @repeated
  uint8 data;           # Ethernet frame, halfway through 32-bit word,
                        # so the IP header is 32-bit aligned.  The
                        # amount of data is inferred from the length
                        # field in the header.  Because of padding,
                        # offsetof(packet OpenflowPacketIn, data) ==
                        # sizeof(packet OpenflowPacketIn) - 2.
}

enum OpenflowActionType {
  OFPAT_OUTPUT = 0,           # Output to switch port.
  OFPAT_SET_VLAN_VID = 1,     # Set the 802.1q VLAN id.
  OFPAT_SET_VLAN_PCP = 2,     # Set the 802.1q priority.
  OFPAT_STRIP_VLAN = 3,       # Strip the 802.1q header.
  OFPAT_SET_DL_SRC = 4,       # Ethernet source address.
  OFPAT_SET_DL_DST = 5,       # Ethernet destination address.
  OFPAT_SET_NW_SRC = 6,       # IP source address.
  OFPAT_SET_NW_DST = 7,       # IP destination address.
  OFPAT_SET_NW_TOS = 8,       # IP ToS (DSCP field, 6 bits).
  OFPAT_SET_TP_SRC = 9,       # TCP/UDP source port.
  OFPAT_SET_TP_DST = 10,      # TCP/UDP destination port.
  OFPAT_ENQUEUE = 11,         # Output to queue.
  OFPAT_VENDOR = 0xffff
}

# Action header that is common to all actions.  The length includes the
# header and any padding used to make the action 64-bit aligned.
# NB: The length of an action *must* always be a multiple of eight.
@bigendian
packet OpenflowActionHeader {
  uint16 type;  # One of OFPAT_*.
  @size
  uint16 len;   # Length of action, including this
                # header.  This is the length of action,
                # including any padding to make it
                # 64-bit aligned.
}

# Action packeture for OFPAT_OUTPUT, which sends packets out 'port'.
# When the 'port' is the OFPP_CONTROLLER, 'max_len' indicates the max
# number of bytes to send.  A 'max_len' of zero means no bytes of the
# packet should be sent.
@type_selector(type = OpenflowActionType.OFPAT_OUTPUT)
packet OpenflowActionOutput(OpenflowActionHeader) {
  uint16 port;     # Output port.
  uint16 max_len;  # Max length to send to controller.
}

# The VLAN id is 12 bits, so we can use the entire 16 bits to indicate
# special conditions.  All ones is used to match that no VLAN id was
# set.
enum OpenflowVlanIds {
  OFP_VLAN_NONE = 0xffff
}

@type_selector(type = OpenflowActionType.OFPAT_SET_VLAN_VID)
packet OpenflowActionVlanVid(OpenflowActionHeader) {
  uint16 vlan_vid;  # VLAN id.
  @repeated(count = 2)
  uint8 pad;
}

@type_selector(type = OpenflowActionType.OFPAT_SET_VLAN_PCP)
packet OpenflowActionVlanPcp(OpenflowActionHeader) {
  uint8 vlan_pcp;               # VLAN priority.
  @repeated(count = 3) uint8 pad;
}

@type_selector(type = OpenflowActionType.OFPAT_SET_DL_SRC)
packet OpenflowActionDlSrcAddr(OpenflowActionHeader) {
  @repeated(count = openflow.OpenflowConstants.OFP_ETH_ALEN)
  uint8 dl_addr;  # Ethernet address.

  @repeated(count = 6)
  uint8 pad;
}

@type_selector(type = OpenflowActionType.OFPAT_SET_DL_DST)
packet OpenflowActionDlDstAddr(OpenflowActionHeader) {
  @repeated(count = openflow.OpenflowConstants.OFP_ETH_ALEN)
  uint8 dl_addr;  # Ethernet address.

  @repeated(count = 6)
  uint8 pad;
}

@type_selector(type = OpenflowActionType.OFPAT_SET_NW_SRC)
packet OpenflowActionNwSrcAddr(OpenflowActionHeader) {
  uint32 nw_addr;               # IP address.
}

@type_selector(type = OpenflowActionType.OFPAT_SET_NW_DST)
packet OpenflowActionNwDstAddr(OpenflowActionHeader) {
  uint32 nw_addr;               # IP address.
}

@type_selector(type = OpenflowActionType.OFPAT_SET_TP_SRC)
packet OpenflowActionTpSrcPort(OpenflowActionHeader) {
  uint16 tp_port;               # TCP/UDP port.

  @repeated(count = 2)
  uint8 pad;
}

@type_selector(type = OpenflowActionType.OFPAT_SET_TP_DST)
packet OpenflowActionTpDstPort(OpenflowActionHeader) {
  uint16 tp_port;               # TCP/UDP port.

  @repeated(count = 2)
  uint8 pad;
}

# Action packeture for OFPAT_SET_NW_TOS.
@type_selector(type = OpenflowActionType.OFPAT_SET_NW_TOS)
packet OpenflowActionNwTos(OpenflowActionHeader) {
  uint8 nw_tos;                 # IP ToS (DSCP field, 6 bits).
  @repeated(count = 3)
  uint8 pad;
}

# Action header for OFPAT_VENDOR. The rest of the body is vendor-defined.
@type_selector(type = OpenflowActionType.OFPAT_VENDOR)
packet OpenflowActionVendorHeader(OpenflowActionHeader) {
  uint32 vendor;                # Vendor ID, which takes the same form
                                # as in "packet OpenflowVendorHeader".
}

# Send packet (controller -> datapath).
@type_selector(type = Openflow10Type.OFPT_PACKET_OUT)
packet OpenflowPacketOut(OpenflowHeaderV10) {
  uint32 buffer_id;           # ID assigned by datapath (-1 if none).
  uint16 in_port;             # Packet's input port (OFPP_NONE if none).
  @size(actions)
  uint16 actions_len;         # Size of action array in bytes.
  @repeated
  OpenflowActionHeader actions;
  @repeated uint8 data;        # Packet data.  The length is inferred
                               # from the length field in the header.
                               # (Only meaningful if buffer_id == -1.)
}

enum OpenflowFlowModCommand {
  OFPFC_ADD = 0,              # New flow.
  OFPFC_MODIFY = 1,           # Modify all matching flows.
  OFPFC_MODIFY_STRICT = 2,    # Modify entry strictly matching wildcards
  OFPFC_DELETE = 3,           # Delete all matching flows.
  OFPFC_DELETE_STRICT = 4     # Strictly match wildcards and priority.
}

# Flow wildcards.
enum OpenflowFlowWildcards {
  OFPFW_IN_PORT  = 1 << 0,  # Switch input port.
  OFPFW_DL_VLAN  = 1 << 1,  # VLAN id.
  OFPFW_DL_SRC   = 1 << 2,  # Ethernet source address.
  OFPFW_DL_DST   = 1 << 3,  # Ethernet destination address.
  OFPFW_DL_TYPE  = 1 << 4,  # Ethernet frame type.
  OFPFW_NW_PROTO = 1 << 5,  # IP protocol.
  OFPFW_TP_SRC   = 1 << 6,  # TCP/UDP source port.
  OFPFW_TP_DST   = 1 << 7,  # TCP/UDP destination port.

  # IP source address wildcard bit count.  0 is exact match, 1 ignores the
  #  LSB, 2 ignores the 2 least-significant bits, ..., 32 and higher wildcard
  #  the entire field.  This is the *opposite* of the usual convention where
  # e.g. /24 indicates that 8 bits (not 24 bits) are wildcarded.
  OFPFW_NW_SRC_SHIFT = 8,
  OFPFW_NW_SRC_BITS = (6 - 1),
  OFPFW_NW_SRC_MASK = ((1 << OpenflowFlowWildcards.OFPFW_NW_SRC_BITS) - 1) <<
      OpenflowFlowWildcards.OFPFW_NW_SRC_SHIFT,
  OFPFW_NW_SRC_ALL = 32 << OpenflowFlowWildcards.OFPFW_NW_SRC_SHIFT,

  # IP destination address wildcard bit count.  Same format as source.
  OFPFW_NW_DST_SHIFT = 14,
  OFPFW_NW_DST_BITS = 6,
  OFPFW_NW_DST_MASK = ((1 << OpenflowFlowWildcards.OFPFW_NW_DST_BITS) - 1) <<
      OpenflowFlowWildcards.OFPFW_NW_DST_SHIFT,
  OFPFW_NW_DST_ALL = 32 << OpenflowFlowWildcards.OFPFW_NW_DST_SHIFT,

  OFPFW_DL_VLAN_PCP = 1 << 20,  # VLAN priority.
  OFPFW_NW_TOS = 1 << 21,  # IP ToS (DSCP field, 6 bits).

  # Wildcard all fields.
  OFPFW_ALL = ((1 << 22) - 1)
}

# The wildcards for ICMP type and code fields use the transport source
# and destination port fields, respectively.
#define OFPFW_ICMP_TYPE OFPFW_TP_SRC
#define OFPFW_ICMP_CODE OFPFW_TP_DST

# Values below this cutoff are 802.3 packets and the two bytes
# following MAC addresses are used as a frame length.  Otherwise, the
# two bytes are used as the Ethernet type.

#define OFP_DL_TYPE_ETH2_CUTOFF   0x0600

# Value of dl_type to indicate that the frame does not include an
# Ethernet type.

#define OFP_DL_TYPE_NOT_ETH_TYPE  0x05ff

# The VLAN id is 12-bits, so we can use the entire 16 bits to indicate
# special conditions.  All ones indicates that no VLAN id was set.

#define OFP_VLAN_NONE      0xffff

# Fields to match against flows
@bigendian
packet OpenflowMatch {
  uint32 wildcards;        # Wildcard fields.
  uint16 in_port;          # Input switch port.
  @repeated(count = openflow.OpenflowConstants.OFP_ETH_ALEN)
  uint8 dl_src;            # Ethernet source address.
  @repeated(count = openflow.OpenflowConstants.OFP_ETH_ALEN)
  uint8 dl_dst;            # Ethernet destination address.
  uint16 dl_vlan;          # Input VLAN id.
  uint8 dl_vlan_pcp;       # Input VLAN priority.
  @repeated(count = 1)
  uint8 pad1;              # Align to 64-bits
  uint16 dl_type;          # Ethernet frame type.
  uint8 nw_tos;            # IP ToS (actually DSCP field, 6 bits).
  uint8 nw_proto;          # IP protocol or lower 8 bits of
                           # ARP opcode.
  @repeated(count = 2)
  uint8 pad2;              # Align to 64-bits
  uint32 nw_src;           # IP source address.
  uint32 nw_dst;           # IP destination address.
  uint16 tp_src;           # TCP/UDP source port.
  uint16 tp_dst;           # TCP/UDP destination port.
}

# The match fields for ICMP type and code use the transport source and
# destination port fields, respectively.
#define icmp_type tp_src
#define icmp_code tp_dst

# Value used in "idle_timeout" and "hard_timeout" to indicate that the entry
# is permanent.
#define OFP_FLOW_PERMANENT 0

# By default, choose a priority in the middle.
#define OFP_DEFAULT_PRIORITY 0x8000

enum OpenflowFlowModFlags {
  OFPFF_SEND_FLOW_REM = 1 << 0,  # Send flow removed message when flow
                                 # expires or is deleted.
  OFPFF_CHECK_OVERLAP = 1 << 1,  # Check for overlapping entries first.
  OFPFF_EMERG         = 1 << 2   # Remark this is for emergency.
}

# Flow setup and teardown (controller -> datapath).
@type_selector(type = Openflow10Type.OFPT_FLOW_MOD)
packet OpenflowFlowMod(OpenflowHeaderV10) {
  OpenflowMatch match;      # Fields to match
  uint64 cookie;             # Opaque controller-issued identifier.

  # Flow actions.
  uint16 command;             # One of OFPFC_*.
  uint16 idle_timeout;        # Idle time before discarding (seconds).
  uint16 hard_timeout;        # Max time before discarding (seconds).
  uint16 priority;            # Priority level of flow entry.
  uint32 buffer_id;           # Buffered packet to apply to (or -1).
                              # Not meaningful for OFPFC_DELETE*.
  uint16 out_port;            # For OFPFC_DELETE* commands, require
                              # matching entries to include this as an
                              # output port.  A value of OFPP_NONE
                              # indicates no restriction.
  uint16 flags;               # One of OFPFF_*.
  @repeated
  OpenflowActionHeader actions; # The action length is inferred
                                # from the length field in the
                                # header.
}

# Why was this flow removed?
enum OpenflowFlowRemovedReason {
  OFPRR_IDLE_TIMEOUT = 0,         # Flow idle time exceeded idle_timeout.
  OFPRR_HARD_TIMEOUT = 1,         # Time exceeded hard_timeout.
  OFPRR_DELETE = 2                # Evicted by a DELETE flow mod.
}

# Flow removed (datapath -> controller).
@type_selector(type = Openflow10Type.OFPT_FLOW_REMOVED)
packet OpenflowFlowRemoved(OpenflowHeaderV10) {
  OpenflowMatch match;    # Description of fields.
  uint64 cookie;          # Opaque controller-issued identifier.

  uint16 priority;        # Priority level of flow entry.
  uint8 reason;           # One of OFPRR_*.
  @repeated(count = 1)
  uint8 pad;              # Align to 32-bits.

  uint32 duration_sec;    # Time flow was alive in seconds.
  uint32 duration_nsec;   # Time flow was alive in nanoseconds beyond
                          # duration_sec.
  uint16 idle_timeout;    # Idle timeout from original flow mod.
  @repeated(count = 2)
  uint8 pad2;             # Align to 64-bits.
  uint64 packet_count;
  uint64 byte_count;
}

# Values for 'type' in OpenflowErrorMessage.  These values are immutable: they
# will not change in future versions of the protocol (although new values may
# be added).
enum OpenflowErrorType {
  OFPET_HELLO_FAILED = 0,         # Hello protocol failed.
  OFPET_BAD_REQUEST = 1,          # Request was not understood.
  OFPET_BAD_ACTION = 2,           # Error in action description.
  OFPET_FLOW_MOD_FAILED = 3,      # Problem modifying flow entry.
  OFPET_PORT_MOD_FAILED = 4,      # Port mod request failed.
  OFPET_QUEUE_OP_FAILED = 5       # Queue operation failed.
}

# OpenflowErrorMsg 'code' values for OFPET_HELLO_FAILED.  'data' contains an
# ASCII text string that may give failure details.
enum OpenflowHelloFailedCode {
  OFPHFC_INCOMPATIBLE = 0,        # No compatible version.
  OFPHFC_EPERM = 1                # Permissions error.
}

# OpenflowErrorMsg 'code' values for OFPET_BAD_REQUEST.  'data' contains at least
# the first 64 bytes of the failed request.
enum OpenflowBadRequestCode {
  OFPBRC_BAD_VERSION = 0,         # ofp_header.version not supported.
  OFPBRC_BAD_TYPE = 1,            # ofp_header.type not supported.
  OFPBRC_BAD_STAT = 2,            # OpenflowStatsRequest.type not supported.
  OFPBRC_BAD_VENDOR = 3,          # Vendor not supported (in OpenflowVendorHeader
                                  # or OpenflowStatsRequest or OpenflowStatsReply).
  OFPBRC_BAD_SUBTYPE = 4,         # Vendor subtype not supported.
  OFPBRC_EPERM = 5,               # Permissions error.
  OFPBRC_BAD_LEN = 6,             # Wrong request length for type.
  OFPBRC_BUFFER_EMPTY = 7,        # Specified buffer has already been used.
  OFPBRC_BUFFER_UNKNOWN = 8       # Specified buffer does not exist.
}

# OpenflowErrorMsg 'code' values for OFPET_BAD_ACTION.  'data' contains at least
# the first 64 bytes of the failed request.
enum OpenflowBadActionCode {
  OFPBAC_BAD_TYPE = 0,           # Unknown action type.
  OFPBAC_BAD_LEN = 1,            # Length problem in actions.
  OFPBAC_BAD_VENDOR = 2,         # Unknown vendor id specified.
  OFPBAC_BAD_VENDOR_TYPE = 3,    # Unknown action type for vendor id.
  OFPBAC_BAD_OUT_PORT = 4,       # Problem validating output action.
  OFPBAC_BAD_ARGUMENT = 5,       # Bad action argument.
  OFPBAC_EPERM = 6,              # Permissions error.
  OFPBAC_TOO_MANY = 7,           # Can't handle this many actions.
  OFPBAC_BAD_QUEUE = 8           # Problem validating output queue.
}

# OpenflowErrorMsg 'code' values for OFPET_FLOW_MOD_FAILED.  'data' contains
# at least the first 64 bytes of the failed request.
enum OpenflowFlow_modFailedCode {
  OFPFMFC_ALL_TABLES_FULL = 0,    # Flow not added because of full tables.
  OFPFMFC_OVERLAP = 1,            # Attempted to add overlapping flow with
                                  # CHECK_OVERLAP flag set.
  OFPFMFC_EPERM = 2,              # Permissions error.
  OFPFMFC_BAD_EMERG_TIMEOUT = 3,  # Flow not added because of non-zero idle/hard
                                  # timeout.
  OFPFMFC_BAD_COMMAND = 4,        # Unknown command.
  OFPFMFC_UNSUPPORTED = 5         # Unsupported action list - cannot process in
                                  # the order specified.
}

# OpenflowErrorMsg 'code' values for OFPET_PORT_MOD_FAILED.  'data' contains
# at least the first 64 bytes of the failed request.
enum OpenflowPort_modFailedCode {
  OFPPMFC_BAD_PORT = 0,            # Specified port does not exist.
  OFPPMFC_BAD_HW_ADDR = 1          # Specified hardware address is wrong.
}

# ofp_error msg 'code' values for OFPET_QUEUE_OP_FAILED. 'data' contains
# at least the first 64 bytes of the failed request
enum OpenflowQueueOpFailedCode {
  OFPQOFC_BAD_PORT = 0,           # Invalid port (or port does not exist).
  OFPQOFC_BAD_QUEUE = 1,          # Queue does not exist.
  OFPQOFC_EPERM = 2               # Permissions error.
}

# OFPT_ERROR: Error message (datapath -> controller).
@type_selector(type = openflow.OpenflowType.OFPT_ERROR)
packet OpenflowErrorMsg(OpenflowHeaderV10) {
  uint16 err_type;
  uint16 code;
  @repeated
  uint8 data;  # Variable-length data.  Interpreted based
               # on the type and code.
}

enum OpenflowStatsTypes {
  # Description of this OpenFlow switch.
  # The request body is empty.
  # The reply body is packet OpenflowDescStats.
  OFPST_DESC = 0,

  # Individual flow statistics.
  # The request body is packet OpenflowFlowStatsRequest.
  # The reply body is an array of packet OpenflowFlowStats.
  OFPST_FLOW = 1,

  # Aggregate flow statistics.
  # The request body is packet OpenflowAggregateStatsRequest.
  # The reply body is packet OpenflowAggregateStatsReply.
  OFPST_AGGREGATE = 2,

  # Flow table statistics.
  # The request body is empty.
  # The reply body is an array of packet OpenflowTableStats.
  OFPST_TABLE = 3,

  # Physical port statistics.
  # The request body is packet OpenflowPortStatsRequest.
  # The reply body is an array of packet OpenflowPortStats.
  OFPST_PORT = 4,

  # Queue statistics for a port
  # The request body defines the port
  # The reply body is an array of packet OpenflowQueueStats
  OFPST_QUEUE = 5,

  # Vendor extension.
  # The request and reply bodies begin with a 32-bit vendor ID, which takes
  # the same form as in "packet OpenflowVendorHeader".  The request and reply
  # bodies are otherwise vendor-defined.
  OFPST_VENDOR = 0xffff
}

@type_selector(type = Openflow10Type.OFPT_STATS_REQUEST)
packet OpenflowStatsRequest(OpenflowHeaderV10) {
  uint16 stats_type;        # One of the OFPST_* constants.
  uint16 flags;             # OFPSF_REQ_* flags (none yet defined).
}

enum OpenflowStatsReplyFlags {
  OFPSF_REPLY_MORE  = 1 << 0  # More replies to follow.
}

@type_selector(type = Openflow10Type.OFPT_STATS_REPLY)
packet OpenflowStatsReply(OpenflowHeaderV10) {
  uint16 stats_type;  # One of the OFPST_* constants.
  uint16 flags;       # OFPSF_REPLY_* flags.
}

enum OpenflowDescStatsConstants {
  SERIAL_NUM_LEN = 32,
  DESC_STR_LEN = 256
}

#define DESC_STR_LEN   256
#define SERIAL_NUM_LEN 32
# Body of reply to OFPST_DESC request.  Each entry is a NULL-terminated
# ASCII string.
@type_selector(stats_type = OpenflowStatsTypes.OFPST_DESC)
packet OpenflowDescStats(OpenflowStatsReply) {
  @repeated(count = OpenflowDescStatsConstants.DESC_STR_LEN)
  char mfr_desc;  # Manufacturer description.
  @repeated(count = OpenflowDescStatsConstants.DESC_STR_LEN)
  char hw_desc;  # Hardware description.
  @repeated(count = OpenflowDescStatsConstants.DESC_STR_LEN)
  char sw_desc;  # Software description.
  @repeated(count = OpenflowDescStatsConstants.SERIAL_NUM_LEN)
  char serial_num;   # Serial number.
  @repeated(count = OpenflowDescStatsConstants.DESC_STR_LEN)
  char dp_desc;  # Human readable description of datapath.
}

# Body for OpenflowStatsRequest of type OFPST_FLOW.
@type_selector(stats_type = OpenflowStatsTypes.OFPST_FLOW)
packet OpenflowFlowStatsRequest(OpenflowStatsRequest) {
  OpenflowMatch match;  # Fields to match.
  uint8 table_id;       # ID of table to read (from OpenflowTableStats),
                        # 0xff for all tables or 0xfe for emergency.
  uint8 pad;            # Align to 32 bits.
  uint16 out_port;      # Require matching entries to include this
                        # as an output port.  A value of OFPP_NONE
                        # indicates no restriction.
}

# The Openflow flow stats.
@bigendian
packet OpenflowFlowStats {
  @size
  uint16 length;          # Length of this entry.
  uint8 table_id;         # ID of table flow came from.
  uint8 pad;
  OpenflowMatch match;    # Description of fields.
  uint32 duration_sec;    # Time flow has been alive in seconds.
  uint32 duration_nsec;   # Time flow has been alive in nanoseconds beyond
                          # duration_sec.
  uint16 priority;        # Priority of the entry. Only meaningful
                          # when this is not an exact-match entry.
  uint16 idle_timeout;    # Number of seconds idle before expiration.
  uint16 hard_timeout;    # Number of seconds before expiration.
  @repeated(count = 6)
  uint8 pad2;             # Align to 64-bits.
  uint64 cookie;          # Opaque controller-issued identifier.
  uint64 packet_count;    # Number of packets in flow.
  uint64 byte_count;      # Number of bytes in flow.

  @repeated
  OpenflowActionHeader actions; # Actions.
}

# Body of reply to OFPST_FLOW request.
@type_selector(stats_type = OpenflowStatsTypes.OFPST_FLOW)
packet OpenflowFlowStatsReply(OpenflowStatsReply) {
  @repeated
  OpenflowFlowStats flow_stats;
}

# Body for OpenflowStatsRequest of type OFPST_AGGREGATE.
@type_selector(stats_type = OpenflowStatsTypes.OFPST_AGGREGATE)
packet OpenflowAggregateStatsRequest(OpenflowStatsRequest) {
  OpenflowMatch match;    # Fields to match.
  uint8 table_id;         # ID of table to read (from OpenflowTableStats)
                          # 0xff for all tables or 0xfe for emergency.
  uint8 pad;              # Align to 32 bits.
  uint16 out_port;        # Require matching entries to include this
                          # as an output port.  A value of OFPP_NONE
                          # indicates no restriction.
}

# Body of reply to OFPST_AGGREGATE request.
@type_selector(stats_type = OpenflowStatsTypes.OFPST_AGGREGATE)
packet OpenflowAggregateStatsReply(OpenflowStatsReply) {
  uint64 packet_count;    # Number of packets in flows.
  uint64 byte_count;      # Number of bytes in flows.
  uint32 flow_count;      # Number of flows.
  @repeated(count = 4)
  uint8 pad;              # Align to 64 bits.
}

# Body of reply to OFPST_TABLE request.
@type_selector(stats_type = OpenflowStatsTypes.OFPST_TABLE)
packet OpenflowTableStats(OpenflowStatsReply) {
  uint8 table_id;        # Identifier of table.  Lower numbered tables
                         # are consulted first.
  @repeated(count = 3)
  uint8 pad;             # Align to 32-bits.
  @repeated(count = openflow.OpenflowConstants.OFP_MAX_TABLE_NAME_LEN)
  char name;
  uint32 wildcards;      # Bitmap of OFPFW_* wildcards that are
                         # supported by the table.
  uint32 max_entries;    # Max number of entries supported.
  uint32 active_count;   # Number of active entries.
  uint64 lookup_count;   # Number of packets looked up in table.
  uint64 matched_count;  # Number of packets that hit table.
}

# Body for OpenflowStatsRequest of type OFPST_PORT.
@type_selector(stats_type = OpenflowStatsTypes.OFPST_PORT)
packet OpenflowPortStatsRequest(OpenflowStatsRequest) {
  uint16 port_no;        # OFPST_PORT message must request statistics
                         # either for a single port (specified in
                         # port_no) or for all ports (if port_no ==
                         # OFPP_NONE).
  @repeated(count = 6)
  uint8 pad;
}

# Body of reply to OFPST_PORT request. If a counter is unsupported, set
# the field to all ones.
@type_selector(stats_type = OpenflowStatsTypes.OFPST_PORT)
packet OpenflowPortStats(OpenflowStatsReply) {
  uint16 port_no;
  @repeated(count = 6)
  uint8 pad;             # Align to 64-bits.
  uint64 rx_packets;     # Number of received packets.
  uint64 tx_packets;     # Number of transmitted packets.
  uint64 rx_bytes;       # Number of received bytes.
  uint64 tx_bytes;       # Number of transmitted bytes.
  uint64 rx_dropped;     # Number of packets dropped by RX.
  uint64 tx_dropped;     # Number of packets dropped by TX.
  uint64 rx_errors;      # Number of receive errors.  This is a super-set
                         # of more specific receive errors and should be
                         # greater than or equal to the sum of all
                         # rx_*_err values.
  uint64 tx_errors;      # Number of transmit errors.  This is a super-set
                         # of more specific transmit errors and should be
                         # greater than or equal to the sum of all
                         # tx_*_err values (none currently defined.)
  uint64 rx_frame_err;   # Number of frame alignment errors.
  uint64 rx_over_err;    # Number of packets with RX overrun.
  uint64 rx_crc_err;     # Number of CRC errors.
  uint64 collisions;     # Number of collisions.
}

# Vendor extension.
@type_selector(type = openflow.OpenflowType.OFPT_VENDOR)
packet OpenflowVendorHeader(OpenflowHeaderV10) {
  uint32 vendor;  # Vendor ID:
                  # - MSB 0: low-order bytes are IEEE OUI.
                  # - MSB != 0: defined by OpenFlow
                  #   consortium.
  # Vendor-defined arbitrary additional data.
}

# All ones is used to indicate all queues in a port (for stats retrieval).
#define OFPQ_ALL      0xffffffff

# Min rate > 1000 means not configured.
#define OFPQ_MIN_RATE_UNCFG      0xffff

enum OpenflowQueueProperties {
  OFPQT_NONE = 0,       # No property defined for queue (default).
  OFPQT_MIN_RATE = 1    # Minimum datarate guaranteed.
                        # Other types should be added here
                        # (i.e. max rate, precedence, etc).
}

# Common description for a queue.
@bigendian
packet OpenflowQueuePropHeader {
  uint16 property;    # One of OFPQT_.
  @size
  uint16 len;         # Length of property, including this header.
  @repeated(count = 4)
  uint8 pad;          # 64-bit alignemnt.
}

# Min-Rate queue property description.
@type_selector(property = OpenflowQueueProperties.OFPQT_MIN_RATE)
packet OpenflowQueuePropMinRate(OpenflowQueuePropHeader) {
  uint16 rate;        # In 1/10 of a percent; >1000 -> disabled.
  @repeated(count = 6)
  uint8 pad;          # 64-bit alignment
}

# Full description for a queue.
@bigendian
packet OpenflowPacketQueue {
  uint32 queue_id;     # id for the specific queue.
  @size
  uint16 len;          # Length in bytes of this queue desc.
  @repeated(count = 2)
  uint8 pad;        # 64-bit alignment.
  @repeated
  OpenflowQueuePropHeader properties; # List of properties.
}

# Query for port queue configuration.
@type_selector(type = Openflow10Type.OFPT_QUEUE_GET_CONFIG_REPLY)
packet OpenflowQueueGetConfigRequest(OpenflowHeaderV10) {
  uint16 port;  # Port to be queried. Should refer
                # to a valid physical port (i.e. < OFPP_MAX)
  @repeated
  uint8 pad;    # 32-bit alignment.
}

# Queue configuration for a given port.
@type_selector(type = Openflow10Type.OFPT_QUEUE_GET_CONFIG_REPLY)
packet OpenflowQueueGetConfigReply(OpenflowHeaderV10) {
  uint16 port;
  @repeated(count = 6)
  uint8 pad;
  @repeated
  OpenflowPacketQueue queues; # List of configured queues.
}

# OFPAT_ENQUEUE action packet: send packets to given queue on port.
@type_selector(type = OpenflowActionType.OFPAT_ENQUEUE)
packet OpenflowActionEnqueue(OpenflowActionHeader) {
  uint16 port;            # Port that queue belongs. Should
                          # refer to a valid physical port
                          # (i.e. < OFPP_MAX) or OFPP_IN_PORT.
  @repeated(count = 6)
  uint8 pad;              # Pad for 64-bit alignment.
  uint32 queue_id;        # Where to enqueue the packets.
}

@type_selector(stats_type = OpenflowStatsTypes.OFPST_QUEUE)
packet OpenflowQueueStatsRequest(OpenflowStatsRequest) {
  uint16 port_no;        # All ports if OFPT_ALL.
  @repeated(count = 2)
  uint8 pad;             # Align to 32-bits.
  uint32 queue_id;       # All queues if OFPQ_ALL.
}

@type_selector(stats_type = OpenflowStatsTypes.OFPST_QUEUE)
packet OpenflowQueueStats(OpenflowStatsReply) {
  uint16 port_no;
  @repeated(count = 2)
  uint8 pad;             # Align to 32-bits.
  uint32 queue_id;       # Queue i.d
  uint64 tx_bytes;       # Number of transmitted bytes.
  uint64 tx_packets;     # Number of transmitted packets.
  uint64 tx_errors;      # Number of packets dropped due to overrun.
}

