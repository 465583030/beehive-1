# Copyright (C) 2014, The Beehive project authors.
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

# Implemented based on openflow.h version 1.2.
# Author: Soheil Hassas Yeganeh <soheil@cs.toronto.edu>
#
# TODO(soheil): When we add support for 1.1, 1.3, and 1.4, we need to refactor
# common, unchanged messages in openflow.packet. Note: After 1.1 most messages
# are backward compatible. So, maybe we need to create an openflow1.1+ packet
# definition.
include <openflow.packet>;

# OpenFlow port numbers. Physical ports start from 1.
enum OpenflowPorts {
  OFPP_MAX = 0xffffff00,
  OFPP_IN_PORT = 0xfffffff8,
  OFPP_TABLE = 0xfffffff9,
  OFPP_NORMAL = 0xfffffffa,
  OFPP_FLOOD = 0xfffffffb,
  OFPP_ALL = 0xfffffffc,
  OFPP_CONTROLLER = 0xfffffffd,
  OFPP_LOCAL = 0xfffffffe,
  OFPP_ANY = 0xffffffff
}

enum Openflow12Type {
  # Asynchronous messages.
  OFPT_PACKET_IN = 10,  # Async message.
  OFPT_FLOW_REMOVED = 11,  # Async message.
  OFPT_PORT_STATUS = 12,  # Async message.

  # Controller command messages.
  OFPT_PACKET_OUT = 13,  # Controller/switch message.
  OFPT_FLOW_MOD = 14,  # Controller/switch message.
  OFPT_GROUP_MOD = 15,  # Controller/switch message.
  OFPT_PORT_MOD = 16,  # Controller/switch message.
  OFPT_TABLE_MOD = 17,  # Controller/switch message.

  # Statistics messages.
  OFPT_STATS_REQUEST = 18,  # Controller/switch message.
  OFPT_STATS_REPLY = 19,  # Controller/switch message.

  # Barrier messages.
  OFPT_BARRIER_REQUEST = 20,  # Controller/switch message.
  OFPT_BARRIER_REPLY = 21,  # Controller/switch message.

  # Queue Configuration messages.
  OFPT_QUEUE_GET_CONFIG_REQUEST = 22,  # Controller/switch message.
  OFPT_QUEUE_GET_CONFIG_REPLY = 23,  # Controller/switch message.

  # Controller role change request messages.
  OFPT_ROLE_REQUEST = 24,  # Controller/switch message.
  OFPT_ROLE_REPLY = 25  # Controller/switch message.
}

@type_selector(version = openflow.OpenflowVersions.OPENFLOW_1_2)
packet OpenflowHeaderV12(openflow.OpenflowHeader) {
}

@type_selector(version = openflow.OpenflowVersions.OPENFLOW_1_2)
packet OpenflowHello(openflow.OpenflowHello) {
}

@type_selector(type = openflow.OpenflowType.OFPT_ECHO_REQUEST)
packet OpenflowEchoRequest(OpenflowHeaderV12) {
}

@type_selector(type = openflow.OpenflowType.OFPT_ECHO_REPLY)
packet OpenflowEchoReply(OpenflowHeaderV12) {
}

@type_selector(type = openflow.OpenflowType.OFPT_FEATURES_REQUEST)
packet OpenflowFeaturesRequest(OpenflowHeaderV12) {
}

# Get switch configuration.
@type_selector(type = openflow.OpenflowType.OFPT_GET_CONFIG_REQUEST)
packet OpenflowGetConfigRequest(OpenflowHeaderV12) {
}

enum OpenflowConfigFlags {
  # Handling of IP fragments.
  OFPC_FRAG_NORMAL = 0,  # No special handling for fragments.
  OFPC_FRAG_DROP = 1,    # Drop fragments.
  OFPC_FRAG_REASM = 2,   # Reassemble (only if OFPC_IP_REASM set).
  OFPC_FRAG_MASK = 3,

  # TTL processing - applicable for IP and MPLS packets.
  OFPC_INVALID_TTL_TO_CONTROLLER = 1 << 2
}

# Config request reply.
@type_selector(type = openflow.OpenflowType.OFPT_GET_CONFIG_REPLY)
packet OpenflowSwitchGetConfigReply(OpenflowHeaderV12) {
  uint16 flags;          # OFPC_* flags.
  uint16 miss_send_len;  # Max bytes of new flow that datapath should
                         # send to the controller.
}

# Set switch config.
@type_selector(type = openflow.OpenflowType.OFPT_SET_CONFIG)
packet OpenflowSwitchSetConfig(OpenflowHeaderV12) {
  uint16 flags;          # OFPC_* flags.
  uint16 miss_send_len;  # Max bytes of new flow that datapath should
                         # send to the controller.
}

# Capabilities supported by the datapath.
enum OpenflowCapabilities {
  OFPC_FLOW_STATS = 1,      # Flow statistics.
  OFPC_TABLE_STATS = 2,     # Table statistics.
  OFPC_PORT_STATS = 4,      # Port statistics.
  OFPC_STP = 8,             # 802.1d spanning tree.
  OFPC_RESERVED = 16,       # Reserved, must be zero.
  OFPC_IP_REASM = 32,       # Can reassemble IP fragments.
  OFPC_QUEUE_STATS = 64,    # Queue statistics.
  OFPC_ARP_MATCH_IP = 128   # Match IP addresses in ARP pkts.
}

# Flags to indicate behavior of the physical port. These flags are
# used in OpenflowPort to describe the current configuration. They are
# used in the ofp_port_mod message to configure the port's behavior.
enum OpenflowPortConfig {
  OFPPC_PORT_DOWN = 1 << 0,
  OFPPC_NO_RECV = 1 << 2,
  OFPPC_NO_FWD = 1 << 5,
  OFPPC_NO_PACKET_IN = 1 << 6
}

# Current state of the physical port.  These are not configurable from
# the controller.
enum OpenflowPortState {
  OFPPS_LINK_DOWN = 1 << 0,  # No physical link present.
  OFPPS_BLOCKED = 1 << 1,  # Port is blocked.
  OFPPS_LIVE = 1 << 2  # Live for fast failover group.
}

# Features of physical ports available in a datapath.
enum OpenflowPortFeatures {
  OFPPF_10MB_HD = 1 << 0,  # 10 Mb half-duplex rate support.
  OFPPF_10MB_FD = 1 << 1,  # 10 Mb full-duplex rate support.
  OFPPF_100MB_HD = 1 << 2,  # 100 Mb half-duplex rate support.
  OFPPF_100MB_FD = 1 << 3,  # 100 Mb full-duplex rate support.
  OFPPF_1GB_HD = 1 << 4,  # 1 Gb half-duplex rate support.
  OFPPF_1GB_FD = 1 << 5,  # 1 Gb full-duplex rate support.
  OFPPF_10GB_FD = 1 << 6,  # 10 Gb full-duplex rate support.
  OFPPF_40GB_FD = 1 << 7,  # 40 Gb full-duplex rate support.
  OFPPF_100GB_FD = 1 << 8,  # 100 Gb full-duplex rate support.
  OFPPF_1TB_FD = 1 << 9,  # 1 Tb full-duplex rate support.
  OFPPF_OTHER = 1 << 10,  # Other rate, not in the list.

  OFPPF_COPPER = 1 << 11,  # Copper medium.
  OFPPF_FIBER = 1 << 12,  # Fiber medium.
  OFPPF_AUTONEG = 1 << 13,  # Auto-negotiation.
  OFPPF_PAUSE = 1 << 14,  # Pause.
  OFPPF_PAUSE_ASYM = 1 << 15  # Asymmetric pause.
}

# Represents a switch port.
@bigendian
packet OpenflowPort {
  uint32 port_no;
  @repeated(count = 4) uint8 pad;

  @repeated(count = openflow.OpenflowConstants.OFP_ETH_ALEN)
  uint8 hw_addr;
  @repeated(count = 2) uint8 pad2;

  @repeated(count = openflow.OpenflowConstants.OFP_MAX_PORT_NAME_LEN)
  char name;

  uint32 config;
  uint32 state;

  uint32 curr;
  uint32 advertised;
  uint32 supported;
  uint32 peer;

  uint32 curr_speed;
  uint32 max_speed;
}

@type_selector(type = openflow.OpenflowType.OFPT_FEATURES_REPLY)
packet OpenflowFeaturesReply(OpenflowHeaderV12) {
  uint64 datapath_id;
  uint32 n_buffers;

  uint8 n_tables;
  @repeated(count = 3) uint8 pad;

  # Features.
  uint32 capabilities;
  uint32 actions;

  # Port info.
  @repeated OpenflowPort ports;
}

# What changed about the physical port.
enum OpenflowPortReason {
  OFPPR_ADD = 0,              # The port was added.
  OFPPR_DELETE = 1,           # The port was removed.
  OFPPR_MODIFY = 2            # Some attribute of the port has changed.
}

@type_selector(type = Openflow12Type.OFPT_PORT_STATUS)
packet OpenflowPortStatus(OpenflowHeaderV12) {
  uint8 reason;  # Set from OpenflowPortReason.
  @repeated(count = 7) uint8 pad;
  OpenflowPort desc;
}

# Modify behavior of the physical port.
@type_selector(type = Openflow12Type.OFPT_PORT_MOD)
packet OpenflowPortMod(OpenflowHeaderV12) {
  uint16 port_no;
  @repeated(count = 6) uint8 hw_addr;  # The hardware address is not
                                    # configurable.  This is used to
                                    # sanity-check the request, so it must
                                    # be the same as returned in an
                                    # OpenflowPort packet.
  uint32 config;  # Bitmap of OFPPC_* flags.
  uint32 mask;  # Bitmap of OFPPC_* flags to be changed.

  uint32 advertise;  # Bitmap of "OpenflowPortFeatures"s.  Zero all
                     # bits to prevent any action taking place.
  @repeated(count = 4) uint8 pad;  # Pad to 64-bits.
}

# Why is this packet being sent to the controller?
enum OpenflowPacketInReason {
  OFPR_NO_MATCH = 0,          # No matching flow.
  OFPR_ACTION = 1             # Action explicitly output to controller.
}

# Packet received on port (datapath -> controller).
@type_selector(type = Openflow12Type.OFPT_PACKET_IN)
packet OpenflowPacketIn(OpenflowHeaderV12) {
  uint32 buffer_id;     # ID assigned by datapath.
  uint16 total_len;     # Full length of frame.
  uint16 in_port;       # Port on which frame was received.
  uint8 reason;         # Reason packet is being sent (one of OFPR_*)
  uint8 pad;

  @repeated
  uint8 data;           # Ethernet frame, halfway through 32-bit word,
                        # so the IP header is 32-bit aligned.  The
                        # amount of data is inferred from the length
                        # field in the header.  Because of padding,
                        # offsetof(packet OpenflowPacketIn, data) ==
                        # sizeof(packet OpenflowPacketIn) - 2.
}

enum OpenflowActionType {
  OFPAT_OUTPUT = 0,
  OFPAT_COPY_TTL_OUT = 11,
  OFPAT_COPY_TTL_IN  = 12,
  OFPAT_SET_MPLS_TTL = 15,
  OFPAT_DEC_MPLS_TTL = 16,
  OFPAT_PUSH_VLAN = 17,
  OFPAT_POP_VLAN = 18,
  OFPAT_PUSH_MPLS = 19,
  OFPAT_POP_MPLS = 20,
  OFPAT_SET_QUEUE = 21,
  OFPAT_GROUP = 22,
  OFPAT_SET_NW_TTL = 23,
  OFPAT_DEC_NW_TTL = 24,
  OFPAT_SET_FIELD = 25,

  OFPAT_EXPERIMENTER = 0xffff
}

# Action header that is common to all actions.  The length includes the
# header and any padding used to make the action 64-bit aligned.
# NB: The length of an action *must* always be a multiple of eight.
@bigendian
packet OpenflowAction {
  uint16 type;  # One of OFPAT_*.
  @size
  uint16 len;   # Length of action, including this
                # header.  This is the length of action,
                # including any padding to make it
                # 64-bit aligned.
}

# Action packeture for OFPAT_OUTPUT, which sends packets out 'port'.
# When the 'port' is the OFPP_CONTROLLER, 'max_len' indicates the max
# number of bytes to send.  A 'max_len' of zero means no bytes of the
# packet should be sent.
@type_selector(type = OpenflowActionType.OFPAT_OUTPUT)
packet OpenflowActionOutput(OpenflowAction) {
  uint32 port;     # Output port.
  uint16 max_len;  # Max length to send to controller.
  @repeated(count = 6) uint8 pad;
}

enum OpenflowInstructionType {
  OFPIT_GOTO_TABLE = 1,
  OFPIT_WRITE_METADATA = 2,
  OFPIT_WRITE_ACTIONS = 3,
  OFPIT_APPLY_ACTIONS = 4,
  OFPIT_CLEAR_ACTIONS = 5,
  OFPIT_EXPERIMENTER = 0xFFFF
}

@bigendian
packet OpenflowInstruction {
  uint16 type;
  @size uint16 len;
}

@type_selector(type = OpenflowInstructionType.OFPIT_APPLY_ACTIONS)
packet OpenflowApplyActions(OpenflowInstruction) {
  @repeated(count = 4) uint8 pad;
  @repeated OpenflowAction actions;
}

enum OpenflowBuffers {
  OFP_NO_BUFFER=0xffffffff
}

# Send packet (controller -> datapath).
@type_selector(type = Openflow12Type.OFPT_PACKET_OUT)
packet OpenflowPacketOut(OpenflowHeaderV12) {
  uint32 buffer_id;           # ID assigned by datapath (-1 if none).
  uint32 in_port;             # Packet's input port (OFPP_NONE if none).
  @size(actions)
  uint16 actions_len;         # Size of action array in bytes.
  @repeated(count = 6) uint8 pad;
  @repeated
  OpenflowAction actions;
  @repeated uint8 data;        # Packet data.  The length is inferred
                               # from the length field in the header.
                               # (Only meaningful if buffer_id == -1.)
}

enum OpenflowFlowModCommand {
  OFPFC_ADD = 0,              # New flow.
  OFPFC_MODIFY = 1,           # Modify all matching flows.
  OFPFC_MODIFY_STRICT = 2,    # Modify entry strictly matching wildcards
  OFPFC_DELETE = 3,           # Delete all matching flows.
  OFPFC_DELETE_STRICT = 4     # Strictly match wildcards and priority.
}

# Flow wildcards.
enum OpenflowFlowWildcards {
  OFPFW_IN_PORT  = 1 << 0,  # Switch input port.
  OFPFW_DL_VLAN  = 1 << 1,  # VLAN id.
  OFPFW_DL_SRC   = 1 << 2,  # Ethernet source address.
  OFPFW_DL_DST   = 1 << 3,  # Ethernet destination address.
  OFPFW_DL_TYPE  = 1 << 4,  # Ethernet frame type.
  OFPFW_NW_PROTO = 1 << 5,  # IP protocol.
  OFPFW_TP_SRC   = 1 << 6,  # TCP/UDP source port.
  OFPFW_TP_DST   = 1 << 7,  # TCP/UDP destination port.

  # IP source address wildcard bit count.  0 is exact match, 1 ignores the
  #  LSB, 2 ignores the 2 least-significant bits, ..., 32 and higher wildcard
  #  the entire field.  This is the *opposite* of the usual convention where
  # e.g. /24 indicates that 8 bits (not 24 bits) are wildcarded.
  OFPFW_NW_SRC_SHIFT = 8,
  OFPFW_NW_SRC_BITS = (6 - 1),
  OFPFW_NW_SRC_MASK = ((1 << OpenflowFlowWildcards.OFPFW_NW_SRC_BITS) - 1) <<
      OpenflowFlowWildcards.OFPFW_NW_SRC_SHIFT,
  OFPFW_NW_SRC_ALL = 32 << OpenflowFlowWildcards.OFPFW_NW_SRC_SHIFT,

  # IP destination address wildcard bit count.  Same format as source.
  OFPFW_NW_DST_SHIFT = 14,
  OFPFW_NW_DST_BITS = 6,
  OFPFW_NW_DST_MASK = ((1 << OpenflowFlowWildcards.OFPFW_NW_DST_BITS) - 1) <<
      OpenflowFlowWildcards.OFPFW_NW_DST_SHIFT,
  OFPFW_NW_DST_ALL = 32 << OpenflowFlowWildcards.OFPFW_NW_DST_SHIFT,

  OFPFW_DL_VLAN_PCP = 1 << 20,  # VLAN priority.
  OFPFW_NW_TOS = 1 << 21,  # IP ToS (DSCP field, 6 bits).

  # Wildcard all fields.
  OFPFW_ALL = ((1 << 22) - 1)
}

enum OpenflowMatchType {
  OFPMT_STANDARD = 0,
  OFPMT_OXM = 1
}

enum OpenflowOxmClass {
  OFPXMC_NXM_0 = 0x0000,
  OFPXMC_NXM_1 = 0x0001,
  OFPXMC_OPENFLOW_BASIC = 0x8000,
  OFPXMC_EXPERIMENTER = 0xFFFF
}

enum OpenflowOxmMatchFields {
  OFPXMT_OFB_IN_PORT = 0,  # Switch input port.
  OFPXMT_OFB_IN_PHY_PORT = 1 << 1,  # Switch physical input port.

  OFPXMT_OFB_METADATA = 2 << 1,  # Metadata passed between tables.

  OFPXMT_OFB_ETH_DST = 3 << 1,  # Ethernet destination address.
  OFPXMT_OFB_ETH_DST_MASKED = (3 << 1) + 1,

  OFPXMT_OFB_ETH_SRC = 4 << 1,  # Ethernet source address.
  OFPXMT_OFB_ETH_SRC_MASKED = (4 << 1) + 1,

  OFPXMT_OFB_ETH_TYPE = 5 << 1,  # Ethernet frame type.

  OFPXMT_OFB_VLAN_VID = 6 << 1,  # VLAN id.
  OFPXMT_OFB_VLAN_PCP = 7 << 1,  # VLAN priority.
  OFPXMT_OFB_IP_DSCP = 8 << 1,  # IP DSCP (6 bits in ToS field).
  OFPXMT_OFB_IP_ECN = 9 << 1,  # IP ECN (2 bits in ToS field).
  OFPXMT_OFB_IP_PROTO = 10 << 1,  # IP protocol.

  OFPXMT_OFB_IPV4_SRC = 11 << 1,  # IPv4 source address.
  OFPXMT_OFB_IPV4_SRC_MASKED = (11 << 1) + 1,

  OFPXMT_OFB_IPV4_DST = 12 << 1,  # IPv4 destination address.
  OFPXMT_OFB_IPV4_DST_MASKED = (12 << 1) + 1,

  OFPXMT_OFB_TCP_SRC = 13 << 1,  # TCP source port.
  OFPXMT_OFB_TCP_DST = 14 << 1,  # TCP destination port.
  OFPXMT_OFB_UDP_SRC = 15 << 1,  # UDP source port.
  OFPXMT_OFB_UDP_DST = 16 << 1,  # UDP destination port.
  OFPXMT_OFB_SCTP_SRC = 17 << 1,  # SCTP source port.
  OFPXMT_OFB_SCTP_DST = 18 << 1,  # SCTP destination port.
  OFPXMT_OFB_ICMPV4_TYPE = 19 << 1,  # ICMP type.
  OFPXMT_OFB_ICMPV4_CODE = 20 << 1,  # ICMP code.
  OFPXMT_OFB_ARP_OP = 21 << 1,  # ARP opcode.
  OFPXMT_OFB_ARP_SPA = 22 << 1,  # ARP source IPv4 address.
  OFPXMT_OFB_ARP_TPA = 23 << 1,  # ARP target IPv4 address.
  OFPXMT_OFB_ARP_SHA = 24 << 1,  # ARP source hardware address.
  OFPXMT_OFB_ARP_THA = 25 << 1,  # ARP target hardware address.
  OFPXMT_OFB_IPV6_SRC = 26 << 1,  # IPv6 source address.
  OFPXMT_OFB_IPV6_DST = 27 << 1,  # IPv6 destination address.
  OFPXMT_OFB_IPV6_FLABEL = 28 << 1,  # IPv6 Flow Label
  OFPXMT_OFB_ICMPV6_TYPE = 29 << 1,  # ICMPv6 type.
  OFPXMT_OFB_ICMPV6_CODE = 30 << 1,  # ICMPv6 code.
  OFPXMT_OFB_IPV6_ND_TARGET = 31 << 1,  # Target address for ND.
  OFPXMT_OFB_IPV6_ND_SLL = 32 << 1,  # Source link-layer for ND.
  OFPXMT_OFB_IPV6_ND_TLL = 33 << 1,  # Target link-layer for ND.
  OFPXMT_OFB_MPLS_LABEL = 34 << 1,  # MPLS label.
  OFPXMT_OFB_MPLS_TC = 35 << 1  # MPLS TC.
}

@bigendian
packet OpenflowOxmField {
  uint16 oxm_class;
  uint8 oxm_field;
  uint8 oxm_length;
}

@type_selector(oxm_class = OpenflowOxmClass.OFPXMC_OPENFLOW_BASIC,
               oxm_field = OpenflowOxmMatchFields.OFPXMT_OFB_IN_PORT,
               oxm_length = 4)
packet OpenflowOxmInPort(OpenflowOxmField) {
  uint32 in_port;
}

@type_selector(oxm_class = OpenflowOxmClass.OFPXMC_OPENFLOW_BASIC,
               oxm_field = OpenflowOxmMatchFields.OFPXMT_OFB_ETH_DST,
               oxm_length = 6)
packet OpenflowOxmEthDst(OpenflowOxmField) {
  @repeated(count = openflow.OpenflowConstants.OFP_ETH_ALEN)
  uint8 mac_addr;
}

@type_selector(oxm_class = OpenflowOxmClass.OFPXMC_OPENFLOW_BASIC,
               oxm_field = OpenflowOxmMatchFields.OFPXMT_OFB_ETH_DST_MASKED,
               oxm_length = 12)
packet OpenflowOxmEthDstMasked(OpenflowOxmField) {
  @repeated(count = openflow.OpenflowConstants.OFP_ETH_ALEN)
  uint8 mac_addr;

  @repeated(count = openflow.OpenflowConstants.OFP_ETH_ALEN)
  uint8 mask;
}

@type_selector(oxm_class = OpenflowOxmClass.OFPXMC_OPENFLOW_BASIC,
               oxm_field = OpenflowOxmMatchFields.OFPXMT_OFB_ETH_SRC,
               oxm_length = 6)
packet OpenflowOxmEthSrc(OpenflowOxmField) {
  @repeated(count = openflow.OpenflowConstants.OFP_ETH_ALEN)
  uint8 mac_addr;
}

@type_selector(oxm_class = OpenflowOxmClass.OFPXMC_OPENFLOW_BASIC,
               oxm_field = OpenflowOxmMatchFields.OFPXMT_OFB_ETH_SRC_MASKED,
               oxm_length = 12)
packet OpenflowOxmEthSrcMasked(OpenflowOxmField) {
  @repeated(count = openflow.OpenflowConstants.OFP_ETH_ALEN)
  uint8 mac_addr;

  @repeated(count = openflow.OpenflowConstants.OFP_ETH_ALEN)
  uint8 mask;
}

# Fields to match against flows
@bigendian
@padded(multiple = 8, excluded = 1)
packet OpenflowMatch {
  uint16 type;
  @size uint16 length;
  @repeated OpenflowOxmField oxm_fields;
}

enum OpenflowFlowModFlags {
  OFPFF_SEND_FLOW_REM = 1 << 0,  # Send flow removed message when flow
                                 # expires or is deleted.
  OFPFF_CHECK_OVERLAP = 1 << 1,  # Check for overlapping entries first.
  OFPFF_EMERG         = 1 << 2   # Remark this is for emergency.
}

# Flow setup and teardown (controller -> datapath).
@type_selector(type = Openflow12Type.OFPT_FLOW_MOD)
packet OpenflowFlowMod(OpenflowHeaderV12) {
  uint64 cookie;
  uint64 cookie_mask;

  uint8 table_id;
  uint8 command;
  uint16 idle_timeout;
  uint16 hard_timeout;
  uint16 priority;
  uint32 buffer_id;
  uint32 out_port;
  uint32 out_group;
  uint16 flags;

  @repeated(count = 2) uint8 pad;

  OpenflowMatch match;
  @repeated
  OpenflowInstruction instructions;
}

# Why was this flow removed?
enum OpenflowFlowRemovedReason {
  OFPRR_IDLE_TIMEOUT = 0,         # Flow idle time exceeded idle_timeout.
  OFPRR_HARD_TIMEOUT = 1,         # Time exceeded hard_timeout.
  OFPRR_DELETE = 2                # Evicted by a DELETE flow mod.
}

# Flow removed (datapath -> controller).
@type_selector(type = Openflow12Type.OFPT_FLOW_REMOVED)
packet OpenflowFlowRemoved(OpenflowHeaderV12) {
  OpenflowMatch match;    # Description of fields.
  uint64 cookie;          # Opaque controller-issued identifier.

  uint16 priority;        # Priority level of flow entry.
  uint8 reason;           # One of OFPRR_*.
  @repeated(count = 1)
  uint8 pad;              # Align to 32-bits.

  uint32 duration_sec;    # Time flow was alive in seconds.
  uint32 duration_nsec;   # Time flow was alive in nanoseconds beyond
                          # duration_sec.
  uint16 idle_timeout;    # Idle timeout from original flow mod.
  @repeated(count = 2)
  uint8 pad2;             # Align to 64-bits.
  uint64 packet_count;
  uint64 byte_count;
}

# Values for 'type' in OpenflowErrorMessage.  These values are immutable: they
# will not change in future versions of the protocol (although new values may
# be added).
enum OpenflowErrorType {
  OFPET_HELLO_FAILED = 0,         # Hello protocol failed.
  OFPET_BAD_REQUEST = 1,          # Request was not understood.
  OFPET_BAD_ACTION = 2,           # Error in action description.
  OFPET_FLOW_MOD_FAILED = 3,      # Problem modifying flow entry.
  OFPET_PORT_MOD_FAILED = 4,      # Port mod request failed.
  OFPET_QUEUE_OP_FAILED = 5       # Queue operation failed.
}

# OpenflowErrorMsg 'code' values for OFPET_HELLO_FAILED.  'data' contains an
# ASCII text string that may give failure details.
enum OpenflowHelloFailedCode {
  OFPHFC_INCOMPATIBLE = 0,        # No compatible version.
  OFPHFC_EPERM = 1                # Permissions error.
}

# OpenflowErrorMsg 'code' values for OFPET_BAD_REQUEST.  'data' contains at least
# the first 64 bytes of the failed request.
enum OpenflowBadRequestCode {
  OFPBRC_BAD_VERSION = 0,         # ofp_header.version not supported.
  OFPBRC_BAD_TYPE = 1,            # ofp_header.type not supported.
  OFPBRC_BAD_STAT = 2,            # OpenflowStatsRequest.type not supported.
  OFPBRC_BAD_VENDOR = 3,          # Vendor not supported (in OpenflowVendorHeader
                                  # or OpenflowStatsRequest or OpenflowStatsReply).
  OFPBRC_BAD_SUBTYPE = 4,         # Vendor subtype not supported.
  OFPBRC_EPERM = 5,               # Permissions error.
  OFPBRC_BAD_LEN = 6,             # Wrong request length for type.
  OFPBRC_BUFFER_EMPTY = 7,        # Specified buffer has already been used.
  OFPBRC_BUFFER_UNKNOWN = 8       # Specified buffer does not exist.
}

# OpenflowErrorMsg 'code' values for OFPET_BAD_ACTION.  'data' contains at least
# the first 64 bytes of the failed request.
enum OpenflowBadActionCode {
  OFPBAC_BAD_TYPE = 0,           # Unknown action type.
  OFPBAC_BAD_LEN = 1,            # Length problem in actions.
  OFPBAC_BAD_VENDOR = 2,         # Unknown vendor id specified.
  OFPBAC_BAD_VENDOR_TYPE = 3,    # Unknown action type for vendor id.
  OFPBAC_BAD_OUT_PORT = 4,       # Problem validating output action.
  OFPBAC_BAD_ARGUMENT = 5,       # Bad action argument.
  OFPBAC_EPERM = 6,              # Permissions error.
  OFPBAC_TOO_MANY = 7,           # Can't handle this many actions.
  OFPBAC_BAD_QUEUE = 8           # Problem validating output queue.
}

# OpenflowErrorMsg 'code' values for OFPET_FLOW_MOD_FAILED.  'data' contains
# at least the first 64 bytes of the failed request.
enum OpenflowFlow_modFailedCode {
  OFPFMFC_ALL_TABLES_FULL = 0,    # Flow not added because of full tables.
  OFPFMFC_OVERLAP = 1,            # Attempted to add overlapping flow with
                                  # CHECK_OVERLAP flag set.
  OFPFMFC_EPERM = 2,              # Permissions error.
  OFPFMFC_BAD_EMERG_TIMEOUT = 3,  # Flow not added because of non-zero idle/hard
                                  # timeout.
  OFPFMFC_BAD_COMMAND = 4,        # Unknown command.
  OFPFMFC_UNSUPPORTED = 5         # Unsupported action list - cannot process in
                                  # the order specified.
}

# OpenflowErrorMsg 'code' values for OFPET_PORT_MOD_FAILED.  'data' contains
# at least the first 64 bytes of the failed request.
enum OpenflowPort_modFailedCode {
  OFPPMFC_BAD_PORT = 0,            # Specified port does not exist.
  OFPPMFC_BAD_HW_ADDR = 1          # Specified hardware address is wrong.
}

# ofp_error msg 'code' values for OFPET_QUEUE_OP_FAILED. 'data' contains
# at least the first 64 bytes of the failed request
enum OpenflowQueueOpFailedCode {
  OFPQOFC_BAD_PORT = 0,           # Invalid port (or port does not exist).
  OFPQOFC_BAD_QUEUE = 1,          # Queue does not exist.
  OFPQOFC_EPERM = 2               # Permissions error.
}

# OFPT_ERROR: Error message (datapath -> controller).
@type_selector(type = openflow.OpenflowType.OFPT_ERROR)
packet OpenflowErrorMsg(OpenflowHeaderV12) {
  uint16 err_type;
  uint16 code;
  @repeated
  uint8 data;  # Variable-length data.  Interpreted based
               # on the type and code.
}

enum OpenflowStatsTypes {
  # Description of this OpenFlow switch.
  # The request body is empty.
  # The reply body is packet OpenflowDescStats.
  OFPST_DESC = 0,

  # Individual flow statistics.
  # The request body is packet OpenflowFlowStatsRequest.
  # The reply body is an array of packet OpenflowFlowStats.
  OFPST_FLOW = 1,

  # Aggregate flow statistics.
  # The request body is packet OpenflowAggregateStatsRequest.
  # The reply body is packet OpenflowAggregateStatsReply.
  OFPST_AGGREGATE = 2,

  # Flow table statistics.
  # The request body is empty.
  # The reply body is an array of packet OpenflowTableStats.
  OFPST_TABLE = 3,

  # Physical port statistics.
  # The request body is packet OpenflowPortStatsRequest.
  # The reply body is an array of packet OpenflowPortStats.
  OFPST_PORT = 4,

  # Queue statistics for a port
  # The request body defines the port
  # The reply body is an array of packet OpenflowQueueStats
  OFPST_QUEUE = 5,

  # Vendor extension.
  # The request and reply bodies begin with a 32-bit vendor ID, which takes
  # the same form as in "packet OpenflowVendorHeader".  The request and reply
  # bodies are otherwise vendor-defined.
  OFPST_VENDOR = 0xffff
}

@type_selector(type = Openflow12Type.OFPT_STATS_REQUEST)
packet OpenflowStatsRequest(OpenflowHeaderV12) {
  uint16 stats_type;        # One of the OFPST_* constants.
  uint16 flags;             # OFPSF_REQ_* flags (none yet defined).
}

enum OpenflowStatsReplyFlags {
  OFPSF_REPLY_MORE  = 1 << 0  # More replies to follow.
}

@type_selector(type = Openflow12Type.OFPT_STATS_REPLY)
packet OpenflowStatsReply(OpenflowHeaderV12) {
  uint16 stats_type;  # One of the OFPST_* constants.
  uint16 flags;       # OFPSF_REPLY_* flags.
}

enum OpenflowDescStatsConstants {
  SERIAL_NUM_LEN = 32,
  DESC_STR_LEN = 256
}

#define DESC_STR_LEN   256
#define SERIAL_NUM_LEN 32
# Body of reply to OFPST_DESC request.  Each entry is a NULL-terminated
# ASCII string.
@type_selector(stats_type = OpenflowStatsTypes.OFPST_DESC)
packet OpenflowDescStats(OpenflowStatsReply) {
  @repeated(count = OpenflowDescStatsConstants.DESC_STR_LEN)
  char mfr_desc;  # Manufacturer description.
  @repeated(count = OpenflowDescStatsConstants.DESC_STR_LEN)
  char hw_desc;  # Hardware description.
  @repeated(count = OpenflowDescStatsConstants.DESC_STR_LEN)
  char sw_desc;  # Software description.
  @repeated(count = OpenflowDescStatsConstants.SERIAL_NUM_LEN)
  char serial_num;   # Serial number.
  @repeated(count = OpenflowDescStatsConstants.DESC_STR_LEN)
  char dp_desc;  # Human readable description of datapath.
}

# Body for OpenflowStatsRequest of type OFPST_FLOW.
@type_selector(stats_type = OpenflowStatsTypes.OFPST_FLOW)
packet OpenflowFlowStatsRequest(OpenflowStatsRequest) {
  OpenflowMatch match;  # Fields to match.
  uint8 table_id;       # ID of table to read (from OpenflowTableStats),
                        # 0xff for all tables or 0xfe for emergency.
  uint8 pad;            # Align to 32 bits.
  uint16 out_port;      # Require matching entries to include this
                        # as an output port.  A value of OFPP_NONE
                        # indicates no restriction.
}

# The Openflow flow stats.
@bigendian
packet OpenflowFlowStats {
  @size
  uint16 length;          # Length of this entry.
  uint8 table_id;         # ID of table flow came from.
  uint8 pad;
  OpenflowMatch match;    # Description of fields.
  uint32 duration_sec;    # Time flow has been alive in seconds.
  uint32 duration_nsec;   # Time flow has been alive in nanoseconds beyond
                          # duration_sec.
  uint16 priority;        # Priority of the entry. Only meaningful
                          # when this is not an exact-match entry.
  uint16 idle_timeout;    # Number of seconds idle before expiration.
  uint16 hard_timeout;    # Number of seconds before expiration.
  @repeated(count = 6)
  uint8 pad2;             # Align to 64-bits.
  uint64 cookie;          # Opaque controller-issued identifier.
  uint64 packet_count;    # Number of packets in flow.
  uint64 byte_count;      # Number of bytes in flow.

  @repeated
  OpenflowAction actions; # Actions.
}

# Body of reply to OFPST_FLOW request.
@type_selector(stats_type = OpenflowStatsTypes.OFPST_FLOW)
packet OpenflowFlowStatsReply(OpenflowStatsReply) {
  @repeated
  OpenflowFlowStats flow_stats;
}

# Body for OpenflowStatsRequest of type OFPST_AGGREGATE.
@type_selector(stats_type = OpenflowStatsTypes.OFPST_AGGREGATE)
packet OpenflowAggregateStatsRequest(OpenflowStatsRequest) {
  OpenflowMatch match;    # Fields to match.
  uint8 table_id;         # ID of table to read (from OpenflowTableStats)
                          # 0xff for all tables or 0xfe for emergency.
  uint8 pad;              # Align to 32 bits.
  uint16 out_port;        # Require matching entries to include this
                          # as an output port.  A value of OFPP_NONE
                          # indicates no restriction.
}

# Body of reply to OFPST_AGGREGATE request.
@type_selector(stats_type = OpenflowStatsTypes.OFPST_AGGREGATE)
packet OpenflowAggregateStatsReply(OpenflowStatsReply) {
  uint64 packet_count;    # Number of packets in flows.
  uint64 byte_count;      # Number of bytes in flows.
  uint32 flow_count;      # Number of flows.
  @repeated(count = 4)
  uint8 pad;              # Align to 64 bits.
}

# Body of reply to OFPST_TABLE request.
@type_selector(stats_type = OpenflowStatsTypes.OFPST_TABLE)
packet OpenflowTableStats(OpenflowStatsReply) {
  uint8 table_id;        # Identifier of table.  Lower numbered tables
                         # are consulted first.
  @repeated(count = 3)
  uint8 pad;             # Align to 32-bits.
  @repeated(count = openflow.OpenflowConstants.OFP_MAX_TABLE_NAME_LEN)
  char name;
  uint32 wildcards;      # Bitmap of OFPFW_* wildcards that are
                         # supported by the table.
  uint32 max_entries;    # Max number of entries supported.
  uint32 active_count;   # Number of active entries.
  uint64 lookup_count;   # Number of packets looked up in table.
  uint64 matched_count;  # Number of packets that hit table.
}

# Body for OpenflowStatsRequest of type OFPST_PORT.
@type_selector(stats_type = OpenflowStatsTypes.OFPST_PORT)
packet OpenflowPortStatsRequest(OpenflowStatsRequest) {
  uint16 port_no;        # OFPST_PORT message must request statistics
                         # either for a single port (specified in
                         # port_no) or for all ports (if port_no ==
                         # OFPP_NONE).
  @repeated(count = 6)
  uint8 pad;
}

# Body of reply to OFPST_PORT request. If a counter is unsupported, set
# the field to all ones.
@type_selector(stats_type = OpenflowStatsTypes.OFPST_PORT)
packet OpenflowPortStats(OpenflowStatsReply) {
  uint16 port_no;
  @repeated(count = 6)
  uint8 pad;             # Align to 64-bits.
  uint64 rx_packets;     # Number of received packets.
  uint64 tx_packets;     # Number of transmitted packets.
  uint64 rx_bytes;       # Number of received bytes.
  uint64 tx_bytes;       # Number of transmitted bytes.
  uint64 rx_dropped;     # Number of packets dropped by RX.
  uint64 tx_dropped;     # Number of packets dropped by TX.
  uint64 rx_errors;      # Number of receive errors.  This is a super-set
                         # of more specific receive errors and should be
                         # greater than or equal to the sum of all
                         # rx_*_err values.
  uint64 tx_errors;      # Number of transmit errors.  This is a super-set
                         # of more specific transmit errors and should be
                         # greater than or equal to the sum of all
                         # tx_*_err values (none currently defined.)
  uint64 rx_frame_err;   # Number of frame alignment errors.
  uint64 rx_over_err;    # Number of packets with RX overrun.
  uint64 rx_crc_err;     # Number of CRC errors.
  uint64 collisions;     # Number of collisions.
}

# Vendor extension.
@type_selector(type = openflow.OpenflowType.OFPT_VENDOR)
packet OpenflowVendorHeader(OpenflowHeaderV12) {
  uint32 vendor;  # Vendor ID:
                  # - MSB 0: low-order bytes are IEEE OUI.
                  # - MSB != 0: defined by OpenFlow
                  #   consortium.
  # Vendor-defined arbitrary additional data.
}

# All ones is used to indicate all queues in a port (for stats retrieval).
#define OFPQ_ALL      0xffffffff

# Min rate > 1000 means not configured.
#define OFPQ_MIN_RATE_UNCFG      0xffff

enum OpenflowQueueProperties {
  OFPQT_NONE = 0,       # No property defined for queue (default).
  OFPQT_MIN_RATE = 1    # Minimum datarate guaranteed.
                        # Other types should be added here
                        # (i.e. max rate, precedence, etc).
}

# Common description for a queue.
@bigendian
packet OpenflowQueuePropHeader {
  uint16 property;    # One of OFPQT_.
  @size
  uint16 len;         # Length of property, including this header.
  @repeated(count = 4)
  uint8 pad;          # 64-bit alignemnt.
}

# Min-Rate queue property description.
@type_selector(property = OpenflowQueueProperties.OFPQT_MIN_RATE)
packet OpenflowQueuePropMinRate(OpenflowQueuePropHeader) {
  uint16 rate;        # In 1/10 of a percent; >1000 -> disabled.
  @repeated(count = 6)
  uint8 pad;          # 64-bit alignment
}

# Full description for a queue.
@bigendian
packet OpenflowPacketQueue {
  uint32 queue_id;     # id for the specific queue.
  @size
  uint16 len;          # Length in bytes of this queue desc.
  @repeated(count = 2)
  uint8 pad;        # 64-bit alignment.
  @repeated
  OpenflowQueuePropHeader properties; # List of properties.
}

# Query for port queue configuration.
@type_selector(type = Openflow12Type.OFPT_QUEUE_GET_CONFIG_REPLY)
packet OpenflowQueueGetConfigRequest(OpenflowHeaderV12) {
  uint16 port;  # Port to be queried. Should refer
                # to a valid physical port (i.e. < OFPP_MAX)
  @repeated
  uint8 pad;    # 32-bit alignment.
}

# Queue configuration for a given port.
@type_selector(type = Openflow12Type.OFPT_QUEUE_GET_CONFIG_REPLY)
packet OpenflowQueueGetConfigReply(OpenflowHeaderV12) {
  uint16 port;
  @repeated(count = 6)
  uint8 pad;
  @repeated
  OpenflowPacketQueue queues; # List of configured queues.
}

@type_selector(stats_type = OpenflowStatsTypes.OFPST_QUEUE)
packet OpenflowQueueStatsRequest(OpenflowStatsRequest) {
  uint16 port_no;        # All ports if OFPT_ALL.
  @repeated(count = 2)
  uint8 pad;             # Align to 32-bits.
  uint32 queue_id;       # All queues if OFPQ_ALL.
}

@type_selector(stats_type = OpenflowStatsTypes.OFPST_QUEUE)
packet OpenflowQueueStats(OpenflowStatsReply) {
  uint16 port_no;
  @repeated(count = 2)
  uint8 pad;             # Align to 32-bits.
  uint32 queue_id;       # Queue i.d
  uint64 tx_bytes;       # Number of transmitted bytes.
  uint64 tx_packets;     # Number of transmitted packets.
  uint64 tx_errors;      # Number of packets dropped due to overrun.
}

